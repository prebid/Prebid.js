import _ from 'lodash';

const weightsUrl = `https://raw.githubusercontent.com/duckduckgo/tracker-radar/refs/heads/main/build-data/generated/api_fingerprint_weights.json`;
import fs from 'fs/promises';
import path from 'path';

const MIN_WEIGHT = 15;
const QUERY_DIR = path.join(import.meta.dirname, '.github/codeql/queries');
const TYPE_FILE_PREFIX = 'autogen_';

async function fetchWeights() {
  const weights = await fetch(weightsUrl).then(res => res.json());
  return Object.fromEntries(
    Object.entries(weights).filter(([api, weight]) => weight >= MIN_WEIGHT)
  );
}

const TUPLE_TPL = _.template(`
// this file is autogenerated, see fingerprintApis.mjs

class <%= name %> extends string {
<% fields.forEach(([type, name]) => {%>
  <%= type %> <%= name %>; <%}) %>
  
  <%= name %>() {<% values.forEach((vals, i) => { %>
      <% if(i > 0) {%> or <% }%>
      (<% vals.forEach(([name, value], j) => { %> <% if(j > 0) {%> and <% }%><%= name %> = <%= value %><%})%> )<%})%>
  }  
<% fields.forEach(([type, name]) => {%>
  <%= type %> get<%= name.charAt(0).toUpperCase() + name.substring(1) %>() {
    result = <%= name %>
  }
  <% }) %>
} 
`);


function makeTupleType(name, fields, values) {
  const quote = (val)  => typeof val === 'string' ? `"${val}"` : val;
  fields.unshift(['float', 'weight']);
  values = values.map((vals) => {
    return [
      ['this', quote(vals.pop())],
      ...fields.map(([_, name], i) => ([name, quote(vals[i])]))
    ]
  })
  return [
    name,
    TUPLE_TPL({
      name, fields, values
    })
  ];
}

function globalConstructor(matches) {
  return makeTupleType('GlobalConstructor', [], matches)
}

function globalTypeProperty(depth = 0) {
  const fields = Array.from(Array(depth + 1).keys()).map(i => (['string', `global${i}`]))
  return function (matches) {
    return makeTupleType(`GlobalTypeProperty${depth}`, fields, matches)
  }
}

function globalObjectProperty(depth, getPath) {
  const fields = Array.from(Array(depth + 1).keys()).map((i) => (['string', `global${i}`]))
  return function (matches) {
    return makeTupleType(
      `GlobalObjectProperty${depth}`,
      fields,
      matches.map(([weight, ...values]) => [weight, ...getPath(values), values[values.length - 1]])
    )
  }
}

function globalVar(matches) {
  return makeTupleType(
    'GlobalVar',
    [],
    matches
  );
}

function renderingContextProperty(matches) {
  const fields = [['string', 'contextType']];
  const contextMap = {
    'WebGLRenderingContext': 'webgl',
    'WebGL2RenderingContext': 'webgl2',
    'CanvasRenderingContext2D': '2d'
  }
  matches = matches.map(([weight, contextType, prop]) => [
    weight, contextMap[contextType], prop
  ]);
  return makeTupleType('RenderingContextProperty', fields, matches);
}

function eventProperty(matches) {
  const fields = [['string', 'event']];
  matches = matches.map(([weight, eventType, prop]) => [weight, eventType.toLowerCase(), prop])
  return makeTupleType('EventProperty', fields, matches);
}

function sensorProperty(matches) {
  return makeTupleType('SensorProperty', [], matches);
}

const API_MATCHERS = [
  [/^([^.]+)\.prototype.constructor$/, globalConstructor],
  [/^(Date|Gyroscope)\.prototype\.(.*)$/, globalTypeProperty()],
  [/^(Intl)\.(DateTimeFormat)\.prototype\.(.*)$/, globalTypeProperty(1)],
  [/^(Screen\.prototype|Notification|Navigator\.prototype)\.(.*)$/, globalObjectProperty(0,
    ([name]) => ({
      'Screen.prototype': ['screen'],
      'Notification': ['Notification'],
      'Navigator.prototype': ['navigator']
    }[name])
  )],
  [/^window\.(.*)$/, globalVar],
  [/^(WebGL2?RenderingContext|CanvasRenderingContext2D)\.prototype\.(.*)$/, renderingContextProperty],
  [/^(DeviceOrientation|DeviceMotion)Event\.prototype\.(.*)$/, eventProperty],
  [/^MediaDevices\.prototype\.(.*)$/, globalObjectProperty(1, () => ['navigator', 'mediaDevices'])],
  [/^Sensor.prototype\.(.*)$/, sensorProperty],
];

async function generateTypes() {
  const weights = await fetchWeights();
  const matches = new Map();
  Object.entries(weights).filter(([identifier, weight]) => {
    for (const [matcher, queryGen] of API_MATCHERS) {
      const match = matcher.exec(identifier);
      if (match) {
        if (!matches.has(matcher)) {
          matches.set(matcher, [queryGen, []]);
        }
        matches.get(matcher)[1].push([weight, ...match.slice(1)]);
        delete weights[identifier];
        break;
      }
    }
  });
  if (Object.keys(weights).length > 0) {
    console.warn(`The following APIs are weighed more than ${MIN_WEIGHT}, but no types were generated for them:`, JSON.stringify(weights, null, 2));
  }
  return Object.fromEntries(
    Array.from(matches.values())
      .map(([queryGen, matches]) => queryGen(matches))
  );
}

async function clearFiles() {
  for (const file of await fs.readdir(QUERY_DIR)) {
    if (file.startsWith(TYPE_FILE_PREFIX)) {
      await fs.rm(path.join(QUERY_DIR, file));
    }
  }
}

async function generateTypeFiles() {
  for (const [name, query] of Object.entries(await generateTypes())) {
    await fs.writeFile(path.join(QUERY_DIR, `autogen_fp${name}.qll`), query);
  }
}

export async function updateQueries() {
  await clearFiles();
  await generateTypeFiles();
}

