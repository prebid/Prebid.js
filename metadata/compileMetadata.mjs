import path from 'path';
import fs from 'fs';
import helpers from '../gulpHelpers.js';
import moduleMetadata from './modules.json' with {type: 'json'};
import coreMetadata from './core.json' with {type: 'json'};

import overrides from './overrides.mjs';
import {fetchDisclosure, getDisclosureUrl} from './storageDisclosure.mjs';

function matches(moduleName, moduleSuffix) {
  moduleSuffix = moduleSuffix.toLowerCase();
  const shortName = moduleName.toLowerCase().replace(moduleSuffix, '');
  return function ({componentName, aliasOf}) {
    const name = (aliasOf ?? componentName).toLowerCase();
    return name === shortName || (name.startsWith(shortName) && moduleSuffix.startsWith(name.slice(shortName.length)));
  };
}

const modules = {
  BidAdapter: 'bidder',
  AnalyticsAdapter: 'analytics',
  IdSystem: 'userId',
  RtdProvider: 'rtd'
};

async function metadataFor(metas) {
  const disclosures = {};
  for (const meta of metas) {
    if (meta.disclosureURL == null && meta.gvlid != null) {
      meta.disclosureURL = await getDisclosureUrl(meta.gvlid);
    }
    if (meta.disclosureURL) {
      const disclosure = await fetchDisclosure(meta);
      disclosures[meta.disclosureURL] = disclosure;
    }
  }
  return {
    'NOTICE': 'do not edit - this file is autogenerated by `gulp update-metadata`',
    disclosures,
    components: metas
  };
}

async function compileCoreMetadata() {
  const modules = coreMetadata.components.reduce((byModule, item) => {
    if (!byModule.hasOwnProperty(item.moduleName)) {
      byModule[item.moduleName] = [];
    }
    byModule[item.moduleName].push(item);
    delete item.moduleName;
    return byModule;
  }, {});
  for (let [moduleName, metadata] of Object.entries(modules)) {
    await updateModuleMetadata(moduleName, metadata);
  }
  return Object.keys(modules);
}

async function updateModuleMetadata(moduleName, metadata) {
  fs.writeFileSync(
    path.resolve(`./metadata/modules/${moduleName}.json`),
    JSON.stringify(await metadataFor(metadata), null, 2)
  );
}

async function compileModuleMetadata() {
  const processed = [];
  const found = new WeakSet();
  let err = false;
  for (const moduleName of helpers.getModuleNames()) {
    let predicate;
    for (const [suffix, moduleType] of Object.entries(modules)) {
      if (moduleName.endsWith(suffix)) {
        predicate = overrides.hasOwnProperty(moduleName)
          ? ({componentName, aliasOf}) => componentName === overrides[moduleName] || aliasOf === overrides[moduleName]
          : matches(moduleName, suffix);
        predicate = ((orig) => (entry) => entry.componentType === moduleType && orig(entry))(predicate);
        break;
      }
    }
    if (predicate) {
      const meta = moduleMetadata.components.filter(predicate);
      meta.forEach((entry) => found.add(entry));
      const names = new Set(meta.map(({componentName, aliasOf}) => aliasOf ?? componentName));
      if (names.size === 0) {
        console.error('Cannot determine module name for module file: ', moduleName);
        err = true;
      } else if (names.size > 1) {
        console.error('More than one module name matches module file:', moduleName, names);
        err = true;
      } else {
        await updateModuleMetadata(moduleName, meta);
        processed.push(moduleName);
      }
    }
  }

  const notFound = moduleMetadata.components.filter(entry => !found.has(entry));
  if (notFound.length > 0) {
    console.error('Could not find module name for metadata', notFound);
    err = true;
  }

  if (err) {
    throw new Error('Could not compile module metadata');
  }
  return processed;
}


export default async function compileMetadata() {
  const allModules = new Set((await compileCoreMetadata())
    .concat(await compileModuleMetadata()));
  fs.readdirSync('./metadata/modules')
    .map(name => path.parse(name))
    .filter(({name}) => !allModules.has(name))
    .forEach(({name}) => {
      const fn = `./metadata/modules/${name}.json`;
      console.info(`Removing "${fn}"`);
      fs.rmSync(fn);
    })

  const extraOverrides = Object.keys(overrides).filter(module => !allModules.has(module));
  if (extraOverrides.length) {
    console.warn('The following modules are mentioned in `metadata/overrides.mjs`, but could not be found:', JSON.stringify(extraOverrides, null, 2));
  }
}
