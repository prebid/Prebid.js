import path from 'path';
import fs from 'fs';
import helpers from '../gulpHelpers.js';
import moduleMetadata from './modules.json' with {type: 'json'};
import coreMetadata from './core.json' with {type: 'json'};

import overrides from './overrides.mjs';
import {fetchDisclosure, getDisclosureUrl, logErrorSummary} from './storageDisclosure.mjs';

const MAX_DISCLOSURE_AGE_DAYS = 14;

function matches(moduleName, moduleSuffix) {
  moduleSuffix = moduleSuffix.toLowerCase();
  const shortName = moduleName.toLowerCase().replace(moduleSuffix, '');
  return function ({componentName, aliasOf}) {
    const name = (aliasOf ?? componentName).toLowerCase();
    return name === shortName || (name.startsWith(shortName) && moduleSuffix.startsWith(name.slice(shortName.length)));
  };
}

const modules = {
  BidAdapter: 'bidder',
  AnalyticsAdapter: 'analytics',
  IdSystem: 'userId',
  RtdProvider: 'rtd'
};

function previousDisclosure(moduleName, {componentType, componentName, disclosureURL}) {
  return new Promise((resolve, reject) => {
    function noPreviousDisclosure() {
      console.info(`No previously fetched disclosure available for "${componentType}.${componentName}" (url: ${disclosureURL})`);
      resolve(null);
    }
    fs.readFile(moduleMetadataPath(moduleName), (err, data) => {
      if (err) {
        err.code === 'ENOENT' ? noPreviousDisclosure() : reject(err);
      } else {
        try {
          const disclosure = JSON.parse(data.toString()).disclosures?.[disclosureURL];
          if (disclosure == null || disclosure.disclosures == null) {
            noPreviousDisclosure();
          } else {
            const disclosureAgeDays = ((new Date()).getTime() - new Date(disclosure.timestamp).getTime()) /
              (1000 * 60  * 60 * 24);
            if (disclosureAgeDays <= MAX_DISCLOSURE_AGE_DAYS) {
              console.info(`Using previously fetched disclosure for ${componentType}.${componentName}" (url: ${disclosureURL}, disclosure is ${Math.floor(disclosureAgeDays)} days old)`);
              resolve(disclosure)
            } else {
              console.warn(`Previously fetched disclosure for ${componentType}.${componentName}" (url: ${disclosureURL}) is too old (${Math.floor(disclosureAgeDays)} days) and won't be reused`);
              resolve(null);
            }
          }
        } catch (e) {
          reject(e);
        }
      }
    })
  })

}

async function metadataFor(moduleName, metas) {
  const disclosures = {};
  for (const meta of metas) {
    if (meta.disclosureURL == null && meta.gvlid != null) {
      meta.disclosureURL = await getDisclosureUrl(meta.gvlid);
    }
    if (meta.disclosureURL) {
      const disclosure = {
        timestamp: new Date().toISOString(),
        disclosures: await fetchDisclosure(meta)
      };
      if (disclosure.disclosures == null) {
        Object.assign(disclosure, await previousDisclosure(moduleName, meta));
      }
      disclosures[meta.disclosureURL] = disclosure;
    }
  }
  return {
    'NOTICE': 'do not edit - this file is autogenerated by `gulp update-metadata`',
    disclosures,
    components: metas
  };
}

async function compileCoreMetadata() {
  const modules = coreMetadata.components.reduce((byModule, item) => {
    if (!byModule.hasOwnProperty(item.moduleName)) {
      byModule[item.moduleName] = [];
    }
    byModule[item.moduleName].push(item);
    delete item.moduleName;
    return byModule;
  }, {});
  for (let [moduleName, metadata] of Object.entries(modules)) {
    await updateModuleMetadata(moduleName, metadata);
  }
  return Object.keys(modules);
}

function moduleMetadataPath(moduleName) {
  return path.resolve(`./metadata/modules/${moduleName}.json`);
}

async function updateModuleMetadata(moduleName, metadata) {
  fs.writeFileSync(
    moduleMetadataPath(moduleName),
    JSON.stringify(await metadataFor(moduleName, metadata), null, 2)
  );
}

async function compileModuleMetadata() {
  const processed = [];
  const found = new WeakSet();
  let err = false;
  for (const moduleName of helpers.getModuleNames()) {
    let predicate;
    for (const [suffix, moduleType] of Object.entries(modules)) {
      if (moduleName.endsWith(suffix)) {
        predicate = overrides.hasOwnProperty(moduleName)
          ? ({componentName, aliasOf}) => componentName === overrides[moduleName] || aliasOf === overrides[moduleName]
          : matches(moduleName, suffix);
        predicate = ((orig) => (entry) => entry.componentType === moduleType && orig(entry))(predicate);
        break;
      }
    }
    if (predicate) {
      const meta = moduleMetadata.components.filter(predicate);
      meta.forEach((entry) => found.add(entry));
      const names = new Set(meta.map(({componentName, aliasOf}) => aliasOf ?? componentName));
      if (names.size === 0) {
        console.error('Cannot determine module name for module file: ', moduleName);
        err = true;
      } else if (names.size > 1) {
        console.error('More than one module name matches module file:', moduleName, names);
        err = true;
      } else {
        await updateModuleMetadata(moduleName, meta);
        processed.push(moduleName);
      }
    }
  }

  const notFound = moduleMetadata.components.filter(entry => !found.has(entry));
  if (notFound.length > 0) {
    console.error('Could not find module name for metadata', notFound);
    err = true;
  }

  if (err) {
    throw new Error('Could not compile module metadata');
  }
  return processed;
}


export default async function compileMetadata() {
  const allModules = new Set((await compileCoreMetadata())
    .concat(await compileModuleMetadata()));
  logErrorSummary();
  fs.readdirSync('./metadata/modules')
    .map(name => path.parse(name))
    .filter(({name}) => !allModules.has(name))
    .forEach(({name}) => {
      const fn = `./metadata/modules/${name}.json`;
      console.info(`Removing "${fn}"`);
      fs.rmSync(fn);
    })

  const extraOverrides = Object.keys(overrides).filter(module => !allModules.has(module));
  if (extraOverrides.length) {
    console.warn('The following modules are mentioned in `metadata/overrides.mjs`, but could not be found:', JSON.stringify(extraOverrides, null, 2));
  }
}
