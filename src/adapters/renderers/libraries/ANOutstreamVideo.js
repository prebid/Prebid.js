var ANOutstreamVideo =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Outstream Ad Renderer module.
	 * @module OutstreamRenderer
	 */

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var Outstream_AdUnit_Base_Object = __webpack_require__(1);
	//var utils = require('videoads-util-misc-general');
	//var prefix = "Outstream Renderer";
	var _logger = __webpack_require__(2);

	var _outstream_adunits = _outstream_adunits || [];
	var _pending_adunit_messages = _pending_adunit_messages || [];

	var TRACE_MESSAGE_PREFIX = "Outstream Renderer";

	/**
	 *  Combine 2 JSON objects, with 1 object overriding the other. If target of combinaiton is an object, the elements of that object will be combined
	 *  @param {Object} target - Object in which to populate values
	 *   @param {Object} souce - Object which to populate values into target with. Values in this object will override those in target if there is a collision
	 *
	 */
	function combineObjectsAndSubobjects(target, source) {
	    for (var key in source) {
	        if (source.hasOwnProperty(key)) {
	            //if the value is an object, but not an array (don't combine arrays)
	            if (target[key] !== null && typeof target[key] === "object" && !Array.isArray(target[key])) {//null also get handled as an object in javascript so it shouldn't go to the recursive logic (for VID-1978)
	                target[key] = combineObjectsAndSubobjects(target[key], source[key]);
	            } else {
	                target[key] = source[key];
	            }
	        }
	    }
	    return target;
	}


	function setInitialPlaybackOptions(playbackOptions, targetOptionsObject) {

	    //make sure the targetOptionsObject exists
	    targetOptionsObject = targetOptionsObject ? targetOptionsObject : {};

	    //playback options is an array (not sure why) so lets itereate through it
	    //and set options as we see them

	    var optionsSet = false;

	    if (playbackOptions && playbackOptions.length >= 1) {
	        switch (playbackOptions[0]) {
	            case "auto_play_sound_on":
	                targetOptionsObject.initialPlayback = "auto";
	                targetOptionsObject.initialAudio = "on";
	                optionsSet = true;
	                break;
	            case "auto_play_sound_off":
	                targetOptionsObject.initialPlayback = "auto";
	                targetOptionsObject.initialAudio = "off";
	                optionsSet = true;
	                break;
	            case "click_to_play":
	                targetOptionsObject.initialPlayback = "click";
	                targetOptionsObject.initialAudio = "unknown";
	                optionsSet = true;
	                break;
	            case "mouseover":
	                targetOptionsObject.initialPlayback = "mouseover";
	                targetOptionsObject.initialAudio = "unknown";
	                optionsSet = true;
	                break;
	            case "auto_play_sound_unknown":
	                targetOptionsObject.initialPlayback = "auto";
	                targetOptionsObject.initialAudio = "unknown";
	                optionsSet = true;
	                break;
	            case "max":
	                optionsSet = false;
	                break;
	        }

	    }

	    //if options haven't been set, use defaults
	    if (!optionsSet) {
	        targetOptionsObject.initialPlayback = "auto";
	        targetOptionsObject.initialAudio = "off";
	    }

	    return targetOptionsObject;
	}


	function sendParentIframeGeometryEventToAdUnit(scrollEventData) {
	    _logger.debug(TRACE_MESSAGE_PREFIX, "Parent iframe geometry update", scrollEventData);

	    if (_outstream_adunits) {
	        for (var i in _outstream_adunits) {
	            _outstream_adunits[i].adUnit.parentIframeGeometryUpdate(scrollEventData);
	        }
	    }
	}

	function setupParentIframeSizeChangeListener(scrollEventName) {
	    //listen for parent iframe scroll
	    try {
	        window[scrollEventName] = function(e) {
	            sendParentIframeGeometryEventToAdUnit(e);
	        };

	    } catch (e) {

	    }
	}

	function setupParentIframeGeometrySizeChanges(tagParams) {
	    //listen for parent iframe geometry event
	    if (tagParams.parentIframeGeometryEvent) {
	        setupParentIframeSizeChangeListener(tagParams.parentIframeGeometryEvent);
	    }

	    //make initial size call
	    if (typeof tagParams.parentIframeGeometryCb === "function") {
	        try {
	            tagParams.parentIframeGeometryCb.call(this, function(e) {
	                //rename patches until Playbuzz updated their events
	                e.windowHeight = e.innerHeight;
	                e.scrollY = e.scroll;
	                sendParentIframeGeometryEventToAdUnit(e);
	            });

	        } catch (e) {

	        }
	    }

	}

	function handleIncomingASTMessage(messageName, messagePayload, targetId) {
	    _logger.log("Got AST message ", messageName, " payload", messagePayload, " target", targetId);
	    var messageDelivered = false;
	    if (_outstream_adunits) {
	        //look at every ad unit
	        for (var i in _outstream_adunits) {
	            //if target id matches, or targetId is undefined (send to all existing instances)
	            if (!targetId || _outstream_adunits[i].id === targetId) {
	                //dispatch message into adunit
	                _outstream_adunits[i].adUnit.handleMessage(messageName, messagePayload);
	                messageDelivered = true;
	            }

	        }
	    }

	    //if we didn't find the id as active, hold the message until an ad unit with that id is created
	    //undefined target ids will be handled above, or dropped here
	    if (!messageDelivered && targetId) {
	        if (!_pending_adunit_messages[targetId]) {
	            _pending_adunit_messages[targetId] = {};
	        }

	        _pending_adunit_messages[targetId].push({
	            message: messageName,
	            payload: messagePayload
	        });
	    }
	}



	function sendPendingMessagesToNewAdUnit(ASTAdId, curOutstreamAdUnit) {
	    //if there are any pending adunit messages for this target
	    if (_pending_adunit_messages[ASTAdId]) {
	        for (var i in _pending_adunit_messages[ASTAdId]) {
	            //send the message to the target
	            curOutstreamAdUnit.adUnit.handleMessage(_pending_adunit_messages[ASTAdId][i].message, _pending_adunit_messages[ASTAdId][i].payload);
	        }
	        //remove the messages from the pending message array
	        delete _pending_adunit_messages[ASTAdId];
	    }
	}

	/**
	 *  Main entry point for the renderer. Calling this function will cause an attempt to render an ad.
	 * @param {Object} adData  - AST object containing tag data
	 * @param {Funciton} eventCB - Callback function to be called when ad events (display, end, error) occour
	 */
	function renderAd(adData, eventCB) {

	    //let's do this before any other checks so we can turn on logging as early as possible if needed
	    //even though we have a bit of repetition in our type checking
	    //make sure a failure here doesn't stop the ad from loading
	    try {
	        //try to see if we can read apntag.debug to set the debug level
	        if (typeof apntag !== "undefined" && typeof apntag.debug !== "undefined") {
	            _logger.setDebugLevel(apntag.debug);
	        } else {
	            //if we can't read apntag.debug, try debugLevel in rendererOptions
	            if (typeof adData !== "undefined" && typeof adData.rendererOptions !== undefined) {
	                _logger.setDebugLevel(adData.rendererOptions.debugLevel);
	            }
	        }
	    } catch (e) {}

	    _logger.info(TRACE_MESSAGE_PREFIX, 'Version: 3.0.15');


	    if (adData) {

	        _logger.log(TRACE_MESSAGE_PREFIX, "renderAd called with ad data " + adData.targetId + " ", adData);

	        var ASTAdId = adData.uuid;
	        var tagParams = adData.rendererOptions;

	        var impbusOptions;
	        var videoNodeOptions;

	        //these are the options that are defined in the Placement from impbus
	        var rendererConfigFromServer = {};


	        //if adRepsonse.ad is specified
	        if (adData.adResponse && adData.adResponse.ad) {
	            impbusOptions = adData.adResponse.ad;
	            if (adData.adResponse.ad.video) {
	                videoNodeOptions = adData.adResponse.ad.video;
	            }

	            //attempt to parse renderer config options from impbus
	            if (adData.adResponse.ad.renderer_config) {
	                try {
	                    rendererConfigFromServer = JSON.parse(adData.adResponse.ad.renderer_config);
	                } catch (e) {}
	            }

	        }


	        //if tagParams is undefined, create an empty object
	        tagParams = tagParams ? tagParams : {};

	        //if impbusOptions is undefined, create an empty object
	        impbusOptions = impbusOptions ? impbusOptions : {};

	        //if videoNodeOptions is undefined, create an empty object
	        videoNodeOptions = videoNodeOptions ? videoNodeOptions : {};

	        var tempContent = adData.adResponse.content;

	        //shim to bring video options up a level
	        tagParams = combineObjectsAndSubobjects(tagParams, videoNodeOptions);

	        setupParentIframeGeometrySizeChanges(tagParams);

	        //using a combined object with all options in it allows us to control the precedence of local vs impbus options
	        var combinedOptionsObj = combineObjectsAndSubobjects(impbusOptions, tagParams);

	        //combine the renderer config object, with local options taking precednece
	        combinedOptionsObj = combineObjectsAndSubobjects(rendererConfigFromServer, combinedOptionsObj);

	        //try to combine the video object from the mediaiton ad node into our combined object
	        //name of element with video node in it is defined in content_source
	        var contentSourceType = impbusOptions.content_source;
	        if (contentSourceType) {
	            if (impbusOptions[contentSourceType] && impbusOptions[contentSourceType].video) {
	                combinedOptionsObj = combineObjectsAndSubobjects(combinedOptionsObj, impbusOptions[contentSourceType].video);
	            }
	        }


	        //translate from how impbus defines initial playback options to outstream's representation
	        combinedOptionsObj = setInitialPlaybackOptions(combinedOptionsObj.playback_methods, combinedOptionsObj);


	        //convert impbus video->supports_skippable to skippable->enabled
	        //ensure combinedOptionsObj has a video node, even if it's empty
	        if (!combinedOptionsObj.video) {
	            combinedOptionsObj.video = {};
	        }

	        //ensure combinedOptionsObj has a skippable node, even if it's empty
	        if (combinedOptionsObj.video && !combinedOptionsObj.video.skippable) {
	            combinedOptionsObj.video.skippable = {};
	        }

	        //if supports_skippable is set, and video skippable is not set, or video skippable enabled is not set
	        if ((combinedOptionsObj.video && typeof combinedOptionsObj.video.supports_skippable !== undefined) && (typeof combinedOptionsObj.video.skippable.enabled === undefined)) {
	            combinedOptionsObj.video.skippable.enabled = combinedOptionsObj.video.supports_skippable;
	        }

	        //translate impbus vs outstream names for some objects
	        combinedOptionsObj.vastXml = tempContent || combinedOptionsObj.content;
	        combinedOptionsObj.targetId = adData.targetId;
	        combinedOptionsObj.targetElementId = combinedOptionsObj.targetId;

	        combinedOptionsObj.width = videoNodeOptions.player_width;
	        combinedOptionsObj.height = videoNodeOptions.player_height;

	        //ensure we have a flash options object
	        combinedOptionsObj.flash = combinedOptionsObj.flash ? combinedOptionsObj.flash : {};

	        //use a default URL For the flash player if it's not specified
	        if (!combinedOptionsObj.flash.swf) {
	            combinedOptionsObj.flash.swf = 'http' +
	                (('https:' === window.document.location.protocol) ? 's' : '') +
	                '://acdn.adnxs.com/video/static/player/flash/adplayer/1.3.8/AppnexusFlashPlayer.swf';
	        }

	        //if options is setting a debug level (as in from a placement object), let's use it over anything else.
	        if( combinedOptionsObj.forceDebugLevel && typeof combinedOptionsObj.forceDebugLevel === 'number' && _logger){
	            _logger.setDebugLevel(combinedOptionsObj.forceDebugLevel);
	        }

	        /*
	                var xmlDoc;
	                if (window.DOMParser) {
	                    parser = new DOMParser();
	                    xmlDoc = parser.parseFromString(combinedOptionsObj.vastXml, "text/xml");
	                } else // Internet Explorer
	                {
	                    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
	                    xmlDoc.async = false;
	                    xmlDoc.loadXML(combinedOptionsObj.vastXml);
	                }

	                console.log(">>>>>", xmlDoc);
	        */

	        try {
	            var vastTagURLRegex = /<VASTAdTagURI>(.+)<\/VASTAdTagURI>/ig;
	            var vastTagURIRegexResult = vastTagURLRegex.exec(combinedOptionsObj.vastXml);
	            if (vastTagURLRegex && vastTagURIRegexResult.length > 0) {
	                vastTagURIRegexResult.splice(0, 1);
	                delete vastTagURIRegexResult.index;
	                delete vastTagURIRegexResult.input;

	                //remove CDATA wrapper if it exists
	                var cdataRegex = /<!\[CDATA\[(.+)]]>/ig;
	                var cdataRegexResult = cdataRegex.exec(vastTagURIRegexResult[0]);
	                cdataRegexResult.splice(0, 1);
	                delete cdataRegexResult.index;
	                delete cdataRegexResult.input;

	                //if no CDATA was removed, use the previous regex result array
	                if (!cdataRegexResult || cdataRegexResult.length === 0) {
	                    cdataRegexResult = vastTagURIRegexResult;
	                }

	                _logger.log(TRACE_MESSAGE_PREFIX, "First VASTAdTagURI found in incoming VAST Tag:", '\n', cdataRegexResult[0]);
	            } else {
	                _logger.log(TRACE_MESSAGE_PREFIX, "No VASTAdTagURI found, perhaps it is a non-wrapped VAST tag, or CSM");
	            }
	        } catch (ex) {}

	        combinedOptionsObj.ASTadId = ASTAdId;
	        combinedOptionsObj.targetWindow = window;
	        combinedOptionsObj.eventCB = eventCB;

	        /*
	        combinedOptionsObj.eventCB = function(){
	            console.log("Outstream CB: ", arguments)
	            eventCB.call(this,arguments);
	        }
	        */

	        combinedOptionsObj.enableInlineVideoFullscreenButton = true;

	        _logger.info("Outstream Renderer calling ad unit with values " + combinedOptionsObj.targetId + " ", combinedOptionsObj);

	        var curOutstreamAdUnit = new Outstream_AdUnit_Base_Object();

	        // This token is replaced with testing-only code in gulp file (similar to tokens for outstream and flash version numbers)
	        // if doing a build for testing, stubbed out otherwise.


	        curOutstreamAdUnit.init(combinedOptionsObj);
	        _outstream_adunits.push({
	            id: adData.targetId,
	            adUnit: curOutstreamAdUnit
	        });
	        sendPendingMessagesToNewAdUnit(ASTAdId, curOutstreamAdUnit);
	        //initialize outstream ad
	    } else {
	        _logger.debug("Outstream Renderer - no ad data");

	    }
	}

	//enable for RAD-828/VID-1332 support

	module.exports = {
	    renderAd: renderAd,
	    notify: handleIncomingASTMessage
	};


	//disable for RAD-828/VID-1332 support
	//module.exports = renderAd;


	//if AST exists, register our handler callback on it
	var rendererTypeId = 2;
	if (typeof apntag === 'object' && typeof apntag.registerRenderer === 'function') {
	    apntag.registerRenderer(rendererTypeId, module.exports);
	} else {
	    apntag_pendingRenderers = typeof apntag_pendingRenderers !== 'undefined' ? apntag_pendingRenderers : [];
	    apntag_pendingRenderers.push({
	        type: rendererTypeId,
	        handler: renderAd,
	        notify: handleIncomingASTMessage
	    });
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * OutstreamAdunit
	 * @module OutstreamAdunit
	 */


	var prefixOfLog = "Outstream_Main";
	var APN_Logger = __webpack_require__(2);
	// var debug = function (message) {
	//     APN_Logger.verbose(message, prefixOfLog);
	// };
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	var info = function (message) {
	    APN_Logger.info(message, prefixOfLog);
	};


	/**
	 * video player manager object
	 * @type {*|exports|module.exports}
	 */
	var PlayerManager_object = __webpack_require__(3);
	var AdHandler = __webpack_require__(28);


	/**
	 * outstreamadunit class start point is init()
	 */
	var outstreamadunit = function () {

	    info("Outstream starts to initialize");

	    //flags for Outstream
	    this.playerManager = Object.create(PlayerManager_object);//clone video player manager object for multiple instances
	    this.disableCollapse = undefined;
	    this.targetElementId = undefined;
	    this.ASTadId = undefined;
	    this.isDoneLoadVideo = false;//flag to notify video load
	    this.isAlreadyCompleted = false;//flag to avoid to invoke adComplete twice
	    this.triggerCheckFocus = null;//id of interval for checking a focus in window
	    this.rWindow = window.self;//Reference of window object
	    this.targetElement = {};//Object for div including video player
	    this.videoPlayerObjectElement = {};//return video object's element
	    this.videoIsreadyToPlay = false;//Return true if video is ready to play when video object loaded metadata from server.
	    this.isVideoRendered = false;//Return true if video is ready to play when video object loaded metadata from server.Especially this is used for videoRead
	    this.hasFocus = false;//detecting document has focus every 0.5 seconds
	    this.isFlash = false;
	    this.animationSpeed = undefined;
	    this.isExpandTransitionCompleted = false;
	    this.isAreadyTerminated = false;//flag to avoid double terminating
	    this.shouldResizeByFullscreenChange = false;
	    this.intervalIdForDetectAndPlay = undefined;
	    this.isCollapseEnd = false;
	    this.isCollapseStart = false;
	    this.isAdComplete = false;
	    this.TIME_TO_REVERIFY = 100;
	    this.isMutedByViewability = false;
	    this.doneInitialPlayback = false;
	    this.originalSize = {width: 0, height: 0};
	    this.sideStream = null;
	    this.firstAdAttempted = false;
	    this.viewableDetector = {};
	    this.isOkToPlayFromPublisher = true;
	    this.isTerminatedByPublisher = false;
	    this.currentEventFromCrossDomainWindow = {offsetTop:0,windowHeight:0};
	    this.isExpanded = false;
	    this.rWindowForPublisher = null;
	    this.isWindowTopAccessible = true;
	    this.options = null;
	    this.haveVideoThresholdForSideStream = false;
	    this.isExpandedWhenFlash = false;
	    this.sizeObj = {};//to save orignal size and final size of Outstream
	    this.DEFAULT_OPTIONS_FOR_OUTSTREAM = __webpack_require__(45);
	    this.cbType = {loaded: "loaded", ended: "ended", error: "error", impression: "impression"};//define callback type for AST tag
	    this.cbNotificationType = {error: "error", adComplete: "adComplete", expandStart: "expandStart", expandEnd: "expandEnd", collapseStart: "collapseStart", collapseEnd: "collapseEnd", timeout: "timeout", size: "renderedPlayerSize", waterfall :"waterfall"};//define cbNotifications
	    this.doneUserActionForInitiateOutstream = false;
	    this.parentIframeIsModal = false;

	    this.elementToCheckTopMost = null;
	    this.rateOfBeaconsForTopMostCheck = null;




	    //major object
	    var outstreamSelf = this;//main object instantiated to point this module itself internally
	    this.videoPlayer = PlayerManager_object;//expose video player for having backward compativbility
	    this.AdHandler = AdHandler;//expose AdHandler for having backward compativbility


	    //internal modules
	    var Initialize = __webpack_require__(46)(outstreamSelf);
	    var Termination = __webpack_require__(50)(outstreamSelf);
	    var Mobile = __webpack_require__(51)(outstreamSelf);
	    var Waterfall = __webpack_require__(52)(outstreamSelf);
	    var ExternalInterface = __webpack_require__(53)(outstreamSelf);
	    var Media = __webpack_require__(54)(outstreamSelf);
	    var Events = __webpack_require__(55)(outstreamSelf);


	    //Initialize
	    this.init = Initialize.init;//starting point of this adUnit
	    this.start = Initialize.start;
	    this.setInitialVariable = Initialize.setInitialVariable;
	    this.getTargetWindow = Initialize.getTargetWindow;
	    this.checkTopWindow = Initialize.checkTopWindow;


	    //Mobile
	    this.createAndroidIframes = Mobile.createAndroidIframes;
	    this.handleFullscreen = Mobile.handleFullscreen;
	    this.fnRotationChange = Mobile.fnRotationChange;
	    this.resizeOutstreamArea = Mobile.resizeOutstreamArea;


	    //Waterfall
	    this.cleanupTargetElement = Waterfall.cleanupTargetElement;
	    this.cleanupPreviousFlashElement = Waterfall.cleanupPreviousFlashElement;


	    //External Interface
	    this.handleMessage = ExternalInterface.handleMessage;//handle message can be called by renderer to send ast messages and payloads to outstream
	    this.parentIframeGeometryUpdate = ExternalInterface.parentIframeGeometryUpdate;//public method to be invoked by ASTRenderer
	    this.handleOkToPlayAd = ExternalInterface.handleOkToPlayAd;
	    this.cbNotification = ExternalInterface.cbNotification;
	    this.eventCB = ExternalInterface.eventCB;
	    this.cbNotification_internal = ExternalInterface.cbNotification_internal;
	    this.eventCB_internal = ExternalInterface.eventCB_internal;
	    this.reportFinalSize = ExternalInterface.reportFinalSize;

	    //Events and AdUnit behavior
	    this.listenerBlur = Events.listenerBlur;
	    this.listenerFocus = Events.listenerFocus;
	    this.setIsExpanded = Events.setIsExpanded;
	    this.expandArea = Events.expandArea;
	    this.detectAndPlay = Events.detectAndPlay;
	    this.isElementVisible = Events.isElementVisible;


	    //Media
	    this.isPlayingVideo = Media.isPlayingVideo;
	    this.sendPlaySignalToVideoPlayerExplicit = Media.sendPlaySignalToVideoPlayerExplicit;
	    this.sendPlaySignalToVideoPlayer = Media.sendPlaySignalToVideoPlayer;
	    this.sendPauseSignalToVideoPlayerExplicit = Media.sendPauseSignalToVideoPlayerExplicit;
	    this.sendPauseSignalToVideoPlayer = Media.sendPauseSignalToVideoPlayer;


	    //Termination
	    this.terminateAll = Termination;


	};

	module.exports = outstreamadunit;
	/*
	 //public method
	 this.init = function (_options) {
	 this.injectEvent = function (e) {
	 this.videoPlayer = PlayerManager_object;//expose video player for having backward compativbility
	 this.AdHandler = AdHandler;//expose AdHandler for having backward compativbility
	 */


/***/ },
/* 2 */
/***/ function(module, exports) {

	/**
	 * Client Side Logging module.
	 * @module Logging
	 */


	//Note that we have an excessive amount of try/catch blocks in this code.
	//That is intentional. Logging should never break the features which are using it

	var TRACE_LEVEL_SILENT = 0;
	var TRACE_LEVEL_ALWAYS = 1;
	var TRACE_LEVEL_ERROR = 2;
	var TRACE_LEVEL_WARN = 3;
	var TRACE_LEVEL_INFO = 4;
	var TRACE_LEVEL_LOG = 5;
	var TRACE_LEVEL_DEBUG = 6;
	var TRACE_LEVEL_VERBOSE = 6;

	var LOCAL_STORAGE_KEY_NAME = "AppNexus_Page_Debug_Log_Level";

	//not an actual debug level, but used as a shortcut so we always
	//know what the max debug level is
	var TRACE_LEVEL_ALL = TRACE_LEVEL_DEBUG;
	var TRACE_LEVEL_DEFAULT = TRACE_LEVEL_SILENT;

	//the current debug level to use
	var _curDebugLevel = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via querystring
	var _debugLevelQueryString = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via localStorage
	var _debugLevelLocalStorage = TRACE_LEVEL_DEFAULT;

	//the debug level that was set via call to setDebugLevel
	var _debugLevelFunctionSet = TRACE_LEVEL_DEFAULT;

	function getCurrentTimeString() {
	    var dateToReturn = "";
	    try {
	        var curDate = new Date();
	        //  try{
	        //     dateToReturn = curDate.toISOString();
	        // }catch(ex){
	        dateToReturn = curDate.getHours() + ":" + curDate.getMinutes() + ":" + curDate.getSeconds() + "." + curDate.getMilliseconds();

	        //}
	    } catch (e) {}
	    return dateToReturn;

	}

	function getTraceMethodName(messageLogLevel) {
	    switch (messageLogLevel) {
	        case 0:
	            break;
	        case 1:
	            return 'always';
	        case 2:
	            return 'error';
	        case 3:
	            return 'warn';
	        case 4:
	            return 'info';
	        case 5:
	            return 'log';
	        case 6:
	            return 'debug';
	        case 7:
	            return 'verbose';
	        default:
	            break;
	    }
	}

	function traceMessageAtLevel(messageLogLevel, args) {

	    try {
	        //if method has been defined, and the correct debug level has been set, log it
	        if (typeof messageLogLevel !== 'undefined' && okToLogMessage(messageLogLevel)) {
	            if (console) {
	                var messagePrefix = "[APN";
	                var methodToUse = getTraceMethodName(messageLogLevel);

	                //if console message doesn't exist, use 'log' and
	                //set the original method in the message prefix
	                if (!console[methodToUse]) {
	                    messagePrefix += "-" + methodToUse;
	                    methodToUse = 'log';
	                }
	                messagePrefix += "]";
	                messagePrefix += "[" + getCurrentTimeString() + "]";

	                args.splice(0, 0, messagePrefix);
	                //from http://tobyho.com/2012/07/27/taking-over-console-log/
	                if (console[methodToUse].apply) {
	                    console[methodToUse].apply(console, args);
	                } else {
	                    var message = Array.prototype.slice.apply(args).join('');
	                    console[methodToUse](message);
	                }
	            }
	        }
	    } catch (e) {}
	}


	//get a named parameter from the querystring
	function getParameterByName(name) {
	    //accesing window might fail at the browser level, we can't really test for it,
	    //so there are a few nested try/catch blocks here
	    try {
	        var urlToSearch = '';
	        //try checking the topmost window, and if not, use current window
	        try {
	            urlToSearch = window.top.location.search;
	        } catch (e) {
	            try {
	                urlToSearch = window.location.search;
	            } catch (e) {}
	        }

	        var regexS = '[\\?&]' + name + '=([^&#]*)';
	        var regex = new RegExp(regexS);
	        var results = regex.exec(urlToSearch);
	        if (results === null) {
	            return '';
	        }
	        return decodeURIComponent(results[1].replace(/\+/g, ' '));
	    } catch (e) {
	        return '';
	    }
	}

	function parseDebugLevelInput(incomingDebugLevel) {
	    var debugLevelToReturn = TRACE_LEVEL_DEFAULT;
	    try {
	        if (typeof incomingDebugLevel !== "undefined") {
	            var debugLevelToParseInt = parseInt(incomingDebugLevel);
	            //if level is an integer, treat it as such
	            if (!isNaN(debugLevelToParseInt)) {
	                debugLevelToReturn = debugLevelToParseInt;
	            } else {
	                if (typeof incomingDebugLevel === "boolean") {
	                    if (incomingDebugLevel) {
	                        debugLevelToReturn = TRACE_LEVEL_ALL;
	                    } else {
	                        debugLevelToReturn = TRACE_LEVEL_SILENT;
	                    }
	                } else {
	                    //not an integer or boolean, treat it as a string
	                    incomingDebugLevel = incomingDebugLevel.toUpperCase();
	                    if (incomingDebugLevel === "TRUE") {
	                        debugLevelToReturn = TRACE_LEVEL_ALL;
	                    } else {
	                        if (incomingDebugLevel === "FALSE") {
	                            debugLevelToReturn = TRACE_LEVEL_SILENT;
	                        }
	                    }
	                }
	            }
	        }
	    } catch (e) {}

	    return debugLevelToReturn;
	}

	function getLogLevelFromLocalStorage() {
	    try {
	        if (localStorage) {
	            return localStorage.getItem(LOCAL_STORAGE_KEY_NAME);
	        }
	    } catch (e) {
	        //default debug level is returned if the key doesn't exist.
	        //https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem
	        return TRACE_LEVEL_DEFAULT;
	    }
	}

	//determine the maximum debug level from the page URL
	function setDebugLevelFromPage() {
	    try {
	        //keep track of the new level
	        _debugLevelQueryString = parseDebugLevelInput(getParameterByName("ast_debug").toUpperCase());
	        _debugLevelLocalStorage = parseDebugLevelInput(getLogLevelFromLocalStorage());

	        //the highest (least restrictive debug level) always wins
	        _curDebugLevel = Math.max(Math.max(_debugLevelQueryString, _debugLevelLocalStorage), _curDebugLevel);

	    } catch (e) {}
	}

	function handleSetDebugLevel(newDebugLevel) {
	    try {
	        //keep track of the new level
	        _debugLevelFunctionSet = parseDebugLevelInput(newDebugLevel);

	        //the highest (least restrictive debug level) always wins
	        _curDebugLevel = Math.max(Math.max(_debugLevelQueryString, _debugLevelFunctionSet), _curDebugLevel);

	    } catch (e) {}
	}

	function okToLogMessage(level) {
	    return level <= _curDebugLevel; // getReqestedMaxDebugLevel();
	}


	//DEPRECATED
	function tryLogMessageLegacy(level, message, source) {
	    try {
	        var messageToLog = "[APN-" + level + "-" + new Date().toISOString() + "] ";
	        if (source !== null && source && source.length > 0) {
	            messageToLog += source + ">";
	        }
	        messageToLog += message;

	        if (okToLogMessage(level)) {
	            console.log(messageToLog);
	        }
	    } catch (ex) {
	        if (okToLogMessage(level)) {
	            console.log(ex);
	        }
	    }
	}

	module.exports = {


	    /**
	     * Call the appropriate trace method at the given level
	     * @param (string) debugLevel = Level to debug at
	     */
	    traceAtLevel: function() {
	        try {
	            if (arguments.length > 0) {
	                var targetTraceLevel = arguments[0];
	                var argsWithoutTraceLevel = Array.prototype.slice.call(arguments, 1);
	                traceMessageAtLevel.call(this, targetTraceLevel, argsWithoutTraceLevel);
	            }
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "always" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "log" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.log style logging.
	     */
	    always: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_ALWAYS, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },


	    /**
	     * If the logging level for type "error" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "error" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.error style logging.
	     */
	    error: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_ERROR, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "log" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "log" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.log style logging.
	     */
	    log: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_LOG, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "warn" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "warn" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.warn style logging.
	     */
	    warn: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_WARN, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "info" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "info" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.info style logging.
	     */
	    info: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_INFO, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "debug" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "debug" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.debug style logging.
	     */
	    debug: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_DEBUG, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * If the logging level for type "verbose" or higher is set, output message to browser's console log
	     * With the [APN] prefix and styled with the browser's console "debug" level trace style
	     * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Outputting_text_to_the_console
	     * for more details about how to use console.debug style logging.
	     */
	    verbose: function() {
	        try {
	            traceMessageAtLevel.call(this, TRACE_LEVEL_VERBOSE, Array.prototype.slice.call(arguments));
	        } catch (e) {}
	    },

	    /**
	     * @deprecated - use other logging methods in this library
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
	     */
	    handleLogDebugLegacySupport: function(message, source) {
	        /*
	        var mainArguments = Array.prototype.slice.call(arguments);
	        mainArguments.unshift("DEBUG");
	        */
	        try {
	            tryLogMessageLegacy(TRACE_LEVEL_LOG, message, source);
	        } catch (e) {}
	    },

	    /**
	     * Sets debug level for logger
	     * @param (string) level = Debug level to use
	     */
	    setDebugLevel: function(newLevel) {
	        try {
	            handleSetDebugLevel(newLevel);
	        } catch (e) {}
	    },


	    /**
	     * Checks if specified trace level will be emitted given the current trace level settings.
	     * @param (Number) levelToCheck = Debug level to check
	     */
	    isTraceLevelActive: function(levelToCheck) {
	        try {
	            return okToLogMessage(levelToCheck);
	        } catch (e) {
	            return false;
	        }
	    },

	    /** @constant {number} */
	    TRACE_LEVEL_ALWAYS: TRACE_LEVEL_ALWAYS,

	    /** @constant {number} */
	    TRACE_LEVEL_ERROR: TRACE_LEVEL_ERROR,

	    /** @constant {number} */
	    TRACE_LEVEL_WARN: TRACE_LEVEL_WARN,

	    /** @constant {number} */
	    TRACE_LEVEL_INFO: TRACE_LEVEL_INFO,

	    /** @constant {number} */
	    TRACE_LEVEL_LOG: TRACE_LEVEL_LOG,

	    /** @constant {number} */
	    TRACE_LEVEL_DEBUG: TRACE_LEVEL_DEBUG,

	    /** @constant {number} */
	    TRACE_LEVEL_VERBOSE: TRACE_LEVEL_VERBOSE
	};


	//look in the query string for debug level
	setDebugLevelFromPage();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Ad Video Player Manager module.
	 * @module AdVideoPlayerManager
	 */

	//define reference of required modules
	var VideoJSPlayer = __webpack_require__(4);
	var BuildPlayerObj = __webpack_require__(7);
	var JSVpaidPlayer = __webpack_require__(21);
	var ExtendDefaultOption = __webpack_require__(22);
	var VideoSizeHandler = __webpack_require__(20);
	var Utils = __webpack_require__(9);
	var DelayEventHandler = Utils.DelayEventHandler;
	var unique = Utils.unique();
	var CustomSkinning = __webpack_require__(23);
	var ViewabilityTracking = __webpack_require__(25);
	var AutoplayHandler = __webpack_require__(27);

	var CONST_MESSAGE_VIDEO_FAILED = "'video_failed' reported from Flash player";
	var UID = new Date().getTime() + Math.floor(Math.random() * 10000);
	var externalNameOfVideoPlayer = "APNVideo_Player_" + UID;


	var prefixOfLog = "[PlayerManager_Main]";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	var error = function (message) {
	    APN_Logger.error(prefixOfLog, message);
	};
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };


	var isIE11 = function () {
	    var index = navigator.userAgent.indexOf("Trident/7.0");
	    return (index > -1);
	};

	//for VID-1551
	var EVENTS_HAVE_TO_FILTER_OUT = ["AdPaused", "AdVolumeChange"];

	var EVENTS_RESTRICTED_SUPPRESSING = [
	    "AdLoaded",
	    // "AdStarted", //need to disscuss with Vikki or Jeff but I'm assuming this also should suppressed because the startAd will be invoked by programmatically instead of human activity
	    "AdStopped",
	    "AdSkippableStateChange",
	    "AdLinearChange",
	    "AdDurationChange",
	    "AdRemainingTimeChange",
	    "AdLog",
	    "AdError"
	];

	var ERROR_TYPE_VAST = 1;//vast-error (one of the error codes specified in the VAST spec)
	var VAST_ERROR_TIMEOUT = 402;
	var VAST_ERROR_UNDEFINED = 900;
	var VAST_ERROR_VIDEOFAILED = 405;


	/*
	 apply Vikki and Eugene's following opinion
	 We proposed to change initialPlayback to auto, initialAudio to off. Add the following options: vpaidTimeout : 5000, waterfallTimeout : 30000, waterfallSteps : -1
	 */
	//define default option for playerManager which can be overrided if it deosn't exists
	var DEFAILT_OPTIONS_FOR_PLAYER_MANAGER = {
	    "initialPlayback": "auto",
	    "initialAudio": "off",
	    "skippable": {
	        "enabled": true,
	        "allowOverride": false,
	        "videoThreshold": 15,
	        "videoOffset": 5,
	        "skipLocation": "top-left",
	        "skipText": "Video can be skipped in %%TIME%% seconds",
	        "skipButtonText": "SKIP"
	    },
	    "adText": "Ad",
	    "showMute": true,
	    "showVolume": true,
	    "showProgressBar": true,
	    "showPlayToggle": true,
	    "showBigPlayButton": true,
	    "allowFullscreen": true,
	    "playerSkin": {
	        "customPlayerSkin": "",
	        "controlBarHeight": 30,
	        "topDividerColor": "#606060",
	        "bottomDividerColor": "#606060",
	        "topDividerWidth": 1,
	        "bottomDividerWidth": 1
	    },
	    "enableInlineVideoForIos": true,
	    "delayExpandUntilVPAIDInit": false,
	    "delayExpandUntilVPAIDImpression": false,
	    "flash": {"swf": "http://acdn.adnxs.com/video/player/vastPlayer/AppnexusFlashPlayer.swf"},
	    "vpaidTimeout": 5000,
	    "waterfallTimeout": 30000,
	    "waterfallSteps": -1,
	    "fixedSizePlayer": true,
	    "disableTopBar": false,
	    "sideStream": {
	        "enabled": false,
	        "position": "bottom-right",
	        "xOffset": 0,
	        "yOffset": 0,
	        "space": "empty"
	    },
	    "sideStreamObject": {},
	    "preloadInlineAudioForIos": false,
	    "controlBarPosition": "over",
	    "customPlayerSkinCss": "",
	    "customButton": {
	        "enabled": false,
	        "url": "",
	        "altText": "",
	        "imageSrc": "",
	        "imgWidth": 50,
	        "imgHeight": 30
	    },
	    "enableNativeInline": false,
	    "androidDSOverride": false,
	    "cbNotification": function () {
	    },
	    "parentIframeIsModal": false,
	    "learnMore": {
	        "enabled": false,
	        "clickToPause": true,
	        "text": "Learn More",
	        "separator": "-"
	    },
	    "playerContextId": "anadvideoplayer",
	    "data": {
	        "skipOffset": "",
	        "durationMsec": null,
	        "skipOffsetMsec": null,
	        "isVastVideoSkippable": false,
	        "vastProgressEvent": {},
	        "vastDurationMsec": null
	    },
	    "test": function () {
	    }
	};


	/**
	 * adVideoPlayerManager function
	 * @type {{externalNameOfVideoPlayer: string, videoPlayerObj, options: {}, adVideoPlayer: {}, callbackForAdUnit: {}, vpaidData: {}, iframeVideoWrapper: {}, isPlayingVideo: boolean, isDoneInitialPlay: boolean, isFullscreen: boolean, heightOffset: number, explicitPaused: boolean, aspectRatio: number, videoObjectId: {}, isViewable: boolean, isSkipped: boolean, isCompleted: boolean, isMuted: boolean, isExplicitMuted: boolean, isChrome: boolean, videojs_vpaid, overlayPlayer: boolean, forceToSkip: boolean, ExtendDefaultOption, delayEventHandler: null, pausedByViewability: boolean, init: adVideoPlayerManager.init, getValueFromPlayer: adVideoPlayerManager.getValueFromPlayer, isIosInlineRequired: adVideoPlayerManager.isIosInlineRequired, decidePlayer: adVideoPlayerManager.decidePlayer, buildPlayer: adVideoPlayerManager.buildPlayer, getPlayerStatus: adVideoPlayerManager.getPlayerStatus, notifyPlayer: adVideoPlayerManager.notifyPlayer, load: adVideoPlayerManager.load, play: adVideoPlayerManager.play, pause: adVideoPlayerManager.pause, explicitPause: adVideoPlayerManager.explicitPause, explicitPlay: adVideoPlayerManager.explicitPlay, mute: adVideoPlayerManager.mute, explicitMute: adVideoPlayerManager.explicitMute, unmute: adVideoPlayerManager.unmute, explicitUnmute: adVideoPlayerManager.explicitUnmute, mouseIn: adVideoPlayerManager.mouseIn, mouseOut: adVideoPlayerManager.mouseOut, destroy: adVideoPlayerManager.destroy, destroyWithoutSkip: adVideoPlayerManager.destroyWithoutSkip, getVideoObject: adVideoPlayerManager.getVideoObject, handlePlayerNotification: adVideoPlayerManager.handlePlayerNotification, handleOverlayNotification: adVideoPlayerManager.handleOverlayNotification, notifyVpaidEvent: adVideoPlayerManager.notifyVpaidEvent, notifyVpaidEvent_internal: adVideoPlayerManager.notifyVpaidEvent_internal, setChromeSize: adVideoPlayerManager.setChromeSize, click: adVideoPlayerManager.click, getRapamsAndExtensions: adVideoPlayerManager.getRapamsAndExtensions, dispatchEventToAdunit: adVideoPlayerManager.dispatchEventToAdunit, dispatchEventToAdunit_internal: adVideoPlayerManager.dispatchEventToAdunit_internal, resizeVideo: adVideoPlayerManager.resizeVideo, isIosInlineRequired: adVideoPlayerManager.isIosInlineRequired, resizePlayer: adVideoPlayerManager.resizePlayer, getFinalSize: adVideoPlayerManager.getFinalSize, log: log, debug: debug}}
	 */
	var adVideoPlayerManager = {

	    //binding objects for sub module
	    externalNameOfVideoPlayer: externalNameOfVideoPlayer,
	    videoPlayerObj: VideoJSPlayer,
	    autoplayHandler: AutoplayHandler,
	    mobileSupport: AutoplayHandler,//added for providing backward compatibility
	    customSkinning: CustomSkinning,
	    options: {},
	    adVideoPlayer: {},
	    callbackForAdUnit: {},//callback in adunit
	    vpaidData: {},
	    iframeVideoWrapper: {},
	    isPlayingVideo: false,
	    isDoneInitialPlay: false,
	    isFullscreen: false,
	    heightOffset: 0,
	    explicitPaused: false,
	    aspectRatio: 0,
	    videoObjectId: {},
	    isViewable: false,
	    isSkipped: false,
	    isCompleted: false,
	    isMuted: false,
	    isExplicitMuted: false,
	    hasBeenUnmuted: false,
	    isChrome: (navigator.userAgent.indexOf("Chrome") > -1),
	    videojs_vpaid: JSVpaidPlayer,
	    overlayPlayer: false,
	    forceToSkip: false,
	    ExtendDefaultOption: ExtendDefaultOption,
	    delayEventHandler: null,
	    pausedByViewability: false,
	    mutedByVisibility: false,
	    gotAdImpressionForFlash: false,
	    gotAdStartedForFlash: false,
	    isReadyToExpandForMobile: false,
	    isAlreadyPlaingForVPAID: false,
	    isSideStreamActivated: false,//this will be set after options.sideStream maxPageOverlay processed by its own logic
	    isExpanded: false,
	    isVideoCompleteInjected: false,
	    isFullscreenToggled: false,//for VID-2558 VID-2554 Safari, Chrome browsers response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation
	    toggleWindowFocus: true,//toggle flag to know whether current window has a focus or not
	    viewabilityTracking: null,
	    isDoneFirstLoadStart: false,
	    flashBlockerTimeout: null,
	    Utils: Utils,
	    isAlreadyStart: false,


	    /**
	     * a start point for initializing playerManager
	     * @param _options
	     */
	    init: function (_options) {
	        var extendedOptions = ExtendDefaultOption(DEFAILT_OPTIONS_FOR_PLAYER_MANAGER, _options);//if optons doesn't have default variables for playerManager level, overrides it
	        this.options = extendedOptions;//TODO minthe : it will be better not to set at this time but remain this until code has more stable & clear state.

	        //if VAST3 override skippable option, it should also override enabled and videoThreshold to 0
	        if (this.options.skippable.allowOverride === true) {//fix VIDLA-525
	            this.options.skippable.videoThreshold = 0;
	            this.options.skippable.enabled = true;
	        }

	        this.delayEventHandler = new DelayEventHandler();//make instance of delay event handling
	        //set event delay handler
	        this.delayEventHandler.suppress(this.options.delayExpandUntilVPAIDImpression);
	        this.delayEventHandler.start();

	        //activate appnexus viewability
	        this.viewabilityTracking = new ViewabilityTracking();

	        return extendedOptions;
	    },

	    getValueFromPlayer: function (param) {

	        //this is just for iOS inline video, height of toolbar which will be added to video area. this is required to show whole area of video with controlbar
	        var result = 0;
	        try {
	            if (param === "controlBar.height") {
	                if (this.adVideoPlayer && this.adVideoPlayer.controlBar && this.adVideoPlayer.controlBar.height && typeof this.adVideoPlayer.controlBar.height === "function" && this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                    result = this.adVideoPlayer.controlBar.height();
	                }
	            }
	        } catch (ex) {
	            error(ex);
	        }

	        return result;
	    },

	    /**
	     * return decision what to use for player
	     * @returns {string}
	     */
	    decidePlayer: function (arrTech) {

	        /*
	         parameter arrTech will have a result from rendition manager as this.options.requiredPlayer
	         Expected requiredPlayer from Rendition manager is :
	         0 - any,
	         1 - html5,
	         2 - flash
	         this result will be decided by Rendition Manager Module with VAST XML
	         */

	        /*
	         summary of result from rendition manager
	         rendition manager returns 0 when it doesn't find any specific playable format for each of technology between html5 and flash
	         if the "type" attribute of "<MediaFile>" element of vast XML has...
	         'video/x-flv', 'video/x-f4v','video/f4v', 'application/x-shockwave-flash' then rendition manager will return flash
	         'video/webm','video/ogg','application/javascript','application/x-javascript' then rendition manager will return html5
	         all the other case rendition manager will return 0
	         */

	        /*
	         special cases verified with Eugene
	         VPAID ad is always favorable by Rendition Manager so if VAST tag has VPAID creative, Rendtional Manager will try to choose VPAID one
	         and If VAST has both JSVPAID and FLASH-VPAID the selection will be depending on playerTechnology
	         */

	        var result = "";
	        var TECH_FLASH = "flash";
	        var TECH_HTML5 = "html5";

	        var isMobile = function () {
	            var index = navigator.appVersion.indexOf("Mobile");
	            var indexForAndroid = navigator.appVersion.indexOf("Android");
	            return (index > -1) || (indexForAndroid > -1);
	        };


	        //fix VID-1069
	        var playerTechnology = this.options.playerTechnology;//possible scenario : ["flash"], ["html5"], ["html5","flash"], ["flash","html5"]


	        //if playerTechnology is either of html5 and flash
	        if (playerTechnology && playerTechnology.length && playerTechnology.length === 1) {
	            switch (arrTech) {
	                case 1:
	                    result = TECH_HTML5;
	                    break;
	                case 2:
	                    result = TECH_FLASH;
	                    break;
	                case 0:
	                    result = (playerTechnology[0] === TECH_HTML5) ? TECH_HTML5 : TECH_FLASH;
	                    break;
	            }
	        }

	        //if playerTechnology has both html5 and flash
	        if (playerTechnology && playerTechnology.length && playerTechnology.length === 2) {
	            switch (arrTech) {
	                case 1:
	                    result = TECH_HTML5;
	                    break;
	                case 2:
	                    result = TECH_FLASH;
	                    break;
	                case 0:
	                    //for VID-1069 (kyungsuk)
	                    //confirmed with Jeff Outstream will favor HTML5 for this case even through Flash was listed first
	                    //a case for (arrTech==0 and jsVpaid==true) won't be happend by Rendition manager. if there's the case, AdHandler will destroy framework with error. this is confirmed with Eugene
	                    result = TECH_HTML5;
	                    break;
	            }
	        }

	        if (isMobile()) {//if it's mobile this manager will always choose html5
	            result = TECH_HTML5;
	        }

	        return result;

	    },

	    /** Build Player.
	     @param {Object} options - Options used to construct video player.
	     @param {Object} eventHandlerCallback - Messages from player will be called on this function.
	     */
	    buildPlayer: function (_callbackForAdUnit, _options) {



	        //register options and callbackForAdUnit
	        //this.options = _options;//deprecated it will be done at init method
	        this.callbackForAdUnit = _callbackForAdUnit;
	        if (_options.hasOwnProperty('overlayPlayer')) {
	            this.overlayPlayer = _options.overlayPlayer;
	            if (_options.hasOwnProperty('fullscreenMode')) {
	                _options.allowFullscreen = false;
	            }
	        }

	        if (isIE11() && this.decidePlayer(this.options.requiredPlayer) === "flash") {
	            //do nothing for now
	        } else if (this.options.targetElement && !this.options.firstAdAttempted) {
	            this.options.targetElement.style.visibility = "hidden";
	        }

	        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);
	        var externalNameOfVideoPlayer = "APNVideo_Player_" + UID;
	        this.externalNameOfVideoPlayer = externalNameOfVideoPlayer;

	        BuildPlayerObj(_callbackForAdUnit, _options, this);

	    },

	    /** Get current property state of player.
	     @param {String} propertyName - Property name to get.
	     @returns {Object} Value of requested propertyName
	     */
	    //getPlayerProperty: function (propertyName) {
	    //    return null;
	    //},

	    /** Get entire player status object.
	     @returns {Object} Representation of all player status values (playerState, audioState etc)
	     */
	    getPlayerStatus: function () {

	    },

	    /** Send notification to the player
	     @param {String} notifiactionName - notification name.
	     @param {Object} notifiactionValue - notification value.
	     */
	    notifyPlayer: function (notifiactionName, notifiactionValue) {
	        this.adVideoPlayer.handleAdUnitNotification({name: notifiactionName, value: notifiactionValue});
	    },

	    load: function () {

	        if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	            debug("load video");
	            try {
	                if (this.adVideoPlayer && this.adVideoPlayer !== undefined && this.adVideoPlayer.load && typeof this.adVideoPlayer.load === "function") {
	                    // VID-2517 Force the video tag to be in non autoplay state and autoplay is handled by explicitly by ad unit.
	                    if (this.options.delayExpandUntilVPAIDImpression && this.adVideoPlayer.player() && this.adVideoPlayer.player().autoplay()) {
	                        this.adVideoPlayer.player().autoplay(false);
	                    }
	                    this.adVideoPlayer.load();
	                }
	            } catch (ex) {
	                error(ex);
	            }

	        }

	    },

	    /**
	     * play video
	     */
	    play: function () {

	        //remedy for fixing a bug on iOS10.1 - iOS10.1 has a bug to break a div which has overflow = "hidden" after entering fullscreen where their native video player.
	        var needApplePatchForIos10 = AutoplayHandler.isMobile() && AutoplayHandler.iOSversion()[0] >= 10 && this.options.enableInlineVideoForIos === false;
	        if (needApplePatchForIos10) {
	            var _playerManager = this;
	            if (_playerManager.overlayPlayer) {
	                _playerManager.options.targetElement.style.overflow = "";
	            } else {
	                setTimeout(function () {
	                    _playerManager.options.targetElement.style.overflow = "";
	                }, _playerManager.options.expandTime);
	            }
	        }

	        //this.destroyWithoutSkip(true, "error occurred",null,900);

	        this.isAlreadyPlaingForVPAID = true;

	        if (this.isCompleted) {
	            return;
	        }
	        debug("play video");


	        //this is for VID-1820 : sending event should be prior than invoking actual play method because that play method will cause another event like "firstPlay" which could give us a flag (this.isDoneInitialPlay == true).
	        if (this.isDoneInitialPlay) {
	            if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                if (!this.isPlayingVideo) {
	                    this.dispatchEventToAdunit({"name": "video_resume"});
	                }
	            }
	            else if (!this.isPlayingVideo) {
	                this.dispatchEventToAdunit({"name": "video_resume"});
	            }
	        } else {
	            // handle impression only for video cases.
	            if (!this.options.vpaid) {
	                this.dispatchEventToAdunit({"name": "video_start"});
	                this.dispatchEventToAdunit({"name": "video_impression"});
	            }
	        }


	        if (this.options.vpaid && this.isIosInlineRequired()) {
	            if (!this.isDoneInitialPlay) {
	                this.adVideoPlayer.trigger('play');//jsvpaid in iOS inline should have this call instead of .play() in order to get "AdStarted" event for JSVPAID after that, framework will have proper video url which is set by JSVPAID creative
	            } else {
	                this.adVideoPlayer.play();//for resuming video
	            }

	        } else {
	            this.adVideoPlayer.play();
	        }


	        if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	        } else {
	            this.isPlayingVideo = true;
	        }

	        this.isDoneInitialPlay = true;


	    },


	    /**
	     * pause video
	     */
	    pause: function () {
	        if (this.isPlayingVideo) {
	            debug("pause video");


	            this.adVideoPlayer.pause();

	            if (!this.isCompleted) {
	                this.dispatchEventToAdunit({"name": "video_pause"});
	            }

	        }

	    },

	    /**
	     * explicit pause a video
	     */
	    explicitPause: function () {
	        debug("explicit pause video");
	        this.explicitPaused = true;
	        this.pause();
	    },

	    /**
	     * explicit play a video
	     * @constructor
	     */
	    explicitPlay: function () {
	        debug("explicit play video");
	        this.explicitPaused = false;
	        this.play();
	    },

	    /**
	     * mute audio
	     */
	    mute: function () {
	        if (!this.isMuted) {
	            debug("mute audio");
	            if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                this.adVideoPlayer.muted(true);
	                this.dispatchEventToAdunit({"name": "video_mute"});
	            }
	            else {
	                // the flash player will notify player manager when audio is muted and then dispatchEventToAdunit for video_mute will be called
	                this.adVideoPlayer.mute();
	            }
	            this.isMuted = true;
	        }
	    },

	    explicitMute: function () {
	        debug("explicit mute video");
	        this.isExplicitMuted = true;
	        this.mute();
	    },

	    /**
	     * unmute audio
	     */
	    unmute: function () {
	        if (!this.isExplicitMuted && this.isMuted) {
	            debug("unmute audio");
	            if (this.decidePlayer(this.options.requiredPlayer) === 'html5') {
	                if (this.adVideoPlayer.muted() === true) {//if already unmuted then set flag and return;
	                    this.adVideoPlayer.muted(false);
	                }
	                if (this.isMuted || this.options.initialAudio === "off") {
	                    this.dispatchEventToAdunit({"name": "video_unmute"});
	                }
	            }
	            else {
	                // the flash player will notify player manager when audio is unmuted and then dispatchEventToAdunit for video_unmute will be called
	                this.adVideoPlayer.unmute();
	                this.hasBeenUnmuted = true;
	            }
	            this.isMuted = false;
	        }
	    },

	    explicitUnmute: function () {
	        this.isExplicitMuted = false;
	        this.unmute();
	    },

	    resizeVideoWithDimensions: function (width, height) {
	        var playerManager = this;
	        this.options.width = width;
	        this.options.height = height;
	        playerManager.resizeVideo(playerManager.aspectRatio);
	    },

	    /**
	     * mouseIn (for flash only)
	     */
	    mouseIn: function () {
	        this.adVideoPlayer.mouseIn();
	    },

	    /**
	     * mouseOut (for flash only)
	     */
	    mouseOut: function () {
	        this.adVideoPlayer.mouseOut();
	    },

	    destroy: function (isError, message) {


	        this.isPlayingVideo = false;
	        this.adVideoPlayer.pause();

	        //invoke skip event
	        if (!this.isCompleted) {
	            this.dispatchEventToAdunit({"name": "video_skip"});
	        }
	        this.isSkipped = true;

	        //TODO all event should be clear in here
	        debug("destroy");
	        var code = VAST_ERROR_UNDEFINED;//Undefined Error in VPAID3.0 spec
	        if (typeof this.callbackForAdUnit.cbWhenDestroy === "function") {
	            if (this.overlayPlayer) {
	                if (isError && message) {
	                    this.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, true, this.options);
	                } else {
	                    this.callbackForAdUnit.cbWhenDestroy(null, true, this.options);
	                }
	            }
	            else {
	                if (isError && message) {
	                    this.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, null, this.options);
	                } else {
	                    this.callbackForAdUnit.cbWhenDestroy(null, null, this.options);
	                }
	            }
	        }
	    },

	    destroyWithoutSkip: function (isError, message, timeout, errCode) {

	        try {
	            var playerManagerSelf = this;
	            var performSkip = function () {
	                playerManagerSelf.isPlayingVideo = false;

	                if (playerManagerSelf.adVideoPlayer && playerManagerSelf.adVideoPlayer.pause && typeof(playerManagerSelf.adVideoPlayer.pause) === "function") {
	                    playerManagerSelf.adVideoPlayer.pause();
	                }

	                //TODO all event should be clear in here
	                debug("destroy without skip");
	                var code = errCode || VAST_ERROR_UNDEFINED;//Undefined Error in VPAID3.0 spec
	                if (typeof playerManagerSelf.callbackForAdUnit.cbWhenDestroy === "function") {
	                    if (playerManagerSelf.overlayPlayer) {
	                        if (isError && message) {
	                            if (timeout) {
	                                code = VAST_ERROR_TIMEOUT;
	                            }
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, true, playerManagerSelf.options);
	                        } else {
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy(null, true, playerManagerSelf.options);
	                        }
	                    }
	                    else {
	                        if (isError && message) {
	                            if (timeout) {
	                                code = VAST_ERROR_TIMEOUT;
	                            }
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy({type: ERROR_TYPE_VAST, code: code, message: message}, null, playerManagerSelf.options);
	                        } else {
	                            playerManagerSelf.callbackForAdUnit.cbWhenDestroy(null, null, playerManagerSelf.options);
	                        }
	                    }
	                }
	            };

	            if (playerManagerSelf.options.disableCollapseForDelay && playerManagerSelf.options.disableCollapseForDelay > 0) {
	                setTimeout(performSkip, playerManagerSelf.options.disableCollapseForDelay);
	            } else {
	                performSkip();
	            }
	        } catch (ex) {
	            error("failed to destroy/notify by " + ex);
	        }

	    },

	    /**
	     * return Video Object it self
	     * @returns {*}
	     */
	    getVideoObject: function () {
	        return this.adVideoPlayer;
	    },


	    handleFlashPlay: function () {
	        var playerManager = this;
	        var fnAfterAdLoaded = function () {
	            playerManager.resizeVideo(playerManager.aspectRatio);
	            debug("flash player is ready to play");
	            if (playerManager.callbackForAdUnit.cbWhenReady) {
	                playerManager.callbackForAdUnit.cbWhenReady(playerManager);
	            }
	        };
	        if (playerManager.isChrome) {
	            playerManager.setChromeSize();//for Chrome limitations
	            setTimeout(fnAfterAdLoaded, 100);
	        }
	        else {
	            fnAfterAdLoaded();
	        }
	    },

	    handlePlayerNotification: function (dataObj) {

	//        debug(dataObj);
	        if (dataObj.name !== 'video_time') {
	            debug("Got notification from player = " + dataObj.name);
	        }
	        //define method in self object
	        //debug(dataObj);
	        var playerManager = this;

	        var eventHandler = {
	            "flash_is_respondble": function () {
	                if (playerManager.flashBlockerTimeout) {
	                    clearTimeout(playerManager.flashBlockerTimeout);
	                    playerManager.flashBlockerTimeout = null;
	                }
	                debug("Flash is respondble");
	                return;
	            },
	            "canplay": function () {
	                if (playerManager.flashBlockerTimeout) {
	                    clearTimeout(playerManager.flashBlockerTimeout);
	                    playerManager.flashBlockerTimeout = null;
	                    debug("Flash is respondble");
	                }
	                if (playerManager.options.hasOwnProperty('overlayPlayer')) {
	                    try {
	                        playerManager.adVideoPlayer.setDOMPlayerIdAndSize(playerManager.adVideoPlayer.id,
	                            playerManager.options.width, playerManager.options.height);
	                    }
	                    catch (ex) {
	                        debug("Failed to execute setDOMPlayerIdAndSize(...) on Flash Player");
	                    }
	                }
	                if (playerManager.options.vpaid) {
	                    try {
	                        var strCompanions = playerManager.adVideoPlayer.getCompanionsXml();
	                        if (strCompanions && strCompanions.length > 0) {
	                            dataObj.companionAds = strCompanions;
	                        }
	                    }
	                    catch (err) {
	                    }
	                }
	                if (playerManager.options.vpaid && playerManager.options.delayExpandUntilVPAIDImpression) {
	                    playerManager.adVideoPlayer.play();//VID-1549
	                } else {
	                    playerManager.handleFlashPlay();
	                }
	            },
	            "video_failed": function () {
	                if (playerManager.flashBlockerTimeout) {
	                    clearTimeout(playerManager.flashBlockerTimeout);
	                    playerManager.flashBlockerTimeout = null;
	                    debug("Flash is respondble");
	                }
	                // 'destroyWithoutSkip(true)' will dispatch 'error' event by itself
	                playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VIDEO_FAILED, null, VAST_ERROR_VIDEOFAILED);
	            },
	            "video_timeout": function () {
	                playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VIDEO_FAILED, true, VAST_ERROR_TIMEOUT);
	            },
	            "video_bitrate": function () {
	                var bandWidth = dataObj.bandwidth;
	                debug("bandwidth from flash : " + bandWidth);
	                //TODO expose bandwitdh
	            },
	            "video_impression": function () {

	            },
	            "video_mute": function () {
	                if (dataObj.hasOwnProperty('value') && !dataObj.value) {
	                    dataObj.name = 'video_unmute';
	                }
	                if (dataObj.hasOwnProperty('value')) {
	                    playerManager.isMuted = dataObj.value;
	                }
	            },
	            "video_click": function () {
	                if (dataObj.hasOwnProperty('playerHandles')) {
	                    if (dataObj.playerHandles) {
	                        // the player handles vpaid creative click event
	                        if (dataObj.hasOwnProperty('url') && dataObj.url.length > 0) {
	                            playerManager.click(dataObj.url);
	                        }
	                        else {
	                            playerManager.click();
	                        }
	                    }
	                    else {
	                        // creative handles this event. we need only notify ad about click
	                        playerManager.dispatchEventToAdunit({"name": "ad-click", "trackClick": true});
	                    }
	                }
	                else {
	                    // it is not a vpaid creative click
	                    playerManager.click();
	                }
	            },
	            "video_complete": function () {
	                playerManager.isCompleted = true;
	                if (!playerManager.options.disableCollapse) {
	                    playerManager.destroyWithoutSkip();
	                }
	            },
	            "video_fullscreen": function () {
	                if (playerManager.isFullscreen) {
	                    setTimeout(function () {
	                        playerManager.isFullscreen = !playerManager.isFullscreen;
	                    }, 1000);//this delay must be required for supressing mouseout event when exit fullscreen

	                } else {
	                    playerManager.isFullscreen = !playerManager.isFullscreen;
	                }

	            },
	            "quartile_event": function () {

	            },
	            "video_pause": function () {
	            },
	            "video_start": function () {
	                if (!playerManager.isDoneInitialPlay && playerManager.options.initialPlayback !== 'auto') {
	                    playerManager.play();
	                }
	            },
	            "video_time": function () {

	            },
	            "video_resume": function () {
	            },
	            "video_stopped": function () {
	                playerManager.destroyWithoutSkip();
	            },
	            "video_skipped": function () {
	                //click skip
	                playerManager.destroy();
	            },
	            "video_ratio": function () {
	                //playerManager.aspectRatio = dataObj.ratio;
	            },
	            "video_heightOffset": function () {
	                playerManager.heightOffset = dataObj.heightOffset;
	                //playerManager.options.height = playerManager.options.height + dataObj.heightOffset;
	                //test
	            },
	            "video_paused_by_user": function () {
	                playerManager.explicitPause();
	            },
	            "video_resumed_by_user": function () {
	                //playerManager.explicitPlay();

	                //change logic for VID-2504
	                debug("received video_resumed_by_user from Flash");
	                if (playerManager.requiredForFlashVpaid()) {
	                    if (playerManager.isVpaidFlashVideoPlaying === false) {
	                        debug("call explicitPlay by video_Resumed_by_user event");
	                        playerManager.explicitPlay();
	                    } else {
	                        debug("do nothing because of isVpaidFlashVideoPlaying:true");
	                    }
	                } else {
	                    playerManager.explicitPlay();
	                }
	            },
	            "video_progress": function () {
	                if (dataObj && dataObj.offset) {
	                    playerManager.dispatchEventToAdunit({"name": dataObj.offset}, function () {
	                        debug("handle video_progress by flash : " + dataObj.offset);
	                    });
	                    return;
	                }
	            }
	        };

	        if (!playerManager.isDoneInitialPlay && dataObj.name === "video_mute") {
	            // ignore some implicit event(s) before done initial play
	            return;
	        }

	        //invoke eventHandler by dataObj.name
	        var invoker = eventHandler[dataObj.name];
	        if (invoker && invoker !== undefined) {
	            invoker();
	        }

	        if (dataObj.name !== "video_pause" && dataObj.name !== "video_resume" &&
	            dataObj.name !== "video_impression" && dataObj.name !== "video_start" &&
	            dataObj.name !== "video_failed" && dataObj.name !== "video_timeout") {

	            this.dispatchEventToAdunit(dataObj);
	        }

	        if ((dataObj.name === "video_impression" || dataObj.name === "video_start") && playerManager.options.vpaid) {
	            this.dispatchEventToAdunit(dataObj);
	        }
	    },
	    handleOverlayNotification: function (dataObj) {
	        //define method in self object
	        debug("Got overlay notification from player = " + dataObj.name);
	        var playerManager = this;

	        var eventHandler = {
	            "leaveFullscreen": function () {
	                if (playerManager.options.hasOwnProperty('playerNotification')) {
	                    playerManager.options.playerNotification('leaveFullscreen');
	                }
	            }
	        };

	        //invoke eventHandler by dataObj.name
	        var invoker = eventHandler[dataObj.name];
	        if (invoker && invoker !== undefined) {
	            invoker();
	        }
	    },

	    requiredForFlashVpaid: function () {
	        return (this.decidePlayer(this.options.requiredPlayer) === "flash" && this.options.vpaid === true);
	    },

	    notifyVpaidEvent: function (eventName) {
	        var playerManager = this;

	        //for VID-2504
	        if (playerManager.requiredForFlashVpaid()) {
	            if (eventName === "AdPaused") {
	                debug("received VPAID AdPaused from Flash");
	                playerManager.isVpaidFlashVideoPlaying = false;
	                playerManager.isPlayingVideo = false;
	                debug("set isVpaidFlashVideoPlaying = false");
	                debug("set isPlayingVideo = false");
	            }

	            if (eventName === "AdPlaying") {
	                debug("received VPAID AdPlaying from Flash");
	                playerManager.isVpaidFlashVideoPlaying = true;
	                playerManager.isPlayingVideo = true;
	                debug("set isVpaidFlashVideoPlaying = true");
	                debug("set isPlayingVideo = true");
	            }
	        }

	        //for VID-1549
	        if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash" && playerManager.options.delayExpandUntilVPAIDImpression) {
	            if (eventName === "AdVideoStart") {
	                playerManager.adVideoPlayer.pause();
	            }
	            if (eventName === "AdImpression") {
	                playerManager.gotAdImpressionForFlash = true;
	            }
	            if (eventName === "AdStarted") {
	                playerManager.gotAdStartedForFlash = true;
	            }
	            if (playerManager.gotAdImpressionForFlash && playerManager.gotAdStartedForFlash) {
	                //this should be one time action when we got both impression and adStarted in order to resize video
	                playerManager.handleFlashPlay();//allow to expand
	                playerManager.gotAdImpressionForFlash = false;
	                playerManager.gotAdStartedForFlash = false;
	            }
	        }


	        //for VID-1551
	        if (playerManager.options.delayExpandUntilVPAIDImpression && playerManager.delayEventHandler.isSuppress && EVENTS_HAVE_TO_FILTER_OUT.indexOf(eventName) >= 0) {
	            return;
	        }

	        if (EVENTS_RESTRICTED_SUPPRESSING.indexOf(eventName) >= 0 || EVENTS_RESTRICTED_SUPPRESSING.indexOf("vpaid." + eventName) >= 0) {
	            //don't suppress, trigger immidiately
	            playerManager.notifyVpaidEvent_internal(eventName);
	        } else {
	            playerManager.delayEventHandler.push(function () {
	                playerManager.notifyVpaidEvent_internal(eventName);
	            });
	        }
	    },

	    notifyVpaidEvent_internal: function (eventName) {
	        if (this.options.cbNotification) {
	            this.options.cbNotification('VPAID', eventName, this.options.targetId);
	        }
	        if (this.options.cbApnVastPlayer) {
	            this.options.cbApnVastPlayer(eventName);
	        }
	    },

	    setChromeSize: function () {
	        this.adVideoPlayer.width = "0px";
	        this.adVideoPlayer.height = "0px";
	        this.adVideoPlayer.style.width = "0px";
	        this.adVideoPlayer.style.height = "0px";
	        this.options.targetElement.style.visibility = "visible";
	    },

	    click: function (urlFromCreative) {

	        if (!this.isDoneInitialPlay) {
	            this.play();//play the video by clicking play button
	            return;
	        }

	        if (this.isIosInlineRequired() === false) {//iOS will pause the video when window.open completed by blur a window, so don't need to be invoked here for VID-2074
	            this.pause();
	            this.toggleWindowFocus = false;//this will make sure to have clear status of focus because at somecase, document.hasFocus() can have true when we do open.window() even the focus is already on the new window.
	        }

	        /**
	         * ad-click
	         */
	            //Do not track clickThru if landing url was not found.
	        var trackClick = false;
	        if (urlFromCreative) {
	            trackClick = true;
	            window.open(urlFromCreative);
	        }
	        else if (this.options.clickUrls[0]) {
	            trackClick = true;
	            var url = this.options.clickUrls[0];
	            window.open(url);
	        }

	        this.dispatchEventToAdunit({"name": "ad-click", "trackClick": trackClick});

	    },

	    getRapamsAndExtensions: function () {
	        var extensions = (this.options.extensions && this.options.extensions.length > 0) ? '<Extensions>' + this.options.extensions + '</Extensions>' : '';
	        return {adParameters: this.options.adParameters, extensions: extensions};
	    },

	    handleViewability: function (object_, checkEventToStartViewability, isHtml5) {

	        var isEnabledViewability = this.options && this.options.viewability && this.options.viewability.config;
	        var eventName = (object_ && object_.name) ? object_.name : null;

	        //for fullscreen VIDLA-263
	        if (eventName === "fullscreenchange" || eventName === "video_fullscreen") {
	            eventName = (this.isFullscreen) ? "fullscreen" : "exitFullscreen";
	        }

	        if (!isHtml5 && eventName === "video_duration") {
	            this.isAlreadyStart = true;
	        }

	        if (eventName && isEnabledViewability) {
	            if (eventName === checkEventToStartViewability) {//only at the time we got "expandStart" can have proper duration and final width,height for outstream, for other ad-unit this will use `loadstart` by a logic
	                var duration;
	                if (isHtml5) {//for html5
	                    duration = this.adVideoPlayer && this.adVideoPlayer.player && typeof(this.adVideoPlayer.player) === "function" && this.adVideoPlayer.player().duration();
	                } else {//for flash
	                    duration = object_.duration;
	                }

	                //VIDLA-568 Update Core Player Logic to support delayed start of viewability library until duration
	                if (!duration || duration === undefined || duration <= 0) {
	                    duration = -2;//-2 means unknown duration on vpaid sepc
	                }

	                //find failsafe value by this order (use vast duratio, -2)
	                if (duration === -2) {//VIDLA-619
	                    if (this.options && this.options.data && this.options.data.vastDurationMsec) {
	                        duration = this.options.data.vastDurationMsec / 1000;
	                        if (!duration || duration === null || duration <= 0) {
	                            duration = -2;//-2 means unknown duration on vpaid sepc
	                        }
	                    } else {
	                        duration = -2;
	                    }
	                }

	                var width = this.options.width;
	                var height = this.options.height;
	                this.viewabilityTracking.init(this.options, duration, width, height);



	                if (isHtml5) {
	                    this.viewabilityTracking.invokeEvent(eventName);
	                } else {
	                    //a decision from VIDLA-568
	                    if (this.isAlreadyStart) {
	                        if (this.options.expandable) {//invoke expand only for expandable ad-unit like Outstream
	                            this.viewabilityTracking.invokeEvent("expand");
	                        }
	                        this.viewabilityTracking.invokeEvent("video_start");
	                    }
	                }


	            } else {
	                if (this.viewabilityTracking.isReady) {
	                    this.viewabilityTracking.invokeEvent(eventName);
	                }
	            }
	        }
	    },

	    findPathForViewability: function (object_) {

	        var isHtml5 = (this.decidePlayer(this.options.requiredPlayer) === 'html5');
	        var checkEventToStartViewability;

	        if (isHtml5) {//for html5
	            if (this.options.expandable) {
	                checkEventToStartViewability = "expand";//event from Outstream
	            } else {
	                checkEventToStartViewability = "loadstart";//event from core-video framework
	            }
	            if (object_ && object_.name && object_.name === checkEventToStartViewability) {//avoiding double invoke
	                if (this.isDoneFirstLoadStart) {
	                    return;
	                } else {
	                    this.isDoneFirstLoadStart = true;
	                }
	            }
	            this.handleViewability(object_, checkEventToStartViewability, isHtml5);

	        } else {//for flash
	            checkEventToStartViewability = "video_duration";//by VIDLA-619

	            if (object_ && object_.name === "video_start") {
	                return;//do nothing if it's video_start, video_duration will consider as video_start because only video_duration can have duration of video and Flash player promised it will be triggered after video_start
	            }

	            if (object_ && object_.name && object_.name === checkEventToStartViewability) {//avoiding double invoke
	                if (this.isDoneFirstLoadStart) {
	                    //do nothing
	                } else {
	                    this.isDoneFirstLoadStart = true;
	                    this.handleViewability(object_, checkEventToStartViewability, isHtml5);//for initialize
	                }
	            } else {
	                this.handleViewability(object_, checkEventToStartViewability, isHtml5);
	            }

	        }
	    },

	    dispatchEventToAdunit: function (object_, cb) {


	        var playerManager = this;

	        //VIDLA-574
	        //Flash fullscreen has to have some latency to get a exact fullscreen status during switching it
	        if (object_.name === "video_fullscreen" && this.decidePlayer(this.options.requiredPlayer) === 'flash') {
	            setTimeout(function () {
	                //copy object to make it read only in order to avoid conflict situation
	                var eventForFullscren = {
	                    "name": object_.name,
	                    "user": object_.user,
	                    "value": object_.value,
	                };
	                playerManager.findPathForViewability(eventForFullscren);
	            }, 1500);//delay to have exact fullscreen status which will be set by playerManager
	        } else {
	            this.findPathForViewability(object_);
	        }

	        if (object_.name === "video_skip" && unique.pushAndCheck(this.options.targetElement.id + "_dispatchEventToAdunit", object_.name) === false) {
	            return;//the unique.pushAndCheck will check if the value is unique, through this apprach unnecassary second "video-skip" will be ignored.
	        }

	        if (object_.name === "video_complete" && this.isVideoCompleteInjected === true) {
	            //do nothing
	        } else {

	            if (object_ && object_.name !== "video_time") {
	                debug("(push)" + object_.name);
	            }

	            this.delayEventHandler.push(function () {
	                playerManager.dispatchEventToAdunit_internal(object_, cb);
	            });
	            if (object_.name === "video_complete") {
	                this.isVideoCompleteInjected = true;
	            }
	        }

	    },

	    /**
	     * dispatchEventToAdunit_internal
	     * @param object_ : kind of events
	     * @param cb : this callback will be invoked after handled all trackings and events
	     */
	    dispatchEventToAdunit_internal: function (object_, cb) {

	        //debug("dispatchEventToAdunit : " + object_.name);

	        // if video is completed all vast event firing will be ignored,
	        // except video_complete, video_skip and ad-click event, make sure we notify ad unit about video completion.
	        if (this.isCompleted && !(object_.name === "video_complete" || object_.name === "ad-click" || object_.name === "video_skip")) {
	            return;
	        }

	        var playerManager = this;
	        if (object_ && object_.name !== "video_time") {
	            debug("invoke callback : " + JSON.stringify(object_));
	        }


	        if (this.callbackForAdUnit.cbForHandlingDispatchedEvent && object_.name !== "video_time") {
	            // debug("dispatchEventToAdunit : " + object_.name);

	            if (object_.name === "video_pause") {
	                this.isPlayingVideo = false;
	            }

	            if (object_.name === "video_play" || object_.name === "video_start" || object_.name === "firstplay") {
	                this.isPlayingVideo = true;
	                this.isDoneInitialPlay = true;
	            }


	            //fullscreen has to have some latency to get a exact fullscreen status during switching it
	            if (object_.name === "video_fullscreen") {
	                setTimeout(function () {
	                    object_.fullscreenStatus = (playerManager.isFullscreen ? "enter" : "exit");
	                    playerManager.callbackForAdUnit.cbForHandlingDispatchedEvent(object_);
	                }, 1500);
	                return;

	            }


	            if (typeof(cb) === "function") {
	                cb();//invoke callback if exists
	            }

	            this.callbackForAdUnit.cbForHandlingDispatchedEvent(object_);
	        }
	    },

	    resizeVideo: function (aspectRatio, shouldConsiderHeightOfDevice, cb) {
	        VideoSizeHandler.resizeVideo(aspectRatio, shouldConsiderHeightOfDevice, this, cb);
	    },

	    resizeVideoForSideStream: function (width, height, cb) {
	        VideoSizeHandler.resizeVideoForSideStream(this, width, height, cb);
	    },

	    isIosInlineRequired: function () {
	        return this.autoplayHandler.isIosInlineRequired(this.options.enableInlineVideoForIos);
	    },

	    resizePlayer: function (width, height) {
	        VideoSizeHandler.resizePlayer(width, height, this);
	    },

	    getFinalSize: function () {
	        return VideoSizeHandler.getFinalSize(this);
	    },

	    setVastAttribute: function (duration) {
	        var _options = this.options;
	        var _videoDuration;

	        if (duration) {
	            _videoDuration = duration;
	        } else {
	            _videoDuration = (this.adVideoPlayer && this.adVideoPlayer.player) ? this.adVideoPlayer.player().duration() : 0;
	        }

	        _options.data.durationMsec = (_videoDuration !== null) ? Math.round(_videoDuration * 1000) : 0;//flash will have zero here

	        //convert skipOffset to milliseconds
	        var _msec = this.Utils.getMsecTime(_options.data.skipOffset, _options.data.durationMsec);
	        if (_options.data.skipOffset && _msec >= 0) {
	            _options.data.isVastVideoSkippable = true;
	            _options.data.skipOffsetMsec = _msec;
	        } else {
	            _options.data.skipOffsetMsec = null;
	        }

	        //convert progress event to milli seconds
	        var vastProgressEvent = _options.data.vastProgressEvent;
	        if (vastProgressEvent && typeof(vastProgressEvent) === "object") {

	            for (var _event in vastProgressEvent) {
	                var _offsetMsec = (this.Utils.getMsecTime(_event.replace(/progress_/g, ""), _options.data.durationMsec));
	                vastProgressEvent[_event] = _offsetMsec;
	            }
	        }


	    },

	    log: debug,
	    debug: debug,

	    test: function (func, obj) {//for tdd
	        var options = this.options;
	        if (options && options.test && options.test[func] && typeof(options.test[func]) === "function") {

	            //moved from outside because we don't need to define this function variables when it doesn't need to test
	            var _fail = function (msg) {
	                console.debug("%c" + msg, "background: red; color: white");
	            };
	            var _succeed = function (msg) {
	                console.debug("%c" + msg, "background: green; color: white");
	            };

	            try {
	                var assert = function (condition, message) {
	                    if (!condition) {
	                        message = message + " failed" || "Assertion failed";
	                        _fail("Unit Test [" + func + "] : " + message);
	                    } else {
	                        message = message + " Succeeded" || "Succeeded";
	                        _succeed("Unit Test [" + func + "] : " + message);
	                    }
	                };
	                var log = function (msg) {
	                    console.debug("%cUnit Test Log : [" + func + "] : " + msg, "background: gray; color: white");
	                };

	                options.test[func](obj, assert, log);
	            } catch (ex) {
	                _fail("unit test failed due to : " + ex);
	            }
	        }
	    }

	};

	module.exports = adVideoPlayerManager;
	window[externalNameOfVideoPlayer] = adVideoPlayerManager;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/* jshint ignore:start */
	/**
	 * @fileoverview Main function src.
	 */

	// HTML5 Shiv. Must be in <head> to support older browsers.
	document.createElement('video');
	document.createElement('audio');
	document.createElement('track');

	/**
	 * Doubles as the main function for users to create a player instance and also
	 * the main library object.
	 *
	 * **ALIASES** videojs, _V_ (deprecated)
	 *
	 * The `vjs` function can be used to initialize or retrieve a player.
	 *
	 *     var myPlayer = vjs('my_video_id');
	 *
	 * @param  {String|Element} id      Video element or video element ID
	 * @param  {Object=} options        Optional options object for config/settings
	 * @param  {Function=} ready        Optional ready callback
	 * @return {vjs.Player}             A player instance
	 * @namespace
	 */
	var global_options;//for having proper pre-generate iframe id
	var vjs = function(id, options, ready){
	  global_options = options;
	  var tag; // Element of ID

	  // Allow for element or ID to be passed in
	  // String ID
	  if (typeof id === 'string') {

	    // Adjust for jQuery ID syntax
	    if (id.indexOf('#') === 0) {
	      id = id.slice(1);
	    }

	    // If a player instance has already been created for this ID return it.
	    if (vjs.players[id]) {

	      // If options or ready funtion are passed, warn
	      if (options) {
	        vjs.log.warn ('Player "' + id + '" is already initialised. Options will not be applied.');
	      }

	      if (ready) {
	        vjs.players[id].ready(ready);
	      }

	      return vjs.players[id];

	    // Otherwise get element for ID
	    } else {
	      tag = vjs.el(id);
	    }

	  // ID is a media element
	  } else {
	    tag = id;
	  }

	  // Check for a useable element
	  if (!tag || !tag.nodeName) { // re: nodeName, could be a box div also
	    throw new TypeError('The element or ID supplied is not valid. (videojs)'); // Returns
	  }

	  // Element may have a player attr referring to an already created player instance.
	  // If not, set up a new player and return the instance.
	  return tag['player'] || new vjs.Player(tag, options, ready);
	};

	// Extended name, also available externally, window.videojs
	var videojs = window['videojs_apn'] = vjs;

	// CDN Version. Used to target right flash swf.
	vjs.CDN_VERSION = 'GENERATED_CDN_VSN';
	vjs.ACCESS_PROTOCOL = ('https:' == document.location.protocol ? 'https://' : 'http://');

	/**
	* Full player version
	* @type {string}
	*/
	vjs['VERSION'] = 'GENERATED_FULL_VSN';

	/**
	 * Global Player instance options, surfaced from vjs.Player.prototype.options_
	 * vjs.options = vjs.Player.prototype.options_
	 * All options should use string keys so they avoid
	 * renaming by closure compiler
	 * @type {Object}
	 */
	vjs.options = {
	  // Default order of fallback technology
	  'techOrder': ['html5','flash'],
	  // techOrder: ['flash','html5'],

	  'html5': {},
	  'flash': {},

	  // Default of web browser is 300x150. Should rely on source width/height.
	  'width': 300,
	  'height': 150,
	  // defaultVolume: 0.85,
	  'defaultVolume': 0.00, // The freakin seaguls are driving me crazy!

	  // default playback rates
	  'playbackRates': [],
	  // Add playback rate selection by adding rates
	  // 'playbackRates': [0.5, 1, 1.5, 2],

	  // default inactivity timeout
	  'inactivityTimeout': 2000,

	  // Included control sets
	  'children': {
	    'mediaLoader': {},
	    'posterImage': {},
	    'loadingSpinner': {},
	    'textTrackDisplay': {},
	    'bigPlayButton': {},
	    'controlBar': {},
	    'errorDisplay': {},
	    'textTrackSettings': {}
	  },

	  'language': document.getElementsByTagName('html')[0].getAttribute('lang') || navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language || 'en',

	  // locales and their language translations
	  'languages': {},

	  // Default message to show when a video cannot be played.
	  'notSupportedMessage': 'No compatible source was found for this video.'
	};

	// Set CDN Version of swf
	// The added (+) blocks the replace from changing this GENERATED_CDN_VSN string
	if (vjs.CDN_VERSION !== 'GENERATED'+'_CDN_VSN') {
	  videojs.options['flash']['swf'] = vjs.ACCESS_PROTOCOL + 'vjs.zencdn.net/'+vjs.CDN_VERSION+'/video-js.swf';
	}

	/**
	 * Utility function for adding languages to the default options. Useful for
	 * amending multiple language support at runtime.
	 *
	 * Example: vjs.addLanguage('es', {'Hello':'Hola'});
	 *
	 * @param  {String} code The language code or dictionary property
	 * @param  {Object} data The data values to be translated
	 * @return {Object} The resulting global languages dictionary object
	 */
	vjs.addLanguage = function(code, data){
	  if(vjs.options['languages'][code] !== undefined) {
	    vjs.options['languages'][code] = vjs.util.mergeOptions(vjs.options['languages'][code], data);
	  } else {
	    vjs.options['languages'][code] = data;
	  }
	  return vjs.options['languages'];
	};

	/**
	 * Global player list
	 * @type {Object}
	 */
	vjs.players = {};

	/*!
	 * Custom Universal Module Definition (UMD)
	 *
	 * Video.js will never be a non-browser lib so we can simplify UMD a bunch and
	 * still support requirejs and browserify. This also needs to be closure
	 * compiler compatible, so string keys are used.
	 */
	if ("function" === 'function' && __webpack_require__(6)['amd']) {
	  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return videojs; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	// checking that module is an object too because of umdjs/umd#35
	} else if (true) {
	  module['exports'] = videojs;
	}

	/**
	 * Core Object/Class for objects that use inheritance + constructors
	 *
	 * To create a class that can be subclassed itself, extend the CoreObject class.
	 *
	 *     var Animal = CoreObject.extend();
	 *     var Horse = Animal.extend();
	 *
	 * The constructor can be defined through the init property of an object argument.
	 *
	 *     var Animal = CoreObject.extend({
	 *       init: function(name, sound){
	 *         this.name = name;
	 *       }
	 *     });
	 *
	 * Other methods and properties can be added the same way, or directly to the
	 * prototype.
	 *
	 *    var Animal = CoreObject.extend({
	 *       init: function(name){
	 *         this.name = name;
	 *       },
	 *       getName: function(){
	 *         return this.name;
	 *       },
	 *       sound: '...'
	 *    });
	 *
	 *    Animal.prototype.makeSound = function(){
	 *      alert(this.sound);
	 *    };
	 *
	 * To create an instance of a class, use the create method.
	 *
	 *    var fluffy = Animal.create('Fluffy');
	 *    fluffy.getName(); // -> Fluffy
	 *
	 * Methods and properties can be overridden in subclasses.
	 *
	 *     var Horse = Animal.extend({
	 *       sound: 'Neighhhhh!'
	 *     });
	 *
	 *     var horsey = Horse.create('Horsey');
	 *     horsey.getName(); // -> Horsey
	 *     horsey.makeSound(); // -> Alert: Neighhhhh!
	 *
	 * @class
	 * @constructor
	 */
	vjs.CoreObject = vjs['CoreObject'] = function(){};
	// Manually exporting vjs['CoreObject'] here for Closure Compiler
	// because of the use of the extend/create class methods
	// If we didn't do this, those functions would get flattened to something like
	// `a = ...` and `this.prototype` would refer to the global object instead of
	// CoreObject

	/**
	 * Create a new object that inherits from this Object
	 *
	 *     var Animal = CoreObject.extend();
	 *     var Horse = Animal.extend();
	 *
	 * @param {Object} props Functions and properties to be applied to the
	 *                       new object's prototype
	 * @return {vjs.CoreObject} An object that inherits from CoreObject
	 * @this {*}
	 */
	vjs.CoreObject.extend = function(props){
	  var init, subObj;

	  props = props || {};
	  // Set up the constructor using the supplied init method
	  // or using the init of the parent object
	  // Make sure to check the unobfuscated version for external libs
	  init = props['init'] || props.init || this.prototype['init'] || this.prototype.init || function(){};
	  // In Resig's simple class inheritance (previously used) the constructor
	  //  is a function that calls `this.init.apply(arguments)`
	  // However that would prevent us from using `ParentObject.call(this);`
	  //  in a Child constructor because the `this` in `this.init`
	  //  would still refer to the Child and cause an infinite loop.
	  // We would instead have to do
	  //    `ParentObject.prototype.init.apply(this, arguments);`
	  //  Bleh. We're not creating a _super() function, so it's good to keep
	  //  the parent constructor reference simple.
	  subObj = function(){
	    init.apply(this, arguments);
	  };

	  // Inherit from this object's prototype
	  subObj.prototype = vjs.obj.create(this.prototype);
	  // Reset the constructor property for subObj otherwise
	  // instances of subObj would have the constructor of the parent Object
	  subObj.prototype.constructor = subObj;

	  // Make the class extendable
	  subObj.extend = vjs.CoreObject.extend;
	  // Make a function for creating instances
	  subObj.create = vjs.CoreObject.create;

	  // Extend subObj's prototype with functions and other properties from props
	  for (var name in props) {
	    if (props.hasOwnProperty(name)) {
	      subObj.prototype[name] = props[name];
	    }
	  }

	  return subObj;
	};

	/**
	 * Create a new instance of this Object class
	 *
	 *     var myAnimal = Animal.create();
	 *
	 * @return {vjs.CoreObject} An instance of a CoreObject subclass
	 * @this {*}
	 */
	vjs.CoreObject.create = function(){
	  // Create a new object that inherits from this object's prototype
	  var inst = vjs.obj.create(this.prototype);

	  // Apply this constructor function to the new object
	  this.apply(inst, arguments);

	  // Return the new object
	  return inst;
	};

	/**
	 * @fileoverview Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
	 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
	 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
	 * robust as jquery's, so there's probably some differences.
	 */

	/**
	 * Add an event listener to element
	 * It stores the handler function in a separate cache object
	 * and adds a generic handler to the element's event,
	 * along with a unique id (guid) to the element.
	 * @param  {Element|Object}   elem Element or object to bind listeners to
	 * @param  {String|Array}   type Type of event to bind to.
	 * @param  {Function} fn   Event listener.
	 * @private
	 */
	vjs.on = function(elem, type, fn){
	  if (vjs.obj.isArray(type)) {
	    return _handleMultipleEvents(vjs.on, elem, type, fn);
	  }

	  var data = vjs.getData(elem);

	  // We need a place to store all our handler data
	  if (!data.handlers) data.handlers = {};

	  if (!data.handlers[type]) data.handlers[type] = [];

	  if (!fn.guid) fn.guid = vjs.guid++;

	  data.handlers[type].push(fn);

	  if (!data.dispatcher) {
	    data.disabled = false;

	    data.dispatcher = function (event){

	      if (data.disabled) return;
	      event = vjs.fixEvent(event);

	      var handlers = data.handlers[event.type];

	      if (handlers) {
	        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
	        var handlersCopy = handlers.slice(0);

	        for (var m = 0, n = handlersCopy.length; m < n; m++) {
	          if (event.isImmediatePropagationStopped()) {
	            break;
	          } else {
	            handlersCopy[m].call(elem, event);
	          }
	        }
	      }
	    };
	  }

	  if (data.handlers[type].length == 1) {
	    if (elem.addEventListener) {
	      elem.addEventListener(type, data.dispatcher, false);
	    } else if (elem.attachEvent) {
	      elem.attachEvent('on' + type, data.dispatcher);
	    }
	  }
	};

	/**
	 * Removes event listeners from an element
	 * @param  {Element|Object}   elem Object to remove listeners from
	 * @param  {String|Array=}   type Type of listener to remove. Don't include to remove all events from element.
	 * @param  {Function} fn   Specific listener to remove. Don't include to remove listeners for an event type.
	 * @private
	 */
	vjs.off = function(elem, type, fn) {
	  // Don't want to add a cache object through getData if not needed
	  if (!vjs.hasData(elem)) return;

	  var data = vjs.getData(elem);

	  // If no events exist, nothing to unbind
	  if (!data.handlers) { return; }

	  if (vjs.obj.isArray(type)) {
	    return _handleMultipleEvents(vjs.off, elem, type, fn);
	  }

	  // Utility function
	  var removeType = function(t){
	     data.handlers[t] = [];
	     vjs.cleanUpEvents(elem,t);
	  };

	  // Are we removing all bound events?
	  if (!type) {
	    for (var t in data.handlers) removeType(t);
	    return;
	  }

	  var handlers = data.handlers[type];

	  // If no handlers exist, nothing to unbind
	  if (!handlers) return;

	  // If no listener was provided, remove all listeners for type
	  if (!fn) {
	    removeType(type);
	    return;
	  }

	  // We're only removing a single handler
	  if (fn.guid) {
	    for (var n = 0; n < handlers.length; n++) {
	      if (handlers[n].guid === fn.guid) {
	        handlers.splice(n--, 1);
	      }
	    }
	  }

	  vjs.cleanUpEvents(elem, type);
	};

	/**
	 * Clean up the listener cache and dispatchers
	 * @param  {Element|Object} elem Element to clean up
	 * @param  {String} type Type of event to clean up
	 * @private
	 */
	vjs.cleanUpEvents = function(elem, type) {
	  var data = vjs.getData(elem);

	  // Remove the events of a particular type if there are none left
	  if (data.handlers[type].length === 0) {
	    delete data.handlers[type];
	    // data.handlers[type] = null;
	    // Setting to null was causing an error with data.handlers

	    // Remove the meta-handler from the element
	    if (elem.removeEventListener) {
	      elem.removeEventListener(type, data.dispatcher, false);
	    } else if (elem.detachEvent) {
	      elem.detachEvent('on' + type, data.dispatcher);
	    }
	  }

	  // Remove the events object if there are no types left
	  if (vjs.isEmpty(data.handlers)) {
	    delete data.handlers;
	    delete data.dispatcher;
	    delete data.disabled;

	    // data.handlers = null;
	    // data.dispatcher = null;
	    // data.disabled = null;
	  }

	  // Finally remove the expando if there is no data left
	  if (vjs.isEmpty(data)) {
	    vjs.removeData(elem);
	  }
	};

	/**
	 * Fix a native event to have standard property values
	 * @param  {Object} event Event object to fix
	 * @return {Object}
	 * @private
	 */
	vjs.fixEvent = function(event) {

	  function returnTrue() { return true; }
	  function returnFalse() { return false; }

	  // Test if fixing up is needed
	  // Used to check if !event.stopPropagation instead of isPropagationStopped
	  // But native events return true for stopPropagation, but don't have
	  // other expected methods like isPropagationStopped. Seems to be a problem
	  // with the Javascript Ninja code. So we're just overriding all events now.
	  if (!event || !event.isPropagationStopped) {
	    var old = event || window.event;

	    event = {};
	    // Clone the old object so that we can modify the values event = {};
	    // IE8 Doesn't like when you mess with native event properties
	    // Firefox returns false for event.hasOwnProperty('type') and other props
	    //  which makes copying more difficult.
	    // TODO: Probably best to create a whitelist of event props
	    for (var key in old) {
	      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
	      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
	      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation') {
	        // Chrome 32+ warns if you try to copy deprecated returnValue, but
	        // we still want to if preventDefault isn't supported (IE8).
	        if (!(key == 'returnValue' && old.preventDefault)) {
	          event[key] = old[key];
	        }
	      }
	    }

	    // The event occurred on this element
	    if (!event.target) {
	      event.target = event.srcElement || document;
	    }

	    // Handle which other element the event is related to
	    event.relatedTarget = event.fromElement === event.target ?
	      event.toElement :
	      event.fromElement;

	    // Stop the default browser action
	    event.preventDefault = function () {
	      if (old.preventDefault) {
	        old.preventDefault();
	      }
	      event.returnValue = false;
	      event.isDefaultPrevented = returnTrue;
	      event.defaultPrevented = true;
	    };

	    event.isDefaultPrevented = returnFalse;
	    event.defaultPrevented = false;

	    // Stop the event from bubbling
	    event.stopPropagation = function () {
	      if (old.stopPropagation) {
	        old.stopPropagation();
	      }
	      event.cancelBubble = true;
	      event.isPropagationStopped = returnTrue;
	    };

	    event.isPropagationStopped = returnFalse;

	    // Stop the event from bubbling and executing other handlers
	    event.stopImmediatePropagation = function () {
	      if (old.stopImmediatePropagation) {
	        old.stopImmediatePropagation();
	      }
	      event.isImmediatePropagationStopped = returnTrue;
	      event.stopPropagation();
	    };

	    event.isImmediatePropagationStopped = returnFalse;

	    // Handle mouse position
	    if (event.clientX != null) {
	      var doc = document.documentElement, body = document.body;

	      event.pageX = event.clientX +
	        (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
	        (doc && doc.clientLeft || body && body.clientLeft || 0);
	      event.pageY = event.clientY +
	        (doc && doc.scrollTop || body && body.scrollTop || 0) -
	        (doc && doc.clientTop || body && body.clientTop || 0);
	    }

	    // Handle key presses
	    event.which = event.charCode || event.keyCode;

	    // Fix button for mouse clicks:
	    // 0 == left; 1 == middle; 2 == right
	    if (event.button != null) {
	      event.button = (event.button & 1 ? 0 :
	        (event.button & 4 ? 1 :
	          (event.button & 2 ? 2 : 0)));
	    }
	  }

	  // Returns fixed-up instance
	  return event;
	};

	/**
	 * Trigger an event for an element
	 * @param  {Element|Object}      elem  Element to trigger an event on
	 * @param  {Event|Object|String} event A string (the type) or an event object with a type attribute
	 * @private
	 */
	vjs.trigger = function(elem, event) {
	  // Fetches element data and a reference to the parent (for bubbling).
	  // Don't want to add a data object to cache for every parent,
	  // so checking hasData first.
	  var elemData = (vjs.hasData(elem)) ? vjs.getData(elem) : {};
	  var parent = elem.parentNode || elem.ownerDocument;
	      // type = event.type || event,
	      // handler;

	  // If an event name was passed as a string, creates an event out of it
	  if (typeof event === 'string') {
	    event = { type:event, target:elem };
	  }
	  // Normalizes the event properties.
	  event = vjs.fixEvent(event);

	  // If the passed element has a dispatcher, executes the established handlers.
	  if (elemData.dispatcher) {
	    elemData.dispatcher.call(elem, event);
	  }

	  // Unless explicitly stopped or the event does not bubble (e.g. media events)
	    // recursively calls this function to bubble the event up the DOM.
	    if (parent && !event.isPropagationStopped() && event.bubbles !== false) {
	    vjs.trigger(parent, event);

	  // If at the top of the DOM, triggers the default action unless disabled.
	  } else if (!parent && !event.defaultPrevented) {
	    var targetData = vjs.getData(event.target);

	    // Checks if the target has a default action for this event.
	    if (event.target[event.type]) {
	      // Temporarily disables event dispatching on the target as we have already executed the handler.
	      targetData.disabled = true;
	      // Executes the default action.
	      if (typeof event.target[event.type] === 'function') {
	        event.target[event.type]();
	      }
	      // Re-enables event dispatching.
	      targetData.disabled = false;
	    }
	  }

	  // Inform the triggerer if the default was prevented by returning false
	  return !event.defaultPrevented;
	  /* Original version of js ninja events wasn't complete.
	   * We've since updated to the latest version, but keeping this around
	   * for now just in case.
	   */
	  // // Added in addition to book. Book code was broke.
	  // event = typeof event === 'object' ?
	  //   event[vjs.expando] ?
	  //     event :
	  //     new vjs.Event(type, event) :
	  //   new vjs.Event(type);

	  // event.type = type;
	  // if (handler) {
	  //   handler.call(elem, event);
	  // }

	  // // Clean up the event in case it is being reused
	  // event.result = undefined;
	  // event.target = elem;
	};

	/**
	 * Trigger a listener only once for an event
	 * @param  {Element|Object}   elem Element or object to
	 * @param  {String|Array}   type
	 * @param  {Function} fn
	 * @private
	 */
	vjs.one = function(elem, type, fn) {
	  if (vjs.obj.isArray(type)) {
	    return _handleMultipleEvents(vjs.one, elem, type, fn);
	  }
	  var func = function(){
	    vjs.off(elem, type, func);
	    fn.apply(this, arguments);
	  };
	  // copy the guid to the new function so it can removed using the original function's ID
	  func.guid = fn.guid = fn.guid || vjs.guid++;
	  vjs.on(elem, type, func);
	};

	/**
	 * Loops through an array of event types and calls the requested method for each type.
	 * @param  {Function} fn   The event method we want to use.
	 * @param  {Element|Object} elem Element or object to bind listeners to
	 * @param  {String}   type Type of event to bind to.
	 * @param  {Function} callback   Event listener.
	 * @private
	 */
	function _handleMultipleEvents(fn, elem, type, callback) {
	  vjs.arr.forEach(type, function(type) {
	    fn(elem, type, callback); //Call the event method for each one of the types
	  });
	}

	var hasOwnProp = Object.prototype.hasOwnProperty;

	/**
	 * Creates an element and applies properties.
	 * @param  {String=} tagName    Name of tag to be created.
	 * @param  {Object=} properties Element properties to be applied.
	 * @return {Element}
	 * @private
	 */
	vjs.createEl = function(tagName, properties){
	  var el;

	  tagName = tagName || 'div';
	  properties = properties || {};

	  el = document.createElement(tagName);

	  vjs.obj.each(properties, function(propName, val){
	    // Not remembering why we were checking for dash
	    // but using setAttribute means you have to use getAttribute

	    // The check for dash checks for the aria-* attributes, like aria-label, aria-valuemin.
	    // The additional check for "role" is because the default method for adding attributes does not
	    // add the attribute "role". My guess is because it's not a valid attribute in some namespaces, although
	    // browsers handle the attribute just fine. The W3C allows for aria-* attributes to be used in pre-HTML5 docs.
	    // http://www.w3.org/TR/wai-aria-primer/#ariahtml. Using setAttribute gets around this problem.
	    if (propName.indexOf('aria-') !== -1 || propName == 'role') {
	     el.setAttribute(propName, val);
	    } else {
	     el[propName] = val;
	    }
	  });

	  return el;
	};

	/**
	 * Uppercase the first letter of a string
	 * @param  {String} string String to be uppercased
	 * @return {String}
	 * @private
	 */
	vjs.capitalize = function(string){
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};

	/**
	 * Object functions container
	 * @type {Object}
	 * @private
	 */
	vjs.obj = {};

	/**
	 * Object.create shim for prototypal inheritance
	 *
	 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
	 *
	 * @function
	 * @param  {Object}   obj Object to use as prototype
	 * @private
	 */
	vjs.obj.create = Object.create || function(obj){
	  //Create a new function called 'F' which is just an empty object.
	  function F() {}

	  //the prototype of the 'F' function should point to the
	  //parameter of the anonymous function.
	  F.prototype = obj;

	  //create a new constructor function based off of the 'F' function.
	  return new F();
	};

	/**
	 * Loop through each property in an object and call a function
	 * whose arguments are (key,value)
	 * @param  {Object}   obj Object of properties
	 * @param  {Function} fn  Function to be called on each property.
	 * @this {*}
	 * @private
	 */
	vjs.obj.each = function(obj, fn, context){
	  for (var key in obj) {
	    if (hasOwnProp.call(obj, key)) {
	      fn.call(context || this, key, obj[key]);
	    }
	  }
	};

	/**
	 * Merge two objects together and return the original.
	 * @param  {Object} obj1
	 * @param  {Object} obj2
	 * @return {Object}
	 * @private
	 */
	vjs.obj.merge = function(obj1, obj2){
	  if (!obj2) { return obj1; }
	  for (var key in obj2){
	    if (hasOwnProp.call(obj2, key)) {
	      obj1[key] = obj2[key];
	    }
	  }
	  return obj1;
	};

	/**
	 * Merge two objects, and merge any properties that are objects
	 * instead of just overwriting one. Uses to merge options hashes
	 * where deeper default settings are important.
	 * @param  {Object} obj1 Object to override
	 * @param  {Object} obj2 Overriding object
	 * @return {Object}      New object. Obj1 and Obj2 will be untouched.
	 * @private
	 */
	vjs.obj.deepMerge = function(obj1, obj2){
	  var key, val1, val2;

	  // make a copy of obj1 so we're not overwriting original values.
	  // like prototype.options_ and all sub options objects
	  obj1 = vjs.obj.copy(obj1);

	  for (key in obj2){
	    if (hasOwnProp.call(obj2, key)) {
	      val1 = obj1[key];
	      val2 = obj2[key];

	      // Check if both properties are pure objects and do a deep merge if so
	      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
	        obj1[key] = vjs.obj.deepMerge(val1, val2);
	      } else {
	        obj1[key] = obj2[key];
	      }
	    }
	  }
	  return obj1;
	};

	/**
	 * Make a copy of the supplied object
	 * @param  {Object} obj Object to copy
	 * @return {Object}     Copy of object
	 * @private
	 */
	vjs.obj.copy = function(obj){
	  return vjs.obj.merge({}, obj);
	};

	/**
	 * Check if an object is plain, and not a dom node or any object sub-instance
	 * @param  {Object} obj Object to check
	 * @return {Boolean}     True if plain, false otherwise
	 * @private
	 */
	vjs.obj.isPlain = function(obj){
	  return !!obj
	    && typeof obj === 'object'
	    && obj.toString() === '[object Object]'
	    && obj.constructor === Object;
	};

	/**
	 * Check if an object is Array
	*  Since instanceof Array will not work on arrays created in another frame we need to use Array.isArray, but since IE8 does not support Array.isArray we need this shim
	 * @param  {Object} obj Object to check
	 * @return {Boolean}     True if plain, false otherwise
	 * @private
	 */
	vjs.obj.isArray = Array.isArray || function(arr) {
	  return Object.prototype.toString.call(arr) === '[object Array]';
	};

	/**
	 * Check to see whether the input is NaN or not.
	 * NaN is the only JavaScript construct that isn't equal to itself
	 * @param {Number} num Number to check
	 * @return {Boolean} True if NaN, false otherwise
	 * @private
	 */
	vjs.isNaN = function(num) {
	  return num !== num;
	};

	/**
	 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
	   It also stores a unique id on the function so it can be easily removed from events
	 * @param  {*}   context The object to bind as scope
	 * @param  {Function} fn      The function to be bound to a scope
	 * @param  {Number=}   uid     An optional unique ID for the function to be set
	 * @return {Function}
	 * @private
	 */
	vjs.bind = function(context, fn, uid) {
	  // Make sure the function has a unique ID
	  if (!fn.guid) { fn.guid = vjs.guid++; }

	  // Create the new function that changes the context
	  var ret = function() {
	    return fn.apply(context, arguments);
	  };

	  // Allow for the ability to individualize this function
	  // Needed in the case where multiple objects might share the same prototype
	  // IF both items add an event listener with the same function, then you try to remove just one
	  // it will remove both because they both have the same guid.
	  // when using this, you need to use the bind method when you remove the listener as well.
	  // currently used in text tracks
	  ret.guid = (uid) ? uid + '_' + fn.guid : fn.guid;

	  return ret;
	};

	/**
	 * Element Data Store. Allows for binding data to an element without putting it directly on the element.
	 * Ex. Event listeners are stored here.
	 * (also from jsninja.com, slightly modified and updated for closure compiler)
	 * @type {Object}
	 * @private
	 */
	vjs.cache = {};

	/**
	 * Unique ID for an element or function
	 * @type {Number}
	 * @private
	 */
	vjs.guid = 1;

	/**
	 * Unique attribute name to store an element's guid in
	 * @type {String}
	 * @constant
	 * @private
	 */
	vjs.expando = 'vdata' + (new Date()).getTime();

	/**
	 * Returns the cache object where data for an element is stored
	 * @param  {Element} el Element to store data for.
	 * @return {Object}
	 * @private
	 */
	vjs.getData = function(el){
	  var id = el[vjs.expando];
	  if (!id) {
	    id = el[vjs.expando] = vjs.guid++;
	  }
	  if (!vjs.cache[id]) {
	    vjs.cache[id] = {};
	  }
	  return vjs.cache[id];
	};

	/**
	 * Returns the cache object where data for an element is stored
	 * @param  {Element} el Element to store data for.
	 * @return {Object}
	 * @private
	 */
	vjs.hasData = function(el){
	  var id = el[vjs.expando];
	  return !(!id || vjs.isEmpty(vjs.cache[id]));
	};

	/**
	 * Delete data for the element from the cache and the guid attr from getElementById
	 * @param  {Element} el Remove data for an element
	 * @private
	 */
	vjs.removeData = function(el){
	  var id = el[vjs.expando];
	  if (!id) { return; }
	  // Remove all stored data
	  // Changed to = null
	  // http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
	  // vjs.cache[id] = null;
	  delete vjs.cache[id];

	  // Remove the expando property from the DOM node
	  try {
	    delete el[vjs.expando];
	  } catch(e) {
	    if (el.removeAttribute) {
	      el.removeAttribute(vjs.expando);
	    } else {
	      // IE doesn't appear to support removeAttribute on the document element
	      el[vjs.expando] = null;
	    }
	  }
	};

	/**
	 * Check if an object is empty
	 * @param  {Object}  obj The object to check for emptiness
	 * @return {Boolean}
	 * @private
	 */
	vjs.isEmpty = function(obj) {
	  for (var prop in obj) {
	    // Inlude null properties as empty.
	    if (obj[prop] !== null) {
	      return false;
	    }
	  }
	  return true;
	};

	/**
	 * Check if an element has a CSS class
	 * @param {Element} element Element to check
	 * @param {String} classToCheck Classname to check
	 * @private
	 */
	vjs.hasClass = function(element, classToCheck){
	  try{
	    if(element){
	      return ((' ' + element.className + ' ').indexOf(' ' + classToCheck + ' ') !== -1);
	    } else{
	       vjs.log('Error in hasClass, element does not exist');
	    }
	  } catch(e){
	    vjs.log('Exception in hasClass', e);
	  }
	};


	/**
	 * Add a CSS class name to an element
	 * @param {Element} element    Element to add class name to
	 * @param {String} classToAdd Classname to add
	 * @private
	 */
	vjs.addClass = function(element, classToAdd){
	  try{
	    if (element && !vjs.hasClass(element, classToAdd)) {
	      element.className = element.className === '' ? classToAdd : element.className + ' ' + classToAdd;
	    } else {
	      vjs.log('Error in addClass, class or element doesn\'t exist');
	    }
	  } catch(e){
	     vjs.log('Exception in addClass', e);
	  }
	};

	/**
	 * Remove a CSS class name from an element
	 * @param {Element} element    Element to remove from class name
	 * @param {String} classToAdd Classname to remove
	 * @private
	 */
	vjs.removeClass = function(element, classToRemove){
	  var classNames, i;

	  if (!vjs.hasClass(element, classToRemove)) {return;}

	  classNames = element.className.split(' ');

	  // no arr.indexOf in ie8, and we don't want to add a big shim
	  for (i = classNames.length - 1; i >= 0; i--) {
	    if (classNames[i] === classToRemove) {
	      classNames.splice(i,1);
	    }
	  }

	  element.className = classNames.join(' ');
	};

	/**
	 * Element for testing browser HTML5 video capabilities
	 * @type {Element}
	 * @constant
	 * @private
	 */
	vjs.TEST_VID = vjs.createEl('video');
	(function() {
	  var track = document.createElement('track');
	  track.kind = 'captions';
	  track.srclang = 'en';
	  track.label = 'English';
	  vjs.TEST_VID.appendChild(track);
	})();

	/**
	 * Useragent for browser testing.
	 * @type {String}
	 * @constant
	 * @private
	 */
	vjs.USER_AGENT = navigator.userAgent;

	/**
	 * Device is an iPhone
	 * @type {Boolean}
	 * @constant
	 * @private
	 */
	vjs.IS_IPHONE = (/iPhone/i).test(vjs.USER_AGENT);
	vjs.IS_IPAD = (/iPad/i).test(vjs.USER_AGENT);
	vjs.IS_IPOD = (/iPod/i).test(vjs.USER_AGENT);
	vjs.IS_IOS = vjs.IS_IPHONE || vjs.IS_IPAD || vjs.IS_IPOD;

	vjs.IOS_VERSION = (function(){
	  var match = vjs.USER_AGENT.match(/OS (\d+)_/i);
	  if (match && match[1]) { return match[1]; }
	})();

	vjs.IS_ANDROID = (/Android/i).test(vjs.USER_AGENT);
	vjs.ANDROID_VERSION = (function() {
	  // This matches Android Major.Minor.Patch versions
	  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
	  var match = vjs.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i),
	    major,
	    minor;

	  if (!match) {
	    return null;
	  }

	  major = match[1] && parseFloat(match[1]);
	  minor = match[2] && parseFloat(match[2]);

	  if (major && minor) {
	    return parseFloat(match[1] + '.' + match[2]);
	  } else if (major) {
	    return major;
	  } else {
	    return null;
	  }
	})();
	// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
	vjs.IS_OLD_ANDROID = vjs.IS_ANDROID && (/webkit/i).test(vjs.USER_AGENT) && vjs.ANDROID_VERSION < 2.3;

	vjs.IS_FIREFOX = (/Firefox/i).test(vjs.USER_AGENT);
	vjs.IS_CHROME = (/Chrome/i).test(vjs.USER_AGENT);
	vjs.IS_IE8 = (/MSIE\s8\.0/).test(vjs.USER_AGENT);

	vjs.TOUCH_ENABLED = !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch);
	vjs.BACKGROUND_SIZE_SUPPORTED = 'backgroundSize' in vjs.TEST_VID.style;

	/**
	 * Apply attributes to an HTML element.
	 * @param  {Element} el         Target element.
	 * @param  {Object=} attributes Element attributes to be applied.
	 * @private
	 */
	vjs.setElementAttributes = function(el, attributes){
	  vjs.obj.each(attributes, function(attrName, attrValue) {
	    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
	      el.removeAttribute(attrName);
	    } else {
	      el.setAttribute(attrName, (attrValue === true ? '' : attrValue));
	    }
	  });
	};

	/**
	 * Get an element's attribute values, as defined on the HTML tag
	 * Attributes are not the same as properties. They're defined on the tag
	 * or with setAttribute (which shouldn't be used with HTML)
	 * This will return true or false for boolean attributes.
	 * @param  {Element} tag Element from which to get tag attributes
	 * @return {Object}
	 * @private
	 */
	vjs.getElementAttributes = function(tag){
	  var obj, knownBooleans, attrs, attrName, attrVal;

	  obj = {};

	  // known boolean attributes
	  // we can check for matching boolean properties, but older browsers
	  // won't know about HTML5 boolean attributes that we still read from
	  knownBooleans = ','+'autoplay,controls,loop,muted,default'+',';

	  if (tag && tag.attributes && tag.attributes.length > 0) {
	    attrs = tag.attributes;

	    for (var i = attrs.length - 1; i >= 0; i--) {
	      attrName = attrs[i].name;
	      attrVal = attrs[i].value;

	      // check for known booleans
	      // the matching element property will return a value for typeof
	      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(','+attrName+',') !== -1) {
	        // the value of an included boolean attribute is typically an empty
	        // string ('') which would equal false if we just check for a false value.
	        // we also don't want support bad code like autoplay='false'
	        attrVal = (attrVal !== null) ? true : false;
	      }

	      obj[attrName] = attrVal;
	    }
	  }

	  return obj;
	};

	/**
	 * Get the computed style value for an element
	 * From http://robertnyman.com/2006/04/24/get-the-rendered-style-of-an-element/
	 * @param  {Element} el        Element to get style value for
	 * @param  {String} strCssRule Style name
	 * @return {String}            Style value
	 * @private
	 */
	vjs.getComputedDimension = function(el, strCssRule){
	  var strValue = '';
	  if(document.defaultView && document.defaultView.getComputedStyle){
	    strValue = document.defaultView.getComputedStyle(el, '').getPropertyValue(strCssRule);

	  } else if(el.currentStyle){
	    // IE8 Width/Height support
	    strValue = el['client'+strCssRule.substr(0,1).toUpperCase() + strCssRule.substr(1)] + 'px';
	  }
	  return strValue;
	};

	/**
	 * Insert an element as the first child node of another
	 * @param  {Element} child   Element to insert
	 * @param  {[type]} parent Element to insert child into
	 * @private
	 */
	vjs.insertFirst = function(child, parent){
	  if (parent.firstChild) {
	    parent.insertBefore(child, parent.firstChild);
	  } else {
	    parent.appendChild(child);
	  }
	};

	/**
	 * Object to hold browser support information
	 * @type {Object}
	 * @private
	 */
	vjs.browser = {};

	/**
	 * Shorthand for document.getElementById()
	 * Also allows for CSS (jQuery) ID syntax. But nothing other than IDs.
	 * @param  {String} id  Element ID
	 * @return {Element}    Element with supplied ID
	 * @private
	 */
	vjs.el = function(id){
	  if (id.indexOf('#') === 0) {
	    id = id.slice(1);
	  }

	  return document.getElementById(id);
	};

	/**
	 * Format seconds as a time string, H:MM:SS or M:SS
	 * Supplying a guide (in seconds) will force a number of leading zeros
	 * to cover the length of the guide
	 * @param  {Number} seconds Number of seconds to be turned into a string
	 * @param  {Number} guide   Number (in seconds) to model the string after
	 * @return {String}         Time formatted as H:MM:SS or M:SS
	 * @private
	 */
	vjs.formatTime = function(seconds, guide) {
	  // Default to using seconds as guide
	  guide = guide || seconds;
	  var s = Math.floor(seconds % 60),
	      m = Math.floor(seconds / 60 % 60),
	      h = Math.floor(seconds / 3600),
	      gm = Math.floor(guide / 60 % 60),
	      gh = Math.floor(guide / 3600);

	  // handle invalid times
	  if (isNaN(seconds) || seconds === Infinity) {
	    // '-' is false for all relational operators (e.g. <, >=) so this setting
	    // will add the minimum number of fields specified by the guide
	    h = m = s = '-';
	  }

	  // Check if we need to show hours
	  h = (h > 0 || gh > 0) ? h + ':' : '';

	  // If hours are showing, we may need to add a leading zero.
	  // Always show at least one digit of minutes.
	  m = (((h || gm >= 10) && m < 10) ? '0' + m : m) + ':';

	  // Check if leading zero is need for seconds
	  s = (s < 10) ? '0' + s : s;

	  return h + m + s;
	};

	// Attempt to block the ability to select text while dragging controls
	vjs.blockTextSelection = function(){
	  document.body.focus();
	  document.onselectstart = function () { return false; };
	};
	// Turn off text selection blocking
	vjs.unblockTextSelection = function(){ document.onselectstart = function () { return true; }; };

	/**
	 * Trim whitespace from the ends of a string.
	 * @param  {String} string String to trim
	 * @return {String}        Trimmed string
	 * @private
	 */
	vjs.trim = function(str){
	  return (str+'').replace(/^\s+|\s+$/g, '');
	};

	/**
	 * Should round off a number to a decimal place
	 * @param  {Number} num Number to round
	 * @param  {Number} dec Number of decimal places to round to
	 * @return {Number}     Rounded number
	 * @private
	 */
	vjs.round = function(num, dec) {
	  if (!dec) { dec = 0; }
	  return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
	};

	/**
	 * Should create a fake TimeRange object
	 * Mimics an HTML5 time range instance, which has functions that
	 * return the start and end times for a range
	 * TimeRanges are returned by the buffered() method
	 * @param  {Number} start Start time in seconds
	 * @param  {Number} end   End time in seconds
	 * @return {Object}       Fake TimeRange object
	 * @private
	 */
	vjs.createTimeRange = function(start, end){
	  if (start === undefined && end === undefined) {
	    return {
	      length: 0,
	      start: function() {
	        throw new Error('This TimeRanges object is empty');
	      },
	      end: function() {
	        throw new Error('This TimeRanges object is empty');
	      }
	    };
	  }

	  return {
	    length: 1,
	    start: function() { return start; },
	    end: function() { return end; }
	  };
	};

	/**
	 * Add to local storage (may removable)
	 * @private
	 */
	vjs.setLocalStorage = function(key, value){
	  try {
	    // IE was throwing errors referencing the var anywhere without this
	    var localStorage = window.localStorage || false;
	    if (!localStorage) { return; }
	    localStorage[key] = value;
	  } catch(e) {
	    if (e.code == 22 || e.code == 1014) { // Webkit == 22 / Firefox == 1014
	      vjs.log('LocalStorage Full (VideoJS)', e);
	    } else {
	      if (e.code == 18) {
	        vjs.log('LocalStorage not allowed (VideoJS)', e);
	      } else {
	        vjs.log('LocalStorage Error (VideoJS)', e);
	      }
	    }
	  }
	};

	/**
	 * Get absolute version of relative URL. Used to tell flash correct URL.
	 * http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
	 * @param  {String} url URL to make absolute
	 * @return {String}     Absolute URL
	 * @private
	 */
	vjs.getAbsoluteURL = function(url){

	  // Check if absolute URL
	  if (!url.match(/^https?:\/\//)) {
	    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
	    url = vjs.createEl('div', {
	      innerHTML: '<a href="'+url+'">x</a>'
	    }).firstChild.href;
	  }

	  return url;
	};


	/**
	 * Resolve and parse the elements of a URL
	 * @param  {String} url The url to parse
	 * @return {Object}     An object of url details
	 */
	vjs.parseUrl = function(url) {
	  var div, a, addToBody, props, details;

	  props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

	  // add the url to an anchor and let the browser parse the URL
	  a = vjs.createEl('a', { href: url });

	  // IE8 (and 9?) Fix
	  // ie8 doesn't parse the URL correctly until the anchor is actually
	  // added to the body, and an innerHTML is needed to trigger the parsing
	  addToBody = (a.host === '' && a.protocol !== 'file:');
	  if (addToBody) {
	    div = vjs.createEl('div');
	    div.innerHTML = '<a href="'+url+'"></a>';
	    a = div.firstChild;
	    // prevent the div from affecting layout
	    div.setAttribute('style', 'display:none; position:absolute;');
	    document.body.appendChild(div);
	  }

	  // Copy the specific URL properties to a new object
	  // This is also needed for IE8 because the anchor loses its
	  // properties when it's removed from the dom
	  details = {};
	  for (var i = 0; i < props.length; i++) {
	    details[props[i]] = a[props[i]];
	  }

	  // IE9 adds the port to the host property unlike everyone else. If
	  // a port identifier is added for standard ports, strip it.
	  if (details.protocol === 'http:') {
	    details.host = details.host.replace(/:80$/, '');
	  }
	  if (details.protocol === 'https:') {
	    details.host = details.host.replace(/:443$/, '');
	  }

	  if (addToBody) {
	    document.body.removeChild(div);
	  }

	  return details;
	};

	/**
	 * Log messages to the console and history based on the type of message
	 *
	 * @param  {String} type The type of message, or `null` for `log`
	 * @param  {[type]} args The args to be passed to the log
	 * @private
	 */
	function _logType(type, args){

	    return;//TODO minthe to block all video.js log

	  var argsArray, noop, console;

	  // convert args to an array to get array functions
	  argsArray = Array.prototype.slice.call(args);
	  // if there's no console then don't try to output messages
	  // they will still be stored in vjs.log.history
	  // Was setting these once outside of this function, but containing them
	  // in the function makes it easier to test cases where console doesn't exist
	  noop = function(){};
	  console = window['console'] || {
	    'log': noop,
	    'warn': noop,
	    'error': noop
	  };

	  if (type) {
	    // add the type to the front of the message
	    argsArray.unshift(type.toUpperCase()+':');
	  } else {
	    // default to log with no prefix
	    type = 'log';
	  }

	  // add to history
	  vjs.log.history.push(argsArray);

	  // add console prefix after adding to history
	  argsArray.unshift('VIDEOJS:');

	  // call appropriate log function
	  if (console[type].apply) {
	    console[type].apply(console, argsArray);
	  } else {
	    // ie8 doesn't allow error.apply, but it will just join() the array anyway
	    console[type](argsArray.join(' '));
	  }
	}

	/**
	 * Log plain debug messages
	 */
	vjs.log = function(){
	  _logType(null, arguments);
	};

	/**
	 * Keep a history of log messages
	 * @type {Array}
	 */
	vjs.log.history = [];

	/**
	 * Log error messages
	 */
	vjs.log.error = function(){
	  _logType('error', arguments);
	};

	/**
	 * Log warning messages
	 */
	vjs.log.warn = function(){
	  _logType('warn', arguments);
	};

	// Offset Left
	// getBoundingClientRect technique from John Resig http://ejohn.org/blog/getboundingclientrect-is-awesome/
	vjs.findPosition = function(el) {
	  var box, docEl, body, clientLeft, scrollLeft, left, clientTop, scrollTop, top;

	  if (el.getBoundingClientRect && el.parentNode) {
	    box = el.getBoundingClientRect();
	  }

	  if (!box) {
	    return {
	      left: 0,
	      top: 0
	    };
	  }

	  docEl = document.documentElement;
	  body = document.body;

	  clientLeft = docEl.clientLeft || body.clientLeft || 0;
	  scrollLeft = window.pageXOffset || body.scrollLeft;
	  left = box.left + scrollLeft - clientLeft;

	  clientTop = docEl.clientTop || body.clientTop || 0;
	  scrollTop = window.pageYOffset || body.scrollTop;
	  top = box.top + scrollTop - clientTop;

	  // Android sometimes returns slightly off decimal values, so need to round
	  return {
	    left: vjs.round(left),
	    top: vjs.round(top)
	  };
	};

	/**
	 * Array functions container
	 * @type {Object}
	 * @private
	 */
	vjs.arr = {};

	/*
	 * Loops through an array and runs a function for each item inside it.
	 * @param  {Array}    array       The array
	 * @param  {Function} callback    The function to be run for each item
	 * @param  {*}        thisArg     The `this` binding of callback
	 * @returns {Array}               The array
	 * @private
	 */
	vjs.arr.forEach = function(array, callback, thisArg) {
	  if (vjs.obj.isArray(array) && callback instanceof Function) {
	    for (var i = 0, len = array.length; i < len; ++i) {
	      callback.call(thisArg || vjs, array[i], i, array);
	    }
	  }

	  return array;
	};

	/**
	 * Utility functions namespace
	 * @namespace
	 * @type {Object}
	 */
	vjs.util = {};

	/**
	 * Merge two options objects, recursively merging any plain object properties as
	 * well.  Previously `deepMerge`
	 *
	 * @param  {Object} obj1 Object to override values in
	 * @param  {Object} obj2 Overriding object
	 * @return {Object}      New object -- obj1 and obj2 will be untouched
	 */
	vjs.util.mergeOptions = function(obj1, obj2){
	  var key, val1, val2;

	  // make a copy of obj1 so we're not overwriting original values.
	  // like prototype.options_ and all sub options objects
	  obj1 = vjs.obj.copy(obj1);

	  for (key in obj2){
	    if (obj2.hasOwnProperty(key)) {
	      val1 = obj1[key];
	      val2 = obj2[key];

	      // Check if both properties are pure objects and do a deep merge if so
	      if (vjs.obj.isPlain(val1) && vjs.obj.isPlain(val2)) {
	        obj1[key] = vjs.util.mergeOptions(val1, val2);
	      } else {
	        obj1[key] = obj2[key];
	      }
	    }
	  }
	  return obj1;
	};
	vjs.EventEmitter = function() {
	};

	vjs.EventEmitter.prototype.allowedEvents_ = {
	};

	vjs.EventEmitter.prototype.on = function(type, fn) {
	  // Remove the addEventListener alias before calling vjs.on
	  // so we don't get into an infinite type loop
	  var ael = this.addEventListener;
	  this.addEventListener = Function.prototype;
	  vjs.on(this, type, fn);
	  this.addEventListener = ael;
	};
	vjs.EventEmitter.prototype.addEventListener = vjs.EventEmitter.prototype.on;

	vjs.EventEmitter.prototype.off = function(type, fn) {
	  vjs.off(this, type, fn);
	};
	vjs.EventEmitter.prototype.removeEventListener = vjs.EventEmitter.prototype.off;

	vjs.EventEmitter.prototype.one = function(type, fn) {
	  vjs.one(this, type, fn);
	};

	vjs.EventEmitter.prototype.trigger = function(event) {
	  var type = event.type || event;

	  if (typeof event === 'string') {
	    event = {
	      type: type
	    };
	  }
	  event = vjs.fixEvent(event);

	  if (this.allowedEvents_[type] && this['on' + type]) {
	    this['on' + type](event);
	  }

	  vjs.trigger(this, event);
	};
	// The standard DOM EventTarget.dispatchEvent() is aliased to trigger()
	vjs.EventEmitter.prototype.dispatchEvent = vjs.EventEmitter.prototype.trigger;

	/**
	 * @fileoverview Player Component - Base class for all UI objects
	 *
	 */

	/**
	 * Base UI Component class
	 *
	 * Components are embeddable UI objects that are represented by both a
	 * javascript object and an element in the DOM. They can be children of other
	 * components, and can have many children themselves.
	 *
	 *     // adding a button to the player
	 *     var button = player.addChild('button');
	 *     button.el(); // -> button element
	 *
	 *     <div class="video-js">
	 *       <div class="vjs-button">Button</div>
	 *     </div>
	 *
	 * Components are also event emitters.
	 *
	 *     button.on('click', function(){
	 *       console.log('Button Clicked!');
	 *     });
	 *
	 *     button.trigger('customevent');
	 *
	 * @param {Object} player  Main Player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 * @extends vjs.CoreObject
	 */
	vjs.Component = vjs.CoreObject.extend({
	  /**
	   * the constructor function for the class
	   *
	   * @constructor
	   */
	  init: function(player, options, ready){
	    this.player_ = player;

	    // Make a copy of prototype.options_ to protect against overriding global defaults
	    this.options_ = vjs.obj.copy(this.options_);

	    // Updated options with supplied options
	    options = this.options(options);

	    // Get ID from options or options element if one is supplied
	    this.id_ = options['id'] || (options['el'] && options['el']['id']);

	    // If there was no ID from the options, generate one
	    if (!this.id_) {
	      // Don't require the player ID function in the case of mock players
	      this.id_ = ((player.id && player.id()) || 'no_player') + '_component_' + vjs.guid++;
	    }

	    this.name_ = options['name'] || null;

	    // Create element if one wasn't provided in options
	    this.el_ = options['el'] || this.createEl();

	    this.children_ = [];
	    this.childIndex_ = {};
	    this.childNameIndex_ = {};

	    // Add any child components in options
	    this.initChildren();

	    this.ready(ready);
	    // Don't want to trigger ready here or it will before init is actually
	    // finished for all children that run this constructor

	    if (options.reportTouchActivity !== false) {
	      this.enableTouchActivity();
	    }
	  }
	});

	/**
	 * Dispose of the component and all child components
	 */
	vjs.Component.prototype.dispose = function(){
	  this.trigger({ type: 'dispose', 'bubbles': false });

	  // Dispose all children.
	  if (this.children_) {
	    for (var i = this.children_.length - 1; i >= 0; i--) {
	      if (this.children_[i].dispose) {
	        this.children_[i].dispose();
	      }
	    }
	  }

	  // Delete child references
	  this.children_ = null;
	  this.childIndex_ = null;
	  this.childNameIndex_ = null;

	  // Remove all event listeners.
	  this.off();

	  // Remove element from DOM
	  if (this.el_.parentNode) {
	    this.el_.parentNode.removeChild(this.el_);
	  }

	  vjs.removeData(this.el_);
	  this.el_ = null;
	};

	/**
	 * Reference to main player instance
	 *
	 * @type {vjs.Player}
	 * @private
	 */
	vjs.Component.prototype.player_ = true;

	/**
	 * Return the component's player
	 *
	 * @return {vjs.Player}
	 */
	vjs.Component.prototype.player = function(){
	  return this.player_;
	};

	/**
	 * The component's options object
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Component.prototype.options_;

	/**
	 * Deep merge of options objects
	 *
	 * Whenever a property is an object on both options objects
	 * the two properties will be merged using vjs.obj.deepMerge.
	 *
	 * This is used for merging options for child components. We
	 * want it to be easy to override individual options on a child
	 * component without having to rewrite all the other default options.
	 *
	 *     Parent.prototype.options_ = {
	 *       children: {
	 *         'childOne': { 'foo': 'bar', 'asdf': 'fdsa' },
	 *         'childTwo': {},
	 *         'childThree': {}
	 *       }
	 *     }
	 *     newOptions = {
	 *       children: {
	 *         'childOne': { 'foo': 'baz', 'abc': '123' }
	 *         'childTwo': null,
	 *         'childFour': {}
	 *       }
	 *     }
	 *
	 *     this.options(newOptions);
	 *
	 * RESULT
	 *
	 *     {
	 *       children: {
	 *         'childOne': { 'foo': 'baz', 'asdf': 'fdsa', 'abc': '123' },
	 *         'childTwo': null, // Disabled. Won't be initialized.
	 *         'childThree': {},
	 *         'childFour': {}
	 *       }
	 *     }
	 *
	 * @param  {Object} obj Object of new option values
	 * @return {Object}     A NEW object of this.options_ and obj merged
	 */
	vjs.Component.prototype.options = function(obj){
	  if (obj === undefined) return this.options_;

	  return this.options_ = vjs.util.mergeOptions(this.options_, obj);
	};

	/**
	 * The DOM element for the component
	 *
	 * @type {Element}
	 * @private
	 */
	vjs.Component.prototype.el_;

	/**
	 * Create the component's DOM element
	 *
	 * @param  {String=} tagName  Element's node type. e.g. 'div'
	 * @param  {Object=} attributes An object of element attributes that should be set on the element
	 * @return {Element}
	 */
	vjs.Component.prototype.createEl = function(tagName, attributes){
	  return vjs.createEl(tagName, attributes);
	};

	vjs.Component.prototype.localize = function(string){
	  var lang = this.player_.language(),
	      languages = this.player_.languages();
	  if (languages && languages[lang] && languages[lang][string]) {
	    return languages[lang][string];
	  }
	  return string;
	};

	/**
	 * Get the component's DOM element
	 *
	 *     var domEl = myComponent.el();
	 *
	 * @return {Element}
	 */
	vjs.Component.prototype.el = function(){
	  return this.el_;
	};

	/**
	 * An optional element where, if defined, children will be inserted instead of
	 * directly in `el_`
	 *
	 * @type {Element}
	 * @private
	 */
	vjs.Component.prototype.contentEl_;

	/**
	 * Return the component's DOM element for embedding content.
	 * Will either be el_ or a new element defined in createEl.
	 *
	 * @return {Element}
	 */
	vjs.Component.prototype.contentEl = function(){
	  return this.contentEl_ || this.el_;
	};

	/**
	 * The ID for the component
	 *
	 * @type {String}
	 * @private
	 */
	vjs.Component.prototype.id_;

	/**
	 * Get the component's ID
	 *
	 *     var id = myComponent.id();
	 *
	 * @return {String}
	 */
	vjs.Component.prototype.id = function(){
	  return this.id_;
	};

	/**
	 * The name for the component. Often used to reference the component.
	 *
	 * @type {String}
	 * @private
	 */
	vjs.Component.prototype.name_;

	/**
	 * Get the component's name. The name is often used to reference the component.
	 *
	 *     var name = myComponent.name();
	 *
	 * @return {String}
	 */
	vjs.Component.prototype.name = function(){
	  return this.name_;
	};

	/**
	 * Array of child components
	 *
	 * @type {Array}
	 * @private
	 */
	vjs.Component.prototype.children_;

	/**
	 * Get an array of all child components
	 *
	 *     var kids = myComponent.children();
	 *
	 * @return {Array} The children
	 */
	vjs.Component.prototype.children = function(){
	  return this.children_;
	};

	/**
	 * Object of child components by ID
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Component.prototype.childIndex_;

	/**
	 * Returns a child component with the provided ID
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.getChildById = function(id){
	  return this.childIndex_[id];
	};

	/**
	 * Object of child components by name
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Component.prototype.childNameIndex_;

	/**
	 * Returns a child component with the provided name
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.getChild = function(name){
	  return this.childNameIndex_[name];
	};

	/**
	 * Adds a child component inside this component
	 *
	 *     myComponent.el();
	 *     // -> <div class='my-component'></div>
	 *     myComonent.children();
	 *     // [empty array]
	 *
	 *     var myButton = myComponent.addChild('MyButton');
	 *     // -> <div class='my-component'><div class="my-button">myButton<div></div>
	 *     // -> myButton === myComonent.children()[0];
	 *
	 * Pass in options for child constructors and options for children of the child
	 *
	 *     var myButton = myComponent.addChild('MyButton', {
	 *       text: 'Press Me',
	 *       children: {
	 *         buttonChildExample: {
	 *           buttonChildOption: true
	 *         }
	 *       }
	 *     });
	 *
	 * @param {String|vjs.Component} child The class name or instance of a child to add
	 * @param {Object=} options Options, including options to be passed to children of the child.
	 * @return {vjs.Component} The child component (created by this process if a string was used)
	 * @suppress {accessControls|checkRegExp|checkTypes|checkVars|const|constantProperty|deprecated|duplicate|es5Strict|fileoverviewTags|globalThis|invalidCasts|missingProperties|nonStandardJsDocs|strictModuleDepCheck|undefinedNames|undefinedVars|unknownDefines|uselessCode|visibility}
	 */
	vjs.Component.prototype.addChild = function(child, options){
	  var component, componentClass, componentName;

	  // If child is a string, create new component with options
	  if (typeof child === 'string') {
	    componentName = child;

	    // Make sure options is at least an empty object to protect against errors
	    options = options || {};

	    // If no componentClass in options, assume componentClass is the name lowercased
	    // (e.g. playButton)
	    componentClass = options['componentClass'] || vjs.capitalize(componentName);

	    // Set name through options
	    options['name'] = componentName;

	    // Create a new object & element for this controls set
	    // If there's no .player_, this is a player
	    // Closure Compiler throws an 'incomplete alias' warning if we use the vjs variable directly.
	    // Every class should be exported, so this should never be a problem here.
	    component = new window['videojs_apn'][componentClass](this.player_ || this, options);

	  // child is a component instance
	  } else {
	    component = child;
	  }

	  this.children_.push(component);

	  if (typeof component.id === 'function') {
	    this.childIndex_[component.id()] = component;
	  }

	  // If a name wasn't used to create the component, check if we can use the
	  // name function of the component
	  componentName = componentName || (component.name && component.name());

	  if (componentName) {
	    this.childNameIndex_[componentName] = component;
	  }

	  // Add the UI object's element to the container div (box)
	  // Having an element is not required
	  if (typeof component['el'] === 'function' && component['el']()) {
	    this.contentEl().appendChild(component['el']());
	  }

	  // Return so it can stored on parent object if desired.
	  return component;
	};

	/**
	 * Remove a child component from this component's list of children, and the
	 * child component's element from this component's element
	 *
	 * @param  {vjs.Component} component Component to remove
	 */
	vjs.Component.prototype.removeChild = function(component){
	  if (typeof component === 'string') {
	    component = this.getChild(component);
	  }

	  if (!component || !this.children_) return;

	  var childFound = false;
	  for (var i = this.children_.length - 1; i >= 0; i--) {
	    if (this.children_[i] === component) {
	      childFound = true;
	      this.children_.splice(i,1);
	      break;
	    }
	  }

	  if (!childFound) return;

	  this.childIndex_[component.id()] = null;
	  this.childNameIndex_[component.name()] = null;

	  var compEl = component.el();
	  if (compEl && compEl.parentNode === this.contentEl()) {
	    this.contentEl().removeChild(component.el());
	  }
	};

	/**
	 * Add and initialize default child components from options
	 *
	 *     // when an instance of MyComponent is created, all children in options
	 *     // will be added to the instance by their name strings and options
	 *     MyComponent.prototype.options_.children = {
	 *       myChildComponent: {
	 *         myChildOption: true
	 *       }
	 *     }
	 *
	 *     // Or when creating the component
	 *     var myComp = new MyComponent(player, {
	 *       children: {
	 *         myChildComponent: {
	 *           myChildOption: true
	 *         }
	 *       }
	 *     });
	 *
	 * The children option can also be an Array of child names or
	 * child options objects (that also include a 'name' key).
	 *
	 *     var myComp = new MyComponent(player, {
	 *       children: [
	 *         'button',
	 *         {
	 *           name: 'button',
	 *           someOtherOption: true
	 *         }
	 *       ]
	 *     });
	 *
	 */
	vjs.Component.prototype.initChildren = function(){
	  var parent, parentOptions, children, child, name, opts, handleAdd;

	  parent = this;
	  parentOptions = parent.options();
	  children = parentOptions['children'];

	  if (children) {
	    handleAdd = function(name, opts){
	      // Allow options for children to be set at the parent options
	      // e.g. videojs(id, { controlBar: false });
	      // instead of videojs(id, { children: { controlBar: false });
	      if (parentOptions[name] !== undefined) {
	        opts = parentOptions[name];
	      }

	      // Allow for disabling default components
	      // e.g. vjs.options['children']['posterImage'] = false
	      if (opts === false) return;

	      // Create and add the child component.
	      // Add a direct reference to the child by name on the parent instance.
	      // If two of the same component are used, different names should be supplied
	      // for each
	      parent[name] = parent.addChild(name, opts);
	    };

	    // Allow for an array of children details to passed in the options
	    if (vjs.obj.isArray(children)) {
	      for (var i = 0; i < children.length; i++) {
	        child = children[i];

	        if (typeof child == 'string') {
	          // ['myComponent']
	          name = child;
	          opts = {};
	        } else {
	          // [{ name: 'myComponent', otherOption: true }]
	          name = child.name;
	          opts = child;
	        }

	        handleAdd(name, opts);
	      }
	    } else {
	      vjs.obj.each(children, handleAdd);
	    }
	  }
	};

	/**
	 * Allows sub components to stack CSS class names
	 *
	 * @return {String} The constructed class name
	 */
	vjs.Component.prototype.buildCSSClass = function(){
	    // Child classes can include a function that does:
	    // return 'CLASS NAME' + this._super();
	    return '';
	};

	/* Events
	============================================================================= */

	/**
	 * Add an event listener to this component's element
	 *
	 *     var myFunc = function(){
	 *       var myComponent = this;
	 *       // Do something when the event is fired
	 *     };
	 *
	 *     myComponent.on('eventType', myFunc);
	 *
	 * The context of myFunc will be myComponent unless previously bound.
	 *
	 * Alternatively, you can add a listener to another element or component.
	 *
	 *     myComponent.on(otherElement, 'eventName', myFunc);
	 *     myComponent.on(otherComponent, 'eventName', myFunc);
	 *
	 * The benefit of using this over `vjs.on(otherElement, 'eventName', myFunc)`
	 * and `otherComponent.on('eventName', myFunc)` is that this way the listeners
	 * will be automatically cleaned up when either component is disposed.
	 * It will also bind myComponent as the context of myFunc.
	 *
	 * **NOTE**: When using this on elements in the page other than window
	 * and document (both permanent), if you remove the element from the DOM
	 * you need to call `vjs.trigger(el, 'dispose')` on it to clean up
	 * references to it and allow the browser to garbage collect it.
	 *
	 * @param  {String|vjs.Component} first   The event type or other component
	 * @param  {Function|String}      second  The event handler or event type
	 * @param  {Function}             third   The event handler
	 * @return {vjs.Component}        self
	 */
	vjs.Component.prototype.on = function(first, second, third){
	  var target, type, fn, removeOnDispose, cleanRemover, thisComponent;

	  if (typeof first === 'string' || vjs.obj.isArray(first)) {
	    vjs.on(this.el_, first, vjs.bind(this, second));

	  // Targeting another component or element
	  } else {
	    target = first;
	    type = second;
	    fn = vjs.bind(this, third);
	    thisComponent = this;

	    // When this component is disposed, remove the listener from the other component
	    removeOnDispose = function(){
	      thisComponent.off(target, type, fn);
	    };
	    // Use the same function ID so we can remove it later it using the ID
	    // of the original listener
	    removeOnDispose.guid = fn.guid;
	    this.on('dispose', removeOnDispose);

	    // If the other component is disposed first we need to clean the reference
	    // to the other component in this component's removeOnDispose listener
	    // Otherwise we create a memory leak.
	    cleanRemover = function(){
	      thisComponent.off('dispose', removeOnDispose);
	    };
	    // Add the same function ID so we can easily remove it later
	    cleanRemover.guid = fn.guid;

	    // Check if this is a DOM node
	    if (first.nodeName) {
	      // Add the listener to the other element
	      vjs.on(target, type, fn);
	      vjs.on(target, 'dispose', cleanRemover);

	    // Should be a component
	    // Not using `instanceof vjs.Component` because it makes mock players difficult
	    } else if (typeof first.on === 'function') {
	      // Add the listener to the other component
	      target.on(type, fn);
	      target.on('dispose', cleanRemover);
	    }
	  }

	  return this;
	};

	/**
	 * Remove an event listener from this component's element
	 *
	 *     myComponent.off('eventType', myFunc);
	 *
	 * If myFunc is excluded, ALL listeners for the event type will be removed.
	 * If eventType is excluded, ALL listeners will be removed from the component.
	 *
	 * Alternatively you can use `off` to remove listeners that were added to other
	 * elements or components using `myComponent.on(otherComponent...`.
	 * In this case both the event type and listener function are REQUIRED.
	 *
	 *     myComponent.off(otherElement, 'eventType', myFunc);
	 *     myComponent.off(otherComponent, 'eventType', myFunc);
	 *
	 * @param  {String=|vjs.Component}  first  The event type or other component
	 * @param  {Function=|String}       second The listener function or event type
	 * @param  {Function=}              third  The listener for other component
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.off = function(first, second, third){
	  var target, otherComponent, type, fn, otherEl;

	  if (!first || typeof first === 'string' || vjs.obj.isArray(first)) {
	    vjs.off(this.el_, first, second);
	  } else {
	    target = first;
	    type = second;
	    // Ensure there's at least a guid, even if the function hasn't been used
	    fn = vjs.bind(this, third);

	    // Remove the dispose listener on this component,
	    // which was given the same guid as the event listener
	    this.off('dispose', fn);

	    if (first.nodeName) {
	      // Remove the listener
	      vjs.off(target, type, fn);
	      // Remove the listener for cleaning the dispose listener
	      vjs.off(target, 'dispose', fn);
	    } else {
	      target.off(type, fn);
	      target.off('dispose', fn);
	    }
	  }

	  return this;
	};

	/**
	 * Add an event listener to be triggered only once and then removed
	 *
	 *     myComponent.one('eventName', myFunc);
	 *
	 * Alternatively you can add a listener to another element or component
	 * that will be triggered only once.
	 *
	 *     myComponent.one(otherElement, 'eventName', myFunc);
	 *     myComponent.one(otherComponent, 'eventName', myFunc);
	 *
	 * @param  {String|vjs.Component}  first   The event type or other component
	 * @param  {Function|String}       second  The listener function or event type
	 * @param  {Function=}             third   The listener function for other component
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.one = function(first, second, third) {
	  var target, type, fn, thisComponent, newFunc;

	  if (typeof first === 'string' || vjs.obj.isArray(first)) {
	    vjs.one(this.el_, first, vjs.bind(this, second));
	  } else {
	    target = first;
	    type = second;
	    fn = vjs.bind(this, third);
	    thisComponent = this;

	    newFunc = function(){
	      thisComponent.off(target, type, newFunc);
	      fn.apply(this, arguments);
	    };
	    // Keep the same function ID so we can remove it later
	    newFunc.guid = fn.guid;

	    this.on(target, type, newFunc);
	  }

	  return this;
	};

	/**
	 * Trigger an event on an element
	 *
	 *     myComponent.trigger('eventName');
	 *     myComponent.trigger({'type':'eventName'});
	 *
	 * @param  {Event|Object|String} event  A string (the type) or an event object with a type attribute
	 * @return {vjs.Component}       self
	 */
	vjs.Component.prototype.trigger = function(event){
	  vjs.trigger(this.el_, event);
	  return this;
	};

	/* Ready
	================================================================================ */
	/**
	 * Is the component loaded
	 * This can mean different things depending on the component.
	 *
	 * @private
	 * @type {Boolean}
	 */
	vjs.Component.prototype.isReady_;

	/**
	 * Trigger ready as soon as initialization is finished
	 *
	 * Allows for delaying ready. Override on a sub class prototype.
	 * If you set this.isReadyOnInitFinish_ it will affect all components.
	 * Specially used when waiting for the Flash player to asynchronously load.
	 *
	 * @type {Boolean}
	 * @private
	 */
	vjs.Component.prototype.isReadyOnInitFinish_ = true;

	/**
	 * List of ready listeners
	 *
	 * @type {Array}
	 * @private
	 */
	vjs.Component.prototype.readyQueue_;

	/**
	 * Bind a listener to the component's ready state
	 *
	 * Different from event listeners in that if the ready event has already happened
	 * it will trigger the function immediately.
	 *
	 * @param  {Function} fn Ready listener
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.ready = function(fn){
	  if (fn) {
	    if (this.isReady_) {
	      fn.call(this);
	    } else {
	      if (this.readyQueue_ === undefined) {
	        this.readyQueue_ = [];
	      }
	      this.readyQueue_.push(fn);
	    }
	  }
	  return this;
	};

	/**
	 * Trigger the ready listeners
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.triggerReady = function(){
	  this.isReady_ = true;

	  var readyQueue = this.readyQueue_;

	  if (readyQueue && readyQueue.length > 0) {

	    for (var i = 0, j = readyQueue.length; i < j; i++) {
	      readyQueue[i].call(this);
	    }

	    // Reset Ready Queue
	    this.readyQueue_ = [];

	    // Allow for using event listeners also, in case you want to do something everytime a source is ready.
	    this.trigger('ready');
	  }
	};

	/* Display
	============================================================================= */

	/**
	 * Check if a component's element has a CSS class name
	 *
	 * @param {String} classToCheck Classname to check
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.hasClass = function(classToCheck){
	  return vjs.hasClass(this.el_, classToCheck);
	};

	/**
	 * Add a CSS class name to the component's element
	 *
	 * @param {String} classToAdd Classname to add
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.addClass = function(classToAdd){
	  vjs.addClass(this.el_, classToAdd);
	  return this;
	};

	/**
	 * Remove a CSS class name from the component's element
	 *
	 * @param {String} classToRemove Classname to remove
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.removeClass = function(classToRemove){
	  vjs.removeClass(this.el_, classToRemove);
	  return this;
	};

	/**
	 * Show the component element if hidden
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.show = function(){
	  this.removeClass('vjs-hidden');
	  return this;
	};

	/**
	 * Hide the component element if currently showing
	 *
	 * @return {vjs.Component}
	 */
	vjs.Component.prototype.hide = function(){
	  this.addClass('vjs-hidden');
	  return this;
	};

	/**
	 * Lock an item in its visible state
	 * To be used with fadeIn/fadeOut.
	 *
	 * @return {vjs.Component}
	 * @private
	 */
	vjs.Component.prototype.lockShowing = function(){
	  this.addClass('vjs-lock-showing');
	  return this;
	};

	/**
	 * Unlock an item to be hidden
	 * To be used with fadeIn/fadeOut.
	 *
	 * @return {vjs.Component}
	 * @private
	 */
	vjs.Component.prototype.unlockShowing = function(){
	  this.removeClass('vjs-lock-showing');
	  return this;
	};

	/**
	 * Disable component by making it unshowable
	 *
	 * Currently private because we're moving towards more css-based states.
	 * @private
	 */
	vjs.Component.prototype.disable = function(){
	  this.hide();
	  this.show = function(){};
	};

	/**
	 * Set or get the width of the component (CSS values)
	 *
	 * Setting the video tag dimension values only works with values in pixels.
	 * Percent values will not work.
	 * Some percents can be used, but width()/height() will return the number + %,
	 * not the actual computed width/height.
	 *
	 * @param  {Number|String=} num   Optional width number
	 * @param  {Boolean} skipListeners Skip the 'resize' event trigger
	 * @return {vjs.Component} This component, when setting the width
	 * @return {Number|String} The width, when getting
	 */
	vjs.Component.prototype.width = function(num, skipListeners){
	  return this.dimension('width', num, skipListeners);
	};

	/**
	 * Get or set the height of the component (CSS values)
	 *
	 * Setting the video tag dimension values only works with values in pixels.
	 * Percent values will not work.
	 * Some percents can be used, but width()/height() will return the number + %,
	 * not the actual computed width/height.
	 *
	 * @param  {Number|String=} num     New component height
	 * @param  {Boolean=} skipListeners Skip the resize event trigger
	 * @return {vjs.Component} This component, when setting the height
	 * @return {Number|String} The height, when getting
	 */
	vjs.Component.prototype.height = function(num, skipListeners){
	  return this.dimension('height', num, skipListeners);
	};

	/**
	 * Set both width and height at the same time
	 *
	 * @param  {Number|String} width
	 * @param  {Number|String} height
	 * @return {vjs.Component} The component
	 */
	vjs.Component.prototype.dimensions = function(width, height){
	  // Skip resize listeners on width for optimization
	  return this.width(width, true).height(height);
	};

	/**
	 * Get or set width or height
	 *
	 * This is the shared code for the width() and height() methods.
	 * All for an integer, integer + 'px' or integer + '%';
	 *
	 * Known issue: Hidden elements officially have a width of 0. We're defaulting
	 * to the style.width value and falling back to computedStyle which has the
	 * hidden element issue. Info, but probably not an efficient fix:
	 * http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/
	 *
	 * @param  {String} widthOrHeight  'width' or 'height'
	 * @param  {Number|String=} num     New dimension
	 * @param  {Boolean=} skipListeners Skip resize event trigger
	 * @return {vjs.Component} The component if a dimension was set
	 * @return {Number|String} The dimension if nothing was set
	 * @private
	 */
	vjs.Component.prototype.dimension = function(widthOrHeight, num, skipListeners){
	  if (num !== undefined) {
	    if (num === null || vjs.isNaN(num)) {
	      num = 0;
	    }

	    // Check if using css width/height (% or px) and adjust
	    if ((''+num).indexOf('%') !== -1 || (''+num).indexOf('px') !== -1) {
	      this.el_.style[widthOrHeight] = num;
	    } else if (num === 'auto') {
	      this.el_.style[widthOrHeight] = '';
	    } else {
	      this.el_.style[widthOrHeight] = num+'px';
	    }

	    // skipListeners allows us to avoid triggering the resize event when setting both width and height
	    if (!skipListeners) { this.trigger('resize'); }

	    // Return component
	    return this;
	  }

	  // Not setting a value, so getting it
	  // Make sure element exists
	  if (!this.el_) return 0;

	  // Get dimension value from style
	  var val = this.el_.style[widthOrHeight];
	  var pxIndex = val.indexOf('px');
	  if (pxIndex !== -1) {
	    // Return the pixel value with no 'px'
	    return parseInt(val.slice(0,pxIndex), 10);

	  // No px so using % or no style was set, so falling back to offsetWidth/height
	  // If component has display:none, offset will return 0
	  // TODO: handle display:none and no dimension style using px
	  } else {

	    return parseInt(this.el_['offset'+vjs.capitalize(widthOrHeight)], 10);

	    // ComputedStyle version.
	    // Only difference is if the element is hidden it will return
	    // the percent value (e.g. '100%'')
	    // instead of zero like offsetWidth returns.
	    // var val = vjs.getComputedStyleValue(this.el_, widthOrHeight);
	    // var pxIndex = val.indexOf('px');

	    // if (pxIndex !== -1) {
	    //   return val.slice(0, pxIndex);
	    // } else {
	    //   return val;
	    // }
	  }
	};

	/**
	 * Fired when the width and/or height of the component changes
	 * @event resize
	 */
	vjs.Component.prototype.onResize;

	/**
	 * Emit 'tap' events when touch events are supported
	 *
	 * This is used to support toggling the controls through a tap on the video.
	 *
	 * We're requiring them to be enabled because otherwise every component would
	 * have this extra overhead unnecessarily, on mobile devices where extra
	 * overhead is especially bad.
	 * @private
	 */
	vjs.Component.prototype.emitTapEvents = function(){
	  var touchStart, firstTouch, touchTime, couldBeTap, noTap,
	      xdiff, ydiff, touchDistance, tapMovementThreshold, touchTimeThreshold;

	  // Track the start time so we can determine how long the touch lasted
	  touchStart = 0;
	  firstTouch = null;

	  // Maximum movement allowed during a touch event to still be considered a tap
	  // Other popular libs use anywhere from 2 (hammer.js) to 15, so 10 seems like a nice, round number.
	  tapMovementThreshold = 10;

	  // The maximum length a touch can be while still being considered a tap
	  touchTimeThreshold = 200;

	  this.on('touchstart', function(event) {
	    // If more than one finger, don't consider treating this as a click
	    if (event.touches.length === 1) {
	      firstTouch = vjs.obj.copy(event.touches[0]);
	      // Record start time so we can detect a tap vs. "touch and hold"
	      touchStart = new Date().getTime();
	      // Reset couldBeTap tracking
	      couldBeTap = true;
	    }
	  });

	  this.on('touchmove', function(event) {
	    // If more than one finger, don't consider treating this as a click
	    if (event.touches.length > 1) {
	      couldBeTap = false;
	    } else if (firstTouch) {
	      // Some devices will throw touchmoves for all but the slightest of taps.
	      // So, if we moved only a small distance, this could still be a tap
	      xdiff = event.touches[0].pageX - firstTouch.pageX;
	      ydiff = event.touches[0].pageY - firstTouch.pageY;
	      touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	      if (touchDistance > tapMovementThreshold) {
	        couldBeTap = false;
	      }
	    }
	  });

	  noTap = function(){
	    couldBeTap = false;
	  };
	  // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
	  this.on('touchleave', noTap);
	  this.on('touchcancel', noTap);

	  // When the touch ends, measure how long it took and trigger the appropriate
	  // event
	  this.on('touchend', function(event) {
	    firstTouch = null;
	    // Proceed only if the touchmove/leave/cancel event didn't happen
	    if (couldBeTap === true) {
	      // Measure how long the touch lasted
	      touchTime = new Date().getTime() - touchStart;
	      // Make sure the touch was less than the threshold to be considered a tap
	      if (touchTime < touchTimeThreshold) {
	        event.preventDefault(); // Don't let browser turn this into a click
	        this.trigger('tap');
	        // It may be good to copy the touchend event object and change the
	        // type to tap, if the other event properties aren't exact after
	        // vjs.fixEvent runs (e.g. event.target)
	      }
	    }
	  });
	};

	/**
	 * Report user touch activity when touch events occur
	 *
	 * User activity is used to determine when controls should show/hide. It's
	 * relatively simple when it comes to mouse events, because any mouse event
	 * should show the controls. So we capture mouse events that bubble up to the
	 * player and report activity when that happens.
	 *
	 * With touch events it isn't as easy. We can't rely on touch events at the
	 * player level, because a tap (touchstart + touchend) on the video itself on
	 * mobile devices is meant to turn controls off (and on). User activity is
	 * checked asynchronously, so what could happen is a tap event on the video
	 * turns the controls off, then the touchend event bubbles up to the player,
	 * which if it reported user activity, would turn the controls right back on.
	 * (We also don't want to completely block touch events from bubbling up)
	 *
	 * Also a touchmove, touch+hold, and anything other than a tap is not supposed
	 * to turn the controls back on on a mobile device.
	 *
	 * Here we're setting the default component behavior to report user activity
	 * whenever touch events happen, and this can be turned off by components that
	 * want touch events to act differently.
	 */
	vjs.Component.prototype.enableTouchActivity = function() {
	  var report, touchHolding, touchEnd;

	  // Don't continue if the root player doesn't support reporting user activity
	  if (!this.player().reportUserActivity) {
	    return;
	  }

	  // listener for reporting that the user is active
	  report = vjs.bind(this.player(), this.player().reportUserActivity);

	  this.on('touchstart', function() {
	    report();
	    // For as long as the they are touching the device or have their mouse down,
	    // we consider them active even if they're not moving their finger or mouse.
	    // So we want to continue to update that they are active
	    this.clearInterval(touchHolding);
	    // report at the same interval as activityCheck
	    touchHolding = this.setInterval(report, 250);
	  });

	  touchEnd = function(event) {
	    report();
	    // stop the interval that maintains activity if the touch is holding
	    this.clearInterval(touchHolding);
	  };

	  this.on('touchmove', report);
	  this.on('touchend', touchEnd);
	  this.on('touchcancel', touchEnd);
	};

	/**
	 * Creates timeout and sets up disposal automatically.
	 * @param {Function} fn The function to run after the timeout.
	 * @param {Number} timeout Number of ms to delay before executing specified function.
	 * @return {Number} Returns the timeout ID
	 */
	vjs.Component.prototype.setTimeout = function(fn, timeout) {
	  fn = vjs.bind(this, fn);

	  // window.setTimeout would be preferable here, but due to some bizarre issue with Sinon and/or Phantomjs, we can't.
	  var timeoutId = setTimeout(fn, timeout);

	  var disposeFn = function() {
	    this.clearTimeout(timeoutId);
	  };

	  disposeFn.guid = 'vjs-timeout-'+ timeoutId;

	  this.on('dispose', disposeFn);

	  return timeoutId;
	};


	/**
	 * Clears a timeout and removes the associated dispose listener
	 * @param {Number} timeoutId The id of the timeout to clear
	 * @return {Number} Returns the timeout ID
	 */
	vjs.Component.prototype.clearTimeout = function(timeoutId) {
	  clearTimeout(timeoutId);

	  var disposeFn = function(){};
	  disposeFn.guid = 'vjs-timeout-'+ timeoutId;

	  this.off('dispose', disposeFn);

	  return timeoutId;
	};

	/**
	 * Creates an interval and sets up disposal automatically.
	 * @param {Function} fn The function to run every N seconds.
	 * @param {Number} interval Number of ms to delay before executing specified function.
	 * @return {Number} Returns the interval ID
	 */
	vjs.Component.prototype.setInterval = function(fn, interval) {
	  fn = vjs.bind(this, fn);

	  var intervalId = setInterval(fn, interval);

	  var disposeFn = function() {
	    this.clearInterval(intervalId);
	  };

	  disposeFn.guid = 'vjs-interval-'+ intervalId;

	  this.on('dispose', disposeFn);

	  return intervalId;
	};

	/**
	 * Clears an interval and removes the associated dispose listener
	 * @param {Number} intervalId The id of the interval to clear
	 * @return {Number} Returns the interval ID
	 */
	vjs.Component.prototype.clearInterval = function(intervalId) {
	  clearInterval(intervalId);

	  var disposeFn = function(){};
	  disposeFn.guid = 'vjs-interval-'+ intervalId;

	  this.off('dispose', disposeFn);

	  return intervalId;
	};

	/* Button - Base class for all buttons
	================================================================================ */
	/**
	 * Base class for all buttons
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.Button = vjs.Component.extend({
	  /**
	   * @constructor
	   * @inheritDoc
	   */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.emitTapEvents();

	    this.on('tap', this.onClick);
	    this.on('click', this.onClick);
	    this.on('focus', this.onFocus);
	    this.on('blur', this.onBlur);
	  }
	});

	vjs.Button.prototype.createEl = function(type, props){
	  var el;

	  // Add standard Aria and Tabindex info
	  props = vjs.obj.merge({
	    className: this.buildCSSClass(),
	    'role': 'button',
	    'aria-live': 'polite', // let the screen reader user know that the text of the button may change
	    tabIndex: 0
	  }, props);

	  el = vjs.Component.prototype.createEl.call(this, type, props);

	  // if innerHTML hasn't been overridden (bigPlayButton), add content elements
	  if (!props.innerHTML) {
	    this.contentEl_ = vjs.createEl('div', {
	      className: 'vjs-control-content'
	    });

	    this.controlText_ = vjs.createEl('span', {
	      className: 'vjs-control-text',
	      innerHTML: this.localize(this.buttonText) || 'Need Text'
	    });

	    this.contentEl_.appendChild(this.controlText_);
	    el.appendChild(this.contentEl_);
	  }

	  return el;
	};

	vjs.Button.prototype.buildCSSClass = function(){
	  // TODO: Change vjs-control to vjs-button?
	  return 'vjs-control ' + vjs.Component.prototype.buildCSSClass.call(this);
	};

	  // Click - Override with specific functionality for button
	vjs.Button.prototype.onClick = function(){};

	  // Focus - Add keyboard functionality to element
	vjs.Button.prototype.onFocus = function(){
	  vjs.on(document, 'keydown', vjs.bind(this, this.onKeyPress));
	};

	  // KeyPress (document level) - Trigger click when keys are pressed
	vjs.Button.prototype.onKeyPress = function(event){
	  // Check for space bar (32) or enter (13) keys
	  if (event.which == 32 || event.which == 13) {
	    event.preventDefault();
	    this.onClick();
	  }
	};

	// Blur - Remove keyboard triggers
	vjs.Button.prototype.onBlur = function(){
	  vjs.off(document, 'keydown', vjs.bind(this, this.onKeyPress));
	};

	/* Slider
	================================================================================ */
	/**
	 * The base functionality for sliders like the volume bar and seek bar
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.Slider = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // Set property names to bar and handle to match with the child Slider class is looking for
	    this.bar = this.getChild(this.options_['barName']);
	    this.handle = this.getChild(this.options_['handleName']);

	    this.on('mousedown', this.onMouseDown);
	    this.on('touchstart', this.onMouseDown);
	    this.on('focus', this.onFocus);
	    this.on('blur', this.onBlur);
	    this.on('click', this.onClick);

	    this.on(player, 'controlsvisible', this.update);
	    this.on(player, this.playerEvent, this.update);
	  }
	});

	vjs.Slider.prototype.createEl = function(type, props) {
	  props = props || {};
	  // Add the slider element class to all sub classes
	  props.className = props.className + ' vjs-slider';
	  props = vjs.obj.merge({
	    'role': 'slider',
	    'aria-valuenow': 0,
	    'aria-valuemin': 0,
	    'aria-valuemax': 100,
	    tabIndex: 0
	  }, props);

	  return vjs.Component.prototype.createEl.call(this, type, props);
	};

	vjs.Slider.prototype.onMouseDown = function(event){
	  event.preventDefault();
	  vjs.blockTextSelection();
	  this.addClass('vjs-sliding');

	  this.on(document, 'mousemove', this.onMouseMove);
	  this.on(document, 'mouseup', this.onMouseUp);
	  this.on(document, 'touchmove', this.onMouseMove);
	  this.on(document, 'touchend', this.onMouseUp);

	  this.onMouseMove(event);
	};

	// To be overridden by a subclass
	vjs.Slider.prototype.onMouseMove = function(){};

	vjs.Slider.prototype.onMouseUp = function() {
	  vjs.unblockTextSelection();
	  this.removeClass('vjs-sliding');

	  this.off(document, 'mousemove', this.onMouseMove);
	  this.off(document, 'mouseup', this.onMouseUp);
	  this.off(document, 'touchmove', this.onMouseMove);
	  this.off(document, 'touchend', this.onMouseUp);

	  this.update();
	};

	vjs.Slider.prototype.update = function(){
	  // In VolumeBar init we have a setTimeout for update that pops and update to the end of the
	  // execution stack. The player is destroyed before then update will cause an error
	  if (!this.el_) return;

	  // If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.
	  // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.
	  // var progress =  (this.player_.scrubbing) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();

	  var barProgress,
	      progress = this.getPercent(),
	      handle = this.handle,
	      bar = this.bar;

	  // Protect against no duration and other division issues
	  if (typeof progress !== 'number' ||
	      progress !== progress ||
	      progress < 0 ||
	      progress === Infinity) {
	        progress = 0;
	  }

	  barProgress = progress;

	  // If there is a handle, we need to account for the handle in our calculation for progress bar
	  // so that it doesn't fall short of or extend past the handle.
	  if (handle) {

	    var box = this.el_,
	        boxWidth = box.offsetWidth,

	        handleWidth = handle.el().offsetWidth,

	        // The width of the handle in percent of the containing box
	        // In IE, widths may not be ready yet causing NaN
	        handlePercent = (handleWidth) ? handleWidth / boxWidth : 0,

	        // Get the adjusted size of the box, considering that the handle's center never touches the left or right side.
	        // There is a margin of half the handle's width on both sides.
	        boxAdjustedPercent = 1 - handlePercent,

	        // Adjust the progress that we'll use to set widths to the new adjusted box width
	        adjustedProgress = progress * boxAdjustedPercent;

	    // The bar does reach the left side, so we need to account for this in the bar's width
	    barProgress = adjustedProgress + (handlePercent / 2);

	    // Move the handle from the left based on the adjected progress
	    handle.el().style.left = vjs.round(adjustedProgress * 100, 2) + '%';
	  }

	  // Set the new bar width
	  if (bar) {
	    bar.el().style.width = vjs.round(barProgress * 100, 2) + '%';
	  }
	};

	vjs.Slider.prototype.calculateDistance = function(event){
	  var el, box, boxX, boxY, boxW, boxH, handle, pageX, pageY;

	  el = this.el_;
	  box = vjs.findPosition(el);
	  boxW = boxH = el.offsetWidth;
	  handle = this.handle;

	  if (this.options()['vertical']) {
	    boxY = box.top;

	    if (event.changedTouches) {
	      pageY = event.changedTouches[0].pageY;
	    } else {
	      pageY = event.pageY;
	    }

	    if (handle) {
	      var handleH = handle.el().offsetHeight;
	      // Adjusted X and Width, so handle doesn't go outside the bar
	      boxY = boxY + (handleH / 2);
	      boxH = boxH - handleH;
	    }

	    // Percent that the click is through the adjusted area
	    return Math.max(0, Math.min(1, ((boxY - pageY) + boxH) / boxH));

	  } else {
	    boxX = box.left;

	    if (event.changedTouches) {
	      pageX = event.changedTouches[0].pageX;
	    } else {
	      pageX = event.pageX;
	    }

	    if (handle) {
	      var handleW = handle.el().offsetWidth;

	      // Adjusted X and Width, so handle doesn't go outside the bar
	      boxX = boxX + (handleW / 2);
	      boxW = boxW - handleW;
	    }

	    // Percent that the click is through the adjusted area
	    return Math.max(0, Math.min(1, (pageX - boxX) / boxW));
	  }
	};

	vjs.Slider.prototype.onFocus = function(){
	  this.on(document, 'keydown', this.onKeyPress);
	};

	vjs.Slider.prototype.onKeyPress = function(event){
	  if (event.which == 37 || event.which == 40) { // Left and Down Arrows
	    event.preventDefault();
	    this.stepBack();
	  } else if (event.which == 38 || event.which == 39) { // Up and Right Arrows
	    event.preventDefault();
	    this.stepForward();
	  }
	};

	vjs.Slider.prototype.onBlur = function(){
	  this.off(document, 'keydown', this.onKeyPress);
	};

	/**
	 * Listener for click events on slider, used to prevent clicks
	 *   from bubbling up to parent elements like button menus.
	 * @param  {Object} event Event object
	 */
	vjs.Slider.prototype.onClick = function(event){
	  event.stopImmediatePropagation();
	  event.preventDefault();
	};

	/**
	 * SeekBar Behavior includes play progress bar, and seek handle
	 * Needed so it can determine seek position based on handle position/size
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.SliderHandle = vjs.Component.extend();

	/**
	 * Default value of the slider
	 *
	 * @type {Number}
	 * @private
	 */
	vjs.SliderHandle.prototype.defaultValue = 0;

	/** @inheritDoc */
	vjs.SliderHandle.prototype.createEl = function(type, props) {
	  props = props || {};
	  // Add the slider element class to all sub classes
	  props.className = props.className + ' vjs-slider-handle';
	  props = vjs.obj.merge({
	    innerHTML: '<span class="vjs-control-text">'+this.defaultValue+'</span>'
	  }, props);

	  return vjs.Component.prototype.createEl.call(this, 'div', props);
	};

	/* Menu
	================================================================================ */
	/**
	 * The Menu component is used to build pop up menus, including subtitle and
	 * captions selection menus.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.Menu = vjs.Component.extend();

	/**
	 * Add a menu item to the menu
	 * @param {Object|String} component Component or component type to add
	 */
	vjs.Menu.prototype.addItem = function(component){
	  this.addChild(component);
	  component.on('click', vjs.bind(this, function(){
	    this.unlockShowing();
	  }));
	};

	/** @inheritDoc */
	vjs.Menu.prototype.createEl = function(){
	  var contentElType = this.options().contentElType || 'ul';
	  this.contentEl_ = vjs.createEl(contentElType, {
	    className: 'vjs-menu-content'
	  });
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    append: this.contentEl_,
	    className: 'vjs-menu'
	  });
	  el.appendChild(this.contentEl_);

	  // Prevent clicks from bubbling up. Needed for Menu Buttons,
	  // where a click on the parent is significant
	  vjs.on(el, 'click', function(event){
	    event.preventDefault();
	    event.stopImmediatePropagation();
	  });

	  return el;
	};

	/**
	 * The component for a menu item. `<li>`
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.MenuItem = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);
	    this.selected(options['selected']);
	  }
	});

	/** @inheritDoc */
	vjs.MenuItem.prototype.createEl = function(type, props){
	  return vjs.Button.prototype.createEl.call(this, 'li', vjs.obj.merge({
	    className: 'vjs-menu-item',
	    innerHTML: this.localize(this.options_['label'])
	  }, props));
	};

	/**
	 * Handle a click on the menu item, and set it to selected
	 */
	vjs.MenuItem.prototype.onClick = function(){
	  this.selected(true);
	};

	/**
	 * Set this menu item as selected or not
	 * @param  {Boolean} selected
	 */
	vjs.MenuItem.prototype.selected = function(selected){
	  if (selected) {
	    this.addClass('vjs-selected');
	    this.el_.setAttribute('aria-selected',true);
	  } else {
	    this.removeClass('vjs-selected');
	    this.el_.setAttribute('aria-selected',false);
	  }
	};


	/**
	 * A button class with a popup menu
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.MenuButton = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.update();

	    this.on('keydown', this.onKeyPress);
	    this.el_.setAttribute('aria-haspopup', true);
	    this.el_.setAttribute('role', 'button');
	  }
	});

	vjs.MenuButton.prototype.update = function() {
	  var menu = this.createMenu();

	  if (this.menu) {
	    this.removeChild(this.menu);
	  }

	  this.menu = menu;
	  this.addChild(menu);

	  if (this.items && this.items.length === 0) {
	    this.hide();
	  } else if (this.items && this.items.length > 1) {
	    this.show();
	  }
	};

	/**
	 * Track the state of the menu button
	 * @type {Boolean}
	 * @private
	 */
	vjs.MenuButton.prototype.buttonPressed_ = false;

	vjs.MenuButton.prototype.createMenu = function(){
	  var menu = new vjs.Menu(this.player_);

	  // Add a title list item to the top
	  if (this.options().title) {
	    menu.contentEl().appendChild(vjs.createEl('li', {
	      className: 'vjs-menu-title',
	      innerHTML: vjs.capitalize(this.options().title),
	      tabindex: -1
	    }));
	  }

	  this.items = this['createItems']();

	  if (this.items) {
	    // Add menu items to the menu
	    for (var i = 0; i < this.items.length; i++) {
	      menu.addItem(this.items[i]);
	    }
	  }

	  return menu;
	};

	/**
	 * Create the list of menu items. Specific to each subclass.
	 */
	vjs.MenuButton.prototype.createItems = function(){};

	/** @inheritDoc */
	vjs.MenuButton.prototype.buildCSSClass = function(){
	  return this.className + ' vjs-menu-button ' + vjs.Button.prototype.buildCSSClass.call(this);
	};

	// Focus - Add keyboard functionality to element
	// This function is not needed anymore. Instead, the keyboard functionality is handled by
	// treating the button as triggering a submenu. When the button is pressed, the submenu
	// appears. Pressing the button again makes the submenu disappear.
	vjs.MenuButton.prototype.onFocus = function(){};
	// Can't turn off list display that we turned on with focus, because list would go away.
	vjs.MenuButton.prototype.onBlur = function(){};

	vjs.MenuButton.prototype.onClick = function(){
	  // When you click the button it adds focus, which will show the menu indefinitely.
	  // So we'll remove focus when the mouse leaves the button.
	  // Focus is needed for tab navigation.
	  this.one('mouseout', vjs.bind(this, function(){
	    this.menu.unlockShowing();
	    this.el_.blur();
	  }));
	  if (this.buttonPressed_){
	    this.unpressButton();
	  } else {
	    this.pressButton();
	  }
	};

	vjs.MenuButton.prototype.onKeyPress = function(event){

	  // Check for space bar (32) or enter (13) keys
	  if (event.which == 32 || event.which == 13) {
	    if (this.buttonPressed_){
	      this.unpressButton();
	    } else {
	      this.pressButton();
	    }
	    event.preventDefault();
	  // Check for escape (27) key
	  } else if (event.which == 27){
	    if (this.buttonPressed_){
	      this.unpressButton();
	    }
	    event.preventDefault();
	  }
	};

	vjs.MenuButton.prototype.pressButton = function(){
	  this.buttonPressed_ = true;
	  this.menu.lockShowing();
	  this.el_.setAttribute('aria-pressed', true);
	  if (this.items && this.items.length > 0) {
	    this.items[0].el().focus(); // set the focus to the title of the submenu
	  }
	};

	vjs.MenuButton.prototype.unpressButton = function(){
	  this.buttonPressed_ = false;
	  this.menu.unlockShowing();
	  this.el_.setAttribute('aria-pressed', false);
	};

	/**
	 * Custom MediaError to mimic the HTML5 MediaError
	 * @param {Number} code The media error code
	 */
	vjs.MediaError = function(code){

	  if (typeof code === 'number') {
	    this.code = code;
	  } else if (typeof code === 'string') {
	    // default code is zero, so this is a custom error
	    this.message = code;
	  } else if (typeof code === 'object') { // object
	    vjs.obj.merge(this, code);
	  }

	  if (!this.message) {
	    //this.message = vjs.MediaError.defaultMessages[this.code] || '';
	    this.message = '';//VID-1444
	  }
	};

	/**
	 * The error code that refers two one of the defined
	 * MediaError types
	 * @type {Number}
	 */
	vjs.MediaError.prototype.code = 0;

	/**
	 * An optional message to be shown with the error.
	 * Message is not part of the HTML5 video spec
	 * but allows for more informative custom errors.
	 * @type {String}
	 */
	vjs.MediaError.prototype.message = '';

	/**
	 * An optional status code that can be set by plugins
	 * to allow even more detail about the error.
	 * For example the HLS plugin might provide the specific
	 * HTTP status code that was returned when the error
	 * occurred, then allowing a custom error overlay
	 * to display more information.
	 * @type {[type]}
	 */
	vjs.MediaError.prototype.status = null;

	vjs.MediaError.errorTypes = [
	  'MEDIA_ERR_CUSTOM',            // = 0
	  'MEDIA_ERR_ABORTED',           // = 1
	  'MEDIA_ERR_NETWORK',           // = 2
	  'MEDIA_ERR_DECODE',            // = 3
	  'MEDIA_ERR_SRC_NOT_SUPPORTED', // = 4
	  'MEDIA_ERR_ENCRYPTED'          // = 5
	];

	vjs.MediaError.defaultMessages = {
	  1: 'You aborted the video playback',
	  2: 'A network error caused the video download to fail part-way.',
	  3: 'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',
	  4: 'The video could not be loaded, either because the server or network failed or because the format is not supported.',
	  5: 'The video is encrypted and we do not have the keys to decrypt it.'
	};

	// Add types as properties on MediaError
	// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
	for (var errNum = 0; errNum < vjs.MediaError.errorTypes.length; errNum++) {
	  vjs.MediaError[vjs.MediaError.errorTypes[errNum]] = errNum;
	  // values should be accessible on both the class and instance
	  vjs.MediaError.prototype[vjs.MediaError.errorTypes[errNum]] = errNum;
	}

	(function(){
	  var apiMap, specApi, browserApi, i;

	  /**
	   * Store the browser-specific methods for the fullscreen API
	   * @type {Object|undefined}
	   * @private
	   */
	  vjs.browser.fullscreenAPI;

	  // browser API methods
	  // map approach from Screenful.js - https://github.com/sindresorhus/screenfull.js
	  apiMap = [
	    // Spec: https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
	    [
	      'requestFullscreen',
	      'exitFullscreen',
	      'fullscreenElement',
	      'fullscreenEnabled',
	      'fullscreenchange',
	      'fullscreenerror'
	    ],
	    // WebKit
	    [
	      'webkitRequestFullscreen',
	      'webkitExitFullscreen',
	      'webkitFullscreenElement',
	      'webkitFullscreenEnabled',
	      'webkitfullscreenchange',
	      'webkitfullscreenerror'
	    ],
	    // Old WebKit (Safari 5.1)
	    [
	      'webkitRequestFullScreen',
	      'webkitCancelFullScreen',
	      'webkitCurrentFullScreenElement',
	      'webkitCancelFullScreen',
	      'webkitfullscreenchange',
	      'webkitfullscreenerror'
	    ],
	    // Mozilla
	    [
	      'mozRequestFullScreen',
	      'mozCancelFullScreen',
	      'mozFullScreenElement',
	      'mozFullScreenEnabled',
	      'mozfullscreenchange',
	      'mozfullscreenerror'
	    ],
	    // Microsoft
	    [
	      'msRequestFullscreen',
	      'msExitFullscreen',
	      'msFullscreenElement',
	      'msFullscreenEnabled',
	      'MSFullscreenChange',
	      'MSFullscreenError'
	    ]
	  ];

	  specApi = apiMap[0];

	  // determine the supported set of functions
	  for (i=0; i<apiMap.length; i++) {
	    // check for exitFullscreen function
	    if (apiMap[i][1] in document) {
	      browserApi = apiMap[i];
	      break;
	    }
	  }

	  // map the browser API names to the spec API names
	  // or leave vjs.browser.fullscreenAPI undefined
	  if (browserApi) {
	    vjs.browser.fullscreenAPI = {};

	    for (i=0; i<browserApi.length; i++) {
	      vjs.browser.fullscreenAPI[specApi[i]] = browserApi[i];
	    }
	  }

	})();

	/**
	 * An instance of the `vjs.Player` class is created when any of the Video.js setup methods are used to initialize a video.
	 *
	 * ```js
	 * var myPlayer = videojs('example_video_1');
	 * ```
	 *
	 * In the following example, the `data-setup` attribute tells the Video.js library to create a player instance when the library is ready.
	 *
	 * ```html
	 * <video id="example_video_1" data-setup='{}' controls>
	 *   <source src="my-source.mp4" type="video/mp4">
	 * </video>
	 * ```
	 *
	 * After an instance has been created it can be accessed globally using `Video('example_video_1')`.
	 *
	 * @class
	 * @extends vjs.Component
	 */
	vjs.Player = vjs.Component.extend({

	  /**
	   * player's constructor function
	   *
	   * @constructs
	   * @method init
	   * @param {Element} tag        The original video tag used for configuring options
	   * @param {Object=} options    Player options
	   * @param {Function=} ready    Ready callback function
	   */
	  init: function(tag, options, ready){
	    this.tag = tag; // Store the original tag used to set options

	    // Make sure tag ID exists
	    tag.id = tag.id || 'vjs_video_' + vjs.guid++;

	    // Store the tag attributes used to restore html5 element
	    this.tagAttributes = tag && vjs.getElementAttributes(tag);

	    // Set Options
	    // The options argument overrides options set in the video tag
	    // which overrides globally set options.
	    // This latter part coincides with the load order
	    // (tag must exist before Player)
	    options = vjs.obj.merge(this.getTagSettings(tag), options);

	    // Update Current Language
	    this.language_ = options['language'] || vjs.options['language'];

	    // Update Supported Languages
	    this.languages_ = options['languages'] || vjs.options['languages'];

	    // Cache for video property values.
	    this.cache_ = {};

	    // Set poster
	    this.poster_ = options['poster'] || '';

	    // Set controls
	    this.controls_ = !!options['controls'];
	    // Original tag settings stored in options
	    // now remove immediately so native controls don't flash.
	    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
	    tag.controls = false;

	    // we don't want the player to report touch activity on itself
	    // see enableTouchActivity in Component
	    options.reportTouchActivity = false;

	    // Set isAudio based on whether or not an audio tag was used
	    this.isAudio(this.tag.nodeName.toLowerCase() === 'audio');

	    // Run base component initializing with new options.
	    // Builds the element through createEl()
	    // Inits and embeds any child components in opts
	    vjs.Component.call(this, this, options, ready);

	    // Update controls className. Can't do this when the controls are initially
	    // set because the element doesn't exist yet.
	    if (this.controls()) {
	      this.addClass('vjs-controls-enabled');
	    } else {
	      this.addClass('vjs-controls-disabled');
	    }

	    if (this.isAudio()) {
	      this.addClass('vjs-audio');
	    }

	    this.addClass('vjs-big-play-centered');

	    // TODO: Make this smarter. Toggle user state between touching/mousing
	    // using events, since devices can have both touch and mouse events.
	    // if (vjs.TOUCH_ENABLED) {
	    //   this.addClass('vjs-touch-enabled');
	    // }

	    // Make player easily findable by ID
	    vjs.players[this.id_] = this;

	    if (options['plugins']) {
	      vjs.obj.each(options['plugins'], function(key, val){
	        this[key](val);
	      }, this);
	    }

	    //Ref: VID 601 Disabling the activity tracker for JS VPAID
	    if(!options['vpaid']){
	      this.listenForUserActivity();
	    }
	  }
	});

	/**
	 * The player's stored language code
	 *
	 * @type {String}
	 * @private
	 */
	vjs.Player.prototype.language_;

	/**
	 * The player's language code
	 * @param  {String} languageCode  The locale string
	 * @return {String}             The locale string when getting
	 * @return {vjs.Player}         self, when setting
	 */
	vjs.Player.prototype.language = function (languageCode) {
	  if (languageCode === undefined) {
	    return this.language_;
	  }

	  this.language_ = languageCode;
	  return this;
	};

	/**
	 * The player's override for Volume controls
	 * @return {Boolean}             The volume override
	 */
	vjs.Player.prototype.getMuteSettingsForIOS10 = function () {
	  //VID-2810 Override the video-js volume logic for IOS 10 and above which allow the set up of the volume
	  return vjs.IS_IOS && this.options_['enableNativeInline'] && (parseInt(vjs.IOS_VERSION) > 9);

	};

	/**
	 * The player's stored language dictionary
	 *
	 * @type {Object}
	 * @private
	 */
	vjs.Player.prototype.languages_;

	vjs.Player.prototype.languages = function(){
	  return this.languages_;
	};

	/**
	 * Player instance options, surfaced using vjs.options
	 * vjs.options = vjs.Player.prototype.options_
	 * Make changes in vjs.options, not here.
	 * All options should use string keys so they avoid
	 * renaming by closure compiler
	 * @type {Object}
	 * @private
	 */
	vjs.Player.prototype.options_ = vjs.options;

	/**
	 * Destroys the video player and does any necessary cleanup
	 *
	 *     myPlayer.dispose();
	 *
	 * This is especially helpful if you are dynamically adding and removing videos
	 * to/from the DOM.
	 */
	vjs.Player.prototype.dispose = function(){
	  this.trigger('dispose');
	  // prevent dispose from being called twice
	  this.off('dispose');

	  // Kill reference to this player
	  vjs.players[this.id_] = null;
	  if (this.tag && this.tag['player']) { this.tag['player'] = null; }
	  if (this.el_ && this.el_['player']) { this.el_['player'] = null; }

	  if (this.tech) { this.tech.dispose(); }

	  // Component dispose
	  vjs.Component.prototype.dispose.call(this);
	};

	vjs.Player.prototype.getTagSettings = function(tag){
	  var tagOptions,
	      dataSetup,
	      options = {
	        'sources': [],
	        'tracks': []
	      };

	  tagOptions = vjs.getElementAttributes(tag);
	  dataSetup = tagOptions['data-setup'];

	  // Check if data-setup attr exists.
	  if (dataSetup !== null){
	    // Parse options JSON
	    // If empty string, make it a parsable json object.
	    vjs.obj.merge(tagOptions, vjs.JSON.parse(dataSetup || '{}'));
	  }

	  vjs.obj.merge(options, tagOptions);

	  // Get tag children settings
	  if (tag.hasChildNodes()) {
	    var children, child, childName, i, j;

	    children = tag.childNodes;

	    for (i=0,j=children.length; i<j; i++) {
	      child = children[i];
	      // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
	      childName = child.nodeName.toLowerCase();
	      if (childName === 'source') {
	        options['sources'].push(vjs.getElementAttributes(child));
	      } else if (childName === 'track') {
	        options['tracks'].push(vjs.getElementAttributes(child));
	      }
	    }
	  }

	  return options;
	};

	vjs.Player.prototype.createEl = function(){
	  var
	    el = this.el_ = vjs.Component.prototype.createEl.call(this, 'div'),
	    tag = this.tag,
	    attrs;

	  // Remove width/height attrs from tag so CSS can make it 100% width/height
	  tag.removeAttribute('width');
	  tag.removeAttribute('height');

	  // Copy over all the attributes from the tag, including ID and class
	  // ID will now reference player box, not the video tag
	  attrs = vjs.getElementAttributes(tag);
	  vjs.obj.each(attrs, function(attr) {
	    // workaround so we don't totally break IE7
	    // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
	    if (attr == 'class') {
	      el.className = attrs[attr];
	    } else {
	      el.setAttribute(attr, attrs[attr]);
	    }
	  });

	  // Update tag id/class for use as HTML5 playback tech
	  // Might think we should do this after embedding in container so .vjs-tech class
	  // doesn't flash 100% width/height, but class only applies with .video-js parent
	  tag.id += '_html5_api';
	  tag.className = 'vjs-tech';

	  // Make player findable on elements
	  tag['player'] = el['player'] = this;
	  // Default state of video is paused
	  this.addClass('vjs-paused');

	  // Make box use width/height of tag, or rely on default implementation
	  // Enforce with CSS since width/height attrs don't work on divs
	  this.width(this.options_['width'], true); // (true) Skip resize listener on load
	  this.height(this.options_['height'], true);

	  // vjs.insertFirst seems to cause the networkState to flicker from 3 to 2, so
	  // keep track of the original for later so we can know if the source originally failed
	  tag.initNetworkState_ = tag.networkState;

	  // Wrap video tag in div (el/box) container
	  if (tag.parentNode) {
	    tag.parentNode.insertBefore(el, tag);
	  }
	  vjs.insertFirst(tag, el); // Breaks iPhone, fixed in HTML5 setup.

	  // The event listeners need to be added before the children are added
	  // in the component init because the tech (loaded with mediaLoader) may
	  // fire events, like loadstart, that these events need to capture.
	  // Long term it might be better to expose a way to do this in component.init
	  // like component.initEventListeners() that runs between el creation and
	  // adding children
	  this.el_ = el;
	  this.on('loadstart', this.onLoadStart);
	  this.on('waiting', this.onWaiting);
	  this.on(['canplay', 'canplaythrough', 'playing', 'ended'], this.onWaitEnd);
	  this.on('seeking', this.onSeeking);
	  this.on('seeked', this.onSeeked);
	  this.on('ended', this.onEnded);
	  this.on('play', this.onPlay);
	  this.on('firstplay', this.onFirstPlay);
	  this.on('pause', this.onPause);
	  this.on('progress', this.onProgress);
	  this.on('durationchange', this.onDurationChange);
	  this.on('fullscreenchange', this.onFullscreenChange);

	  return el;
	};

	// /* Media Technology (tech)
	// ================================================================================ */
	// Load/Create an instance of playback technology including element and API methods
	// And append playback element in player div.
	vjs.Player.prototype.loadTech = function(techName, source){

	  // Pause and remove current playback technology
	  if (this.tech) {
	    this.unloadTech();
	  }

	  // get rid of the HTML5 video tag as soon as we are using another tech
	  if (techName !== 'Html5' && this.tag) {
	    vjs.Html5.disposeMediaElement(this.tag);
	    this.tag = null;
	  }

	  this.techName = techName;

	  // Turn off API access because we're loading a new tech that might load asynchronously
	  this.isReady_ = false;

	  var techReady = function(){
	    this.player_.triggerReady();
	  };

	  // Grab tech-specific options from player options and add source and parent element to use.
	  var techOptions = vjs.obj.merge({ 'source': source, 'parentEl': this.el_ }, this.options_[techName.toLowerCase()]);

	  if (source) {
	    this.currentType_ = source.type;
	    if (source.src == this.cache_.src && this.cache_.currentTime > 0) {
	      techOptions['startTime'] = this.cache_.currentTime;
	    }

	    this.cache_.src = source.src;
	  }

	  // Initialize tech instance
	  this.tech = new window['videojs_apn'][techName](this, techOptions);

	  this.tech.ready(techReady);
	};

	vjs.Player.prototype.unloadTech = function(){
	  this.isReady_ = false;

	  this.tech.dispose();

	  this.tech = false;
	};

	// There's many issues around changing the size of a Flash (or other plugin) object.
	// First is a plugin reload issue in Firefox that has been around for 11 years: https://bugzilla.mozilla.org/show_bug.cgi?id=90268
	// Then with the new fullscreen API, Mozilla and webkit browsers will reload the flash object after going to fullscreen.
	// To get around this, we're unloading the tech, caching source and currentTime values, and reloading the tech once the plugin is resized.
	// reloadTech: function(betweenFn){
	//   vjs.log('unloadingTech')
	//   this.unloadTech();
	//   vjs.log('unloadedTech')
	//   if (betweenFn) { betweenFn.call(); }
	//   vjs.log('LoadingTech')
	//   this.loadTech(this.techName, { src: this.cache_.src })
	//   vjs.log('loadedTech')
	// },

	// /* Player event handlers (how the player reacts to certain events)
	// ================================================================================ */

	/**
	 * Fired when the user agent begins looking for media data
	 * @event loadstart
	 */
	vjs.Player.prototype.onLoadStart = function() {
	  // TODO: Update to use `emptied` event instead. See #1277.

	  this.removeClass('vjs-ended');

	  // reset the error state
	  this.error(null);

	  // If it's already playing we want to trigger a firstplay event now.
	  // The firstplay event relies on both the play and loadstart events
	  // which can happen in any order for a new source
	  if (!this.paused()) {
	    this.trigger('firstplay');
	  } else {
	    // reset the hasStarted state
	    this.hasStarted(false);
	  }
	};

	vjs.Player.prototype.hasStarted_ = false;

	vjs.Player.prototype.hasStarted = function(hasStarted){
	  if (hasStarted !== undefined) {
	    // only update if this is a new value
	    if (this.hasStarted_ !== hasStarted) {
	      this.hasStarted_ = hasStarted;
	      if (hasStarted) {
	        this.addClass('vjs-has-started');
	        // trigger the firstplay event if this newly has played
	        this.trigger('firstplay');
	      } else {
	        this.removeClass('vjs-has-started');
	      }
	    }
	    return this;
	  }
	  return this.hasStarted_;
	};

	/**
	 * Fired when the player has initial duration and dimension information
	 * @event loadedmetadata
	 */
	vjs.Player.prototype.onLoadedMetaData;

	/**
	 * Fired when the player has downloaded data at the current playback position
	 * @event loadeddata
	 */
	vjs.Player.prototype.onLoadedData;

	/**
	 * Fired when the player has finished downloading the source data
	 * @event loadedalldata
	 */
	vjs.Player.prototype.onLoadedAllData;

	/**
	 * Fired whenever the media begins or resumes playback
	 * @event play
	 */
	vjs.Player.prototype.onPlay = function(){
	  this.removeClass('vjs-ended');
	  this.removeClass('vjs-paused');
	  this.addClass('vjs-playing');

	  // hide the poster when the user hits play
	  // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play
	  this.hasStarted(true);
	};

	/**
	 * Fired whenever the media begins waiting
	 * @event waiting
	 */
	vjs.Player.prototype.onWaiting = function(){
	  this.addClass('vjs-waiting');
	};

	/**
	 * A handler for events that signal that waiting has ended
	 * which is not consistent between browsers. See #1351
	 * @private
	 */
	vjs.Player.prototype.onWaitEnd = function(){
	  this.removeClass('vjs-waiting');
	};

	/**
	 * Fired whenever the player is jumping to a new time
	 * @event seeking
	 */
	vjs.Player.prototype.onSeeking = function(){
	  this.addClass('vjs-seeking');
	};

	/**
	 * Fired when the player has finished jumping to a new time
	 * @event seeked
	 */
	vjs.Player.prototype.onSeeked = function(){
	  this.removeClass('vjs-seeking');
	};

	/**
	 * Fired the first time a video is played
	 *
	 * Not part of the HLS spec, and we're not sure if this is the best
	 * implementation yet, so use sparingly. If you don't have a reason to
	 * prevent playback, use `myPlayer.one('play');` instead.
	 *
	 * @event firstplay
	 */
	vjs.Player.prototype.onFirstPlay = function(){
	    //If the first starttime attribute is specified
	    //then we will start at the given offset in seconds
	    if(this.options_['starttime']){
	      this.currentTime(this.options_['starttime']);
	    }

	    this.addClass('vjs-has-started');
	};

	/**
	 * Fired whenever the media has been paused
	 * @event pause
	 */
	vjs.Player.prototype.onPause = function(){
	  this.removeClass('vjs-playing');
	  this.addClass('vjs-paused');
	};

	/**
	 * Fired when the current playback position has changed
	 *
	 * During playback this is fired every 15-250 milliseconds, depending on the
	 * playback technology in use.
	 * @event timeupdate
	 */
	vjs.Player.prototype.onTimeUpdate;

	/**
	 * Fired while the user agent is downloading media data
	 * @event progress
	 */
	vjs.Player.prototype.onProgress = function(){
	  // Add custom event for when source is finished downloading.
	  if (this.bufferedPercent() == 1) {
	    this.trigger('loadedalldata');
	  }
	};

	/**
	 * Fired when the end of the media resource is reached (currentTime == duration)
	 * @event ended
	 */
	vjs.Player.prototype.onEnded = function(){
	  this.addClass('vjs-ended');
	  if (this.options_['loop']) {
	    this.currentTime(0);
	    this.play();
	  } else if (!this.paused()) {
	    this.pause();
	  }
	};

	/**
	 * Fired when the duration of the media resource is first known or changed
	 * @event durationchange
	 */
	vjs.Player.prototype.onDurationChange = function(){
	  // Allows for caching value instead of asking player each time.
	  // We need to get the techGet response and check for a value so we don't
	  // accidentally cause the stack to blow up.
	  var duration = this.techGet('duration');
	  if (duration) {
	    if (duration < 0) {
	      duration = Infinity;
	    }
	    this.duration(duration);
	    // Determine if the stream is live and propagate styles down to UI.
	    if (duration === Infinity) {
	      this.addClass('vjs-live');
	    } else {
	      this.removeClass('vjs-live');
	    }
	  }
	};

	/**
	 * Fired when the volume changes
	 * @event volumechange
	 */
	vjs.Player.prototype.onVolumeChange;

	/**
	 * Fired when the player switches in or out of fullscreen mode
	 * @event fullscreenchange
	 */
	vjs.Player.prototype.onFullscreenChange = function() {
	  if (this.isFullscreen()) {
	    this.addClass('vjs-fullscreen');
	  } else {
	    this.removeClass('vjs-fullscreen');
	  }
	};

	/**
	 * Fired when an error occurs
	 * @event error
	 */
	vjs.Player.prototype.onError;

	// /* Player API
	// ================================================================================ */

	/**
	 * Object for cached values.
	 * @private
	 */
	vjs.Player.prototype.cache_;

	vjs.Player.prototype.getCache = function(){
	  return this.cache_;
	};

	// Pass values to the playback tech
	vjs.Player.prototype.techCall = function(method, arg){
	  // If it's not ready yet, call method when it is
	  if (this.tech && !this.tech.isReady_) {
	    this.tech.ready(function(){
	      this[method](arg);
	    });

	  // Otherwise call method now
	  } else {
	    try {
	      this.tech[method](arg);
	    } catch(e) {
	      vjs.log(e);
	      throw e;
	    }
	  }
	};

	// Get calls can't wait for the tech, and sometimes don't need to.
	vjs.Player.prototype.techGet = function(method){
	  if (this.tech && this.tech.isReady_) {

	    // Flash likes to die and reload when you hide or reposition it.
	    // In these cases the object methods go away and we get errors.
	    // When that happens we'll catch the errors and inform tech that it's not ready any more.
	    try {
	      return this.tech[method]();
	    } catch(e) {
	      // When building additional tech libs, an expected method may not be defined yet
	      if (this.tech[method] === undefined) {
	        vjs.log('Video.js: ' + method + ' method not defined for '+this.techName+' playback technology.', e);
	      } else {
	        // When a method isn't available on the object it throws a TypeError
	        if (e.name == 'TypeError') {
	          vjs.log('Video.js: ' + method + ' unavailable on '+this.techName+' playback technology element.', e);
	          this.tech.isReady_ = false;
	        } else {
	          vjs.log(e);
	        }
	      }
	      throw e;
	    }
	  }

	  return;
	};

	/**
	 * start media playback
	 *
	 *     myPlayer.play();
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.play = function(){
	  this.techCall('play');
	  return this;
	};

	/**
	 * Pause the video playback
	 *
	 *     myPlayer.pause();
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.pause = function(){
	  this.techCall('pause');
	  this.trigger("apn-vpaid-pause");//VID-2405, VID-2406
	  return this;
	};

	/**
	 * Check if the player is paused
	 *
	 *     var isPaused = myPlayer.paused();
	 *     var isPlaying = !myPlayer.paused();
	 *
	 * @return {Boolean} false if the media is currently playing, or true otherwise
	 */
	vjs.Player.prototype.paused = function(){
	  // The initial state of paused should be true (in Safari it's actually false)
	  return (this.techGet('paused') === false) ? false : true;
	};

	/**
	 * Get or set the current time (in seconds)
	 *
	 *     // get
	 *     var whereYouAt = myPlayer.currentTime();
	 *
	 *     // set
	 *     myPlayer.currentTime(120); // 2 minutes into the video
	 *
	 * @param  {Number|String=} seconds The time to seek to
	 * @return {Number}        The time in seconds, when not setting
	 * @return {vjs.Player}    self, when the current time is set
	 */
	vjs.Player.prototype.currentTime = function(seconds){
	  if (seconds !== undefined) {

	    this.techCall('setCurrentTime', seconds);

	    return this;
	  }

	  // cache last currentTime and return. default to 0 seconds
	  //
	  // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
	  // currentTime when scrubbing, but may not provide much performance benefit afterall.
	  // Should be tested. Also something has to read the actual current time or the cache will
	  // never get updated.
	  return this.cache_.currentTime = (this.techGet('currentTime') || 0);
	};

	/**
	 * Get the length in time of the video in seconds
	 *
	 *     var lengthOfVideo = myPlayer.duration();
	 *
	 * **NOTE**: The video must have started loading before the duration can be
	 * known, and in the case of Flash, may not be known until the video starts
	 * playing.
	 *
	 * @return {Number} The duration of the video in seconds
	 */
	vjs.Player.prototype.duration = function(seconds){
	  if (seconds !== undefined) {

	    // cache the last set value for optimized scrubbing (esp. Flash)
	    this.cache_.duration = parseFloat(seconds);

	    return this;
	  }

	  if (this.cache_.duration === undefined) {
	    this.onDurationChange();
	  }

	  return this.cache_.duration || 0;
	};

	/**
	 * Calculates how much time is left.
	 *
	 *     var timeLeft = myPlayer.remainingTime();
	 *
	 * Not a native video element function, but useful
	 * @return {Number} The time remaining in seconds
	 */
	vjs.Player.prototype.remainingTime = function(){
	  return this.duration() - this.currentTime();
	};

	// http://dev.w3.org/html5/spec/video.html#dom-media-buffered
	// Buffered returns a timerange object.
	// Kind of like an array of portions of the video that have been downloaded.

	/**
	 * Get a TimeRange object with the times of the video that have been downloaded
	 *
	 * If you just want the percent of the video that's been downloaded,
	 * use bufferedPercent.
	 *
	 *     // Number of different ranges of time have been buffered. Usually 1.
	 *     numberOfRanges = bufferedTimeRange.length,
	 *
	 *     // Time in seconds when the first range starts. Usually 0.
	 *     firstRangeStart = bufferedTimeRange.start(0),
	 *
	 *     // Time in seconds when the first range ends
	 *     firstRangeEnd = bufferedTimeRange.end(0),
	 *
	 *     // Length in seconds of the first time range
	 *     firstRangeLength = firstRangeEnd - firstRangeStart;
	 *
	 * @return {Object} A mock TimeRange object (following HTML spec)
	 */
	vjs.Player.prototype.buffered = function(){
	  var buffered = this.techGet('buffered');

	  if (!buffered || !buffered.length) {
	    buffered = vjs.createTimeRange(0,0);
	  }

	  return buffered;
	};

	/**
	 * Get the percent (as a decimal) of the video that's been downloaded
	 *
	 *     var howMuchIsDownloaded = myPlayer.bufferedPercent();
	 *
	 * 0 means none, 1 means all.
	 * (This method isn't in the HTML5 spec, but it's very convenient)
	 *
	 * @return {Number} A decimal between 0 and 1 representing the percent
	 */
	vjs.Player.prototype.bufferedPercent = function(){
	  var duration = this.duration(),
	      buffered = this.buffered(),
	      bufferedDuration = 0,
	      start, end;

	  if (!duration) {
	    return 0;
	  }

	  for (var i=0; i<buffered.length; i++){
	    start = buffered.start(i);
	    end   = buffered.end(i);

	    // buffered end can be bigger than duration by a very small fraction
	    if (end > duration) {
	      end = duration;
	    }

	    bufferedDuration += end - start;
	  }

	  return bufferedDuration / duration;
	};

	/**
	 * Get the ending time of the last buffered time range
	 *
	 * This is used in the progress bar to encapsulate all time ranges.
	 * @return {Number} The end of the last buffered time range
	 */
	vjs.Player.prototype.bufferedEnd = function(){
	  var buffered = this.buffered(),
	      duration = this.duration(),
	      end = buffered.end(buffered.length-1);

	  if (end > duration) {
	    end = duration;
	  }

	  return end;
	};

	/**
	 * Get or set the current volume of the media
	 *
	 *     // get
	 *     var howLoudIsIt = myPlayer.volume();
	 *
	 *     // set
	 *     myPlayer.volume(0.5); // Set volume to half
	 *
	 * 0 is off (muted), 1.0 is all the way up, 0.5 is half way.
	 *
	 * @param  {Number} percentAsDecimal The new volume as a decimal percent
	 * @return {Number}                  The current volume, when getting
	 * @return {vjs.Player}              self, when setting
	 */
	vjs.Player.prototype.volume = function(percentAsDecimal){
	  var vol;

	  if (percentAsDecimal !== undefined) {
	    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal))); // Force value to between 0 and 1
	    this.cache_.volume = vol;
	    this.techCall('setVolume', vol);
	    vjs.setLocalStorage('volume', vol);
	    return this;
	  }

	  // Default to 1 when returning current volume.
	  vol = parseFloat(this.techGet('volume'));
	  return (isNaN(vol)) ? 1 : vol;
	};


	/**
	 * Get the current muted state, or turn mute on or off
	 *
	 *     // get
	 *     var isVolumeMuted = myPlayer.muted();
	 *
	 *     // set
	 *     myPlayer.muted(true); // mute the volume
	 *
	 * @param  {Boolean=} muted True to mute, false to unmute
	 * @return {Boolean} True if mute is on, false if not, when getting
	 * @return {vjs.Player} self, when setting mute
	 */
	vjs.Player.prototype.muted = function(muted){
	    if (muted !== undefined) {
	        //for VID-2793 this mute doesn't need to be invoked if inline module enabled because the module has own mute/unmute features
	        var supressMutedForIOS = vjs.IS_IOS && this.options_['enableInlineVideoForIos'];
	        if (!supressMutedForIOS) {
	            this.techCall('setMuted', muted);
	        }
	        return this;
	    }
	    return this.techGet('muted') || false; // Default to false
	};


	// Check if current tech can support native fullscreen
	// (e.g. with built in controls like iOS, so not our flash swf)
	vjs.Player.prototype.supportsFullScreen = function(){
	  return this.techGet('supportsFullScreen') || false;
	};

	/**
	 * is the player in fullscreen
	 * @type {Boolean}
	 * @private
	 */
	vjs.Player.prototype.isFullscreen_ = false;

	/**
	 * Check if the player is in fullscreen mode
	 *
	 *     // get
	 *     var fullscreenOrNot = myPlayer.isFullscreen();
	 *
	 *     // set
	 *     myPlayer.isFullscreen(true); // tell the player it's in fullscreen
	 *
	 * NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
	 * property and instead document.fullscreenElement is used. But isFullscreen is
	 * still a valuable property for internal player workings.
	 *
	 * @param  {Boolean=} isFS Update the player's fullscreen state
	 * @return {Boolean} true if fullscreen, false if not
	 * @return {vjs.Player} self, when setting
	 */
	vjs.Player.prototype.isFullscreen = function(isFS){
	  if (isFS !== undefined) {
	    this.isFullscreen_ = !!isFS;
	    return this;
	  }
	  return this.isFullscreen_;
	};

	/**
	 * Old naming for isFullscreen()
	 * @deprecated for lowercase 's' version
	 */
	vjs.Player.prototype.isFullScreen = function(isFS){
	  vjs.log.warn('player.isFullScreen() has been deprecated, use player.isFullscreen() with a lowercase "s")');
	  return this.isFullscreen(isFS);
	};

	/**
	 * Increase the size of the video to full screen
	 *
	 *     myPlayer.requestFullscreen();
	 *
	 * In some browsers, full screen is not supported natively, so it enters
	 * "full window mode", where the video fills the browser window.
	 * In browsers and devices that support native full screen, sometimes the
	 * browser's default controls will be shown, and not the Video.js custom skin.
	 * This includes most mobile devices (iOS, Android) and older versions of
	 * Safari.
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.requestFullscreen = function(){
	  var fsApi = vjs.browser.fullscreenAPI;

	  this.isFullscreen(true);

	  if (fsApi) {
	    // the browser supports going fullscreen at the element level so we can
	    // take the controls fullscreen as well as the video

	    // Trigger fullscreenchange event after change
	    // We have to specifically add this each time, and remove
	    // when canceling fullscreen. Otherwise if there's multiple
	    // players on a page, they would all be reacting to the same fullscreen
	    // events
	    vjs.on(document, fsApi['fullscreenchange'], vjs.bind(this, function(e){
	      this.isFullscreen(document[fsApi.fullscreenElement]);

	      // If cancelling fullscreen, remove event listener.
	      if (this.isFullscreen() === false) {
	        vjs.off(document, fsApi['fullscreenchange'], arguments.callee);
	      }

	      this.trigger('fullscreenchange');
	    }));

	    this.el_[fsApi.requestFullscreen]();

	  } else if (this.tech.supportsFullScreen()) {
	    // we can't take the video.js controls fullscreen but we can go fullscreen
	    // with native controls
	    this.techCall('enterFullScreen');
	  } else {
	    // fullscreen isn't supported so we'll just stretch the video element to
	    // fill the viewport
	    this.enterFullWindow();
	    this.trigger('fullscreenchange');
	  }

	  return this;
	};

	/**
	 * Old naming for requestFullscreen
	 * @deprecated for lower case 's' version
	 */
	vjs.Player.prototype.requestFullScreen = function(){
	  vjs.log.warn('player.requestFullScreen() has been deprecated, use player.requestFullscreen() with a lowercase "s")');
	  return this.requestFullscreen();
	};


	/**
	 * Return the video to its normal size after having been in full screen mode
	 *
	 *     myPlayer.exitFullscreen();
	 *
	 * @return {vjs.Player} self
	 */
	vjs.Player.prototype.exitFullscreen = function(){
	  var fsApi = vjs.browser.fullscreenAPI;
	  this.isFullscreen(false);

	  // Check for browser element fullscreen support
	  if (fsApi) {
	    document[fsApi.exitFullscreen]();
	  } else if (this.tech.supportsFullScreen()) {
	   this.techCall('exitFullScreen');
	  } else {
	   this.exitFullWindow();
	   this.trigger('fullscreenchange');
	  }

	  return this;
	};

	/**
	 * Old naming for exitFullscreen
	 * @deprecated for exitFullscreen
	 */
	vjs.Player.prototype.cancelFullScreen = function(){
	  vjs.log.warn('player.cancelFullScreen() has been deprecated, use player.exitFullscreen()');
	  return this.exitFullscreen();
	};

	// When fullscreen isn't supported we can stretch the video container to as wide as the browser will let us.
	vjs.Player.prototype.enterFullWindow = function(){
	  this.isFullWindow = true;

	  // Storing original doc overflow value to return to when fullscreen is off
	  this.docOrigOverflow = document.documentElement.style.overflow;

	  // Add listener for esc key to exit fullscreen
	  vjs.on(document, 'keydown', vjs.bind(this, this.fullWindowOnEscKey));

	  // Hide any scroll bars
	  document.documentElement.style.overflow = 'hidden';

	  // Apply fullscreen styles
	  vjs.addClass(document.body, 'vjs-full-window');

	  this.trigger('enterFullWindow');
	};
	vjs.Player.prototype.fullWindowOnEscKey = function(event){
	  if (event.keyCode === 27) {
	    if (this.isFullscreen() === true) {
	      this.exitFullscreen();
	    } else {
	      this.exitFullWindow();
	    }
	  }
	};

	vjs.Player.prototype.exitFullWindow = function(){
	  this.isFullWindow = false;
	  vjs.off(document, 'keydown', this.fullWindowOnEscKey);

	  // Unhide scroll bars.
	  document.documentElement.style.overflow = this.docOrigOverflow;

	  // Remove fullscreen styles
	  vjs.removeClass(document.body, 'vjs-full-window');

	  // Resize the box, controller, and poster to original sizes
	  // this.positionAll();
	  this.trigger('exitFullWindow');
	};

	vjs.Player.prototype.selectSource = function(sources){
	  // Loop through each playback technology in the options order
	  for (var i=0,j=this.options_['techOrder'];i<j.length;i++) {
	    var techName = vjs.capitalize(j[i]),
	        tech = window['videojs_apn'][techName];

	    // Check if the current tech is defined before continuing
	    if (!tech) {
	      vjs.log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
	      continue;
	    }

	    // Check if the browser supports this technology
	    if (tech.isSupported()) {
	      // Loop through each source object
	      for (var a=0,b=sources;a<b.length;a++) {
	        var source = b[a];

	        // Check if source can be played with this technology
	        if (tech['canPlaySource'](source)) {
	          return { source: source, tech: techName };
	        }
	      }
	    }
	  }

	  return false;
	};

	/**
	 * The source function updates the video source
	 *
	 * There are three types of variables you can pass as the argument.
	 *
	 * **URL String**: A URL to the the video file. Use this method if you are sure
	 * the current playback technology (HTML5/Flash) can support the source you
	 * provide. Currently only MP4 files can be used in both HTML5 and Flash.
	 *
	 *     myPlayer.src("http://www.example.com/path/to/video.mp4");
	 *
	 * **Source Object (or element):** A javascript object containing information
	 * about the source file. Use this method if you want the player to determine if
	 * it can support the file using the type information.
	 *
	 *     myPlayer.src({ type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" });
	 *
	 * **Array of Source Objects:** To provide multiple versions of the source so
	 * that it can be played using HTML5 across browsers you can use an array of
	 * source objects. Video.js will detect which version is supported and load that
	 * file.
	 *
	 *     myPlayer.src([
	 *       { type: "video/mp4", src: "http://www.example.com/path/to/video.mp4" },
	 *       { type: "video/webm", src: "http://www.example.com/path/to/video.webm" },
	 *       { type: "video/ogg", src: "http://www.example.com/path/to/video.ogv" }
	 *     ]);
	 *
	 * @param  {String|Object|Array=} source The source URL, object, or array of sources
	 * @return {String} The current video source when getting
	 * @return {String} The player when setting
	 */
	vjs.Player.prototype.src = function(source){
	  if (source === undefined) {
	    return this.techGet('src');
	  }

	  // case: Array of source objects to choose from and pick the best to play
	  if (vjs.obj.isArray(source)) {
	    this.sourceList_(source);

	  // case: URL String (http://myvideo...)
	  } else if (typeof source === 'string') {
	    // create a source object from the string
	    this.src({ src: source });

	  // case: Source object { src: '', type: '' ... }
	  } else if (source instanceof Object) {
	    // check if the source has a type and the loaded tech cannot play the source
	    // if there's no type we'll just try the current tech
	    if (source.type && !window['videojs_apn'][this.techName]['canPlaySource'](source)) {
	      // create a source list with the current source and send through
	      // the tech loop to check for a compatible technology
	      this.sourceList_([source]);
	    } else {
	      this.cache_.src = source.src;
	      this.currentType_ = source.type || '';

	      // wait until the tech is ready to set the source
	      this.ready(function(){

	        // The setSource tech method was added with source handlers
	        // so older techs won't support it
	        // We need to check the direct prototype for the case where subclasses
	        // of the tech do not support source handlers
	        if (window['videojs_apn'][this.techName].prototype.hasOwnProperty('setSource')) {
	          this.techCall('setSource', source);
	        } else {
	          this.techCall('src', source.src);
	        }

	        if (this.options_['preload'] == 'auto') {
	          this.load();
	        }

	        if (this.options_['autoplay']) {
	          this.play();
	        }
	      });
	    }
	  }

	  return this;
	};

	/**
	 * Handle an array of source objects
	 * @param  {[type]} sources Array of source objects
	 * @private
	 */
	vjs.Player.prototype.sourceList_ = function(sources){
	  var sourceTech = this.selectSource(sources);

	  if (sourceTech) {
	    if (sourceTech.tech === this.techName) {
	      // if this technology is already loaded, set the source
	      this.src(sourceTech.source);
	    } else {
	      // load this technology with the chosen source
	      this.loadTech(sourceTech.tech, sourceTech.source);
	    }
	  } else {
	    // We need to wrap this in a timeout to give folks a chance to add error event handlers
	    this.setTimeout( function() {
	      this.error({ code: 4, message: this.localize(this.options()['notSupportedMessage']) });
	    }, 0);

	    // we could not find an appropriate tech, but let's still notify the delegate that this is it
	    // this needs a better comment about why this is needed
	    this.triggerReady();
	  }
	};

	/**
	 * Begin loading the src data.
	 * @return {vjs.Player} Returns the player
	 */
	vjs.Player.prototype.load = function(){
	  this.techCall('load');
	  return this;
	};

	/**
	 * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
	 * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
	 * @return {String} The current source
	 */
	vjs.Player.prototype.currentSrc = function(){
	  return this.techGet('currentSrc') || this.cache_.src || '';
	};

	/**
	 * Get the current source type e.g. video/mp4
	 * This can allow you rebuild the current source object so that you could load the same
	 * source and tech later
	 * @return {String} The source MIME type
	 */
	vjs.Player.prototype.currentType = function(){
	    return this.currentType_ || '';
	};

	/**
	 * Get or set the preload attribute.
	 * @return {String} The preload attribute value when getting
	 * @return {vjs.Player} Returns the player when setting
	 */
	vjs.Player.prototype.preload = function(value){
	  if (value !== undefined) {
	    this.techCall('setPreload', value);
	    this.options_['preload'] = value;
	    return this;
	  }
	  return this.techGet('preload');
	};

	/**
	 * Get or set the autoplay attribute.
	 * @return {String} The autoplay attribute value when getting
	 * @return {vjs.Player} Returns the player when setting
	 */
	vjs.Player.prototype.autoplay = function(value){
	  if (value !== undefined) {
	    this.techCall('setAutoplay', value);
	    this.options_['autoplay'] = value;
	    return this;
	  }
	  return this.techGet('autoplay', value);
	};

	/**
	 * Get or set the loop attribute on the video element.
	 * @return {String} The loop attribute value when getting
	 * @return {vjs.Player} Returns the player when setting
	 */
	vjs.Player.prototype.loop = function(value){
	  if (value !== undefined) {
	    this.techCall('setLoop', value);
	    this.options_['loop'] = value;
	    return this;
	  }
	  return this.techGet('loop');
	};

	/**
	 * the url of the poster image source
	 * @type {String}
	 * @private
	 */
	vjs.Player.prototype.poster_;

	/**
	 * get or set the poster image source url
	 *
	 * ##### EXAMPLE:
	 *
	 *     // getting
	 *     var currentPoster = myPlayer.poster();
	 *
	 *     // setting
	 *     myPlayer.poster('http://example.com/myImage.jpg');
	 *
	 * @param  {String=} [src] Poster image source URL
	 * @return {String} poster URL when getting
	 * @return {vjs.Player} self when setting
	 */
	vjs.Player.prototype.poster = function(src){
	  if (src === undefined) {
	    return this.poster_;
	  }

	  // The correct way to remove a poster is to set as an empty string
	  // other falsey values will throw errors
	  if (!src) {
	    src = '';
	  }

	  // update the internal poster variable
	  this.poster_ = src;

	  // update the tech's poster
	  this.techCall('setPoster', src);

	  // alert components that the poster has been set
	  this.trigger('posterchange');

	  return this;
	};

	/**
	 * Whether or not the controls are showing
	 * @type {Boolean}
	 * @private
	 */
	vjs.Player.prototype.controls_;

	/**
	 * Get or set whether or not the controls are showing.
	 * @param  {Boolean} controls Set controls to showing or not
	 * @return {Boolean}    Controls are showing
	 */
	vjs.Player.prototype.controls = function(bool){
	  if (bool !== undefined) {
	    bool = !!bool; // force boolean
	    // Don't trigger a change event unless it actually changed
	    if (this.controls_ !== bool) {
	      this.controls_ = bool;
	      if (bool) {
	        this.removeClass('vjs-controls-disabled');
	        this.addClass('vjs-controls-enabled');
	        this.trigger('controlsenabled');
	      } else {
	        this.removeClass('vjs-controls-enabled');
	        this.addClass('vjs-controls-disabled');
	        this.trigger('controlsdisabled');
	      }
	    }
	    return this;
	  }
	  return this.controls_;
	};

	vjs.Player.prototype.usingNativeControls_;

	/**
	 * Toggle native controls on/off. Native controls are the controls built into
	 * devices (e.g. default iPhone controls), Flash, or other techs
	 * (e.g. Vimeo Controls)
	 *
	 * **This should only be set by the current tech, because only the tech knows
	 * if it can support native controls**
	 *
	 * @param  {Boolean} bool    True signals that native controls are on
	 * @return {vjs.Player}      Returns the player
	 * @private
	 */
	vjs.Player.prototype.usingNativeControls = function(bool){
	  if (bool !== undefined) {
	    bool = !!bool; // force boolean
	    // Don't trigger a change event unless it actually changed
	    if (this.usingNativeControls_ !== bool) {
	      this.usingNativeControls_ = bool;
	      if (bool) {
	        this.addClass('vjs-using-native-controls');

	        /**
	         * player is using the native device controls
	         *
	         * @event usingnativecontrols
	         * @memberof vjs.Player
	         * @instance
	         * @private
	         */
	        this.trigger('usingnativecontrols');
	      } else {
	        this.removeClass('vjs-using-native-controls');

	        /**
	         * player is using the custom HTML controls
	         *
	         * @event usingcustomcontrols
	         * @memberof vjs.Player
	         * @instance
	         * @private
	         */
	        this.trigger('usingcustomcontrols');
	      }
	    }
	    return this;
	  }
	  return this.usingNativeControls_;
	};

	/**
	 * Store the current media error
	 * @type {Object}
	 * @private
	 */
	vjs.Player.prototype.error_ = null;

	/**
	 * Set or get the current MediaError
	 * @param  {*} err A MediaError or a String/Number to be turned into a MediaError
	 * @return {vjs.MediaError|null}     when getting
	 * @return {vjs.Player}              when setting
	 */
	vjs.Player.prototype.error = function(err){
	  if (err === undefined) {
	    return this.error_;
	  }

	  // restoring to default
	  if (err === null) {
	    this.error_ = err;
	    this.removeClass('vjs-error');
	    return this;
	  }

	  // error instance
	  if (err instanceof vjs.MediaError) {
	    this.error_ = err;
	  } else {
	    this.error_ = new vjs.MediaError(err);
	  }

	  // fire an error event on the player
	  this.trigger('error');

	  // add the vjs-error classname to the player
	  this.addClass('vjs-error');

	  // log the name of the error type and any message
	  // ie8 just logs "[object object]" if you just log the error object
	  vjs.log.error('(CODE:'+this.error_.code+' '+vjs.MediaError.errorTypes[this.error_.code]+')', this.error_.message, this.error_);

	  return this;
	};

	/**
	 * Returns whether or not the player is in the "ended" state.
	 * @return {Boolean} True if the player is in the ended state, false if not.
	 */
	vjs.Player.prototype.ended = function(){ return this.techGet('ended'); };

	/**
	 * Returns whether or not the player is in the "seeking" state.
	 * @return {Boolean} True if the player is in the seeking state, false if not.
	 */
	vjs.Player.prototype.seeking = function(){ return this.techGet('seeking'); };

	/**
	 * Returns the TimeRanges of the media that are currently available
	 * for seeking to.
	 * @return {TimeRanges} the seekable intervals of the media timeline
	 */
	vjs.Player.prototype.seekable = function(){ return this.techGet('seekable'); };

	// When the player is first initialized, trigger activity so components
	// like the control bar show themselves if needed
	vjs.Player.prototype.userActivity_ = true;
	vjs.Player.prototype.reportUserActivity = function(event){
	  this.userActivity_ = true;
	};

	vjs.Player.prototype.userActive_ = true;
	vjs.Player.prototype.userActive = function(bool){
	  if (bool !== undefined) {
	    bool = !!bool;
	    if (bool !== this.userActive_) {
	      this.userActive_ = bool;
	      if (bool) {
	        // If the user was inactive and is now active we want to reset the
	        // inactivity timer
	        this.userActivity_ = true;
	        this.removeClass('vjs-user-inactive');
	        this.addClass('vjs-user-active');
	        this.trigger('useractive');
	      } else {
	        // We're switching the state to inactive manually, so erase any other
	        // activity
	        this.userActivity_ = false;

	        // Chrome/Safari/IE have bugs where when you change the cursor it can
	        // trigger a mousemove event. This causes an issue when you're hiding
	        // the cursor when the user is inactive, and a mousemove signals user
	        // activity. Making it impossible to go into inactive mode. Specifically
	        // this happens in fullscreen when we really need to hide the cursor.
	        //
	        // When this gets resolved in ALL browsers it can be removed
	        // https://code.google.com/p/chromium/issues/detail?id=103041
	        if(this.tech) {
	          this.tech.one('mousemove', function(e){
	            e.stopPropagation();
	            e.preventDefault();
	          });
	        }

	        this.removeClass('vjs-user-active');
	        this.addClass('vjs-user-inactive');
	        this.trigger('userinactive');
	      }
	    }
	    return this;
	  }
	  return this.userActive_;
	};

	vjs.Player.prototype.listenForUserActivity = function(){
	  var onActivity, onMouseMove, onMouseDown, mouseInProgress, onMouseUp,
	      activityCheck, inactivityTimeout, lastMoveX, lastMoveY;

	  onActivity = vjs.bind(this, this.reportUserActivity);

	  onMouseMove = function(e) {
	    // #1068 - Prevent mousemove spamming
	    // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
	    if(e.screenX != lastMoveX || e.screenY != lastMoveY) {
	      lastMoveX = e.screenX;
	      lastMoveY = e.screenY;
	      onActivity();
	    }
	  };

	  onMouseDown = function() {
	    onActivity();
	    // For as long as the they are touching the device or have their mouse down,
	    // we consider them active even if they're not moving their finger or mouse.
	    // So we want to continue to update that they are active
	    this.clearInterval(mouseInProgress);
	    // Setting userActivity=true now and setting the interval to the same time
	    // as the activityCheck interval (250) should ensure we never miss the
	    // next activityCheck
	    mouseInProgress = this.setInterval(onActivity, 250);
	  };

	  onMouseUp = function(event) {
	    onActivity();
	    // Stop the interval that maintains activity if the mouse/touch is down
	    this.clearInterval(mouseInProgress);
	  };

	  // Any mouse movement will be considered user activity
	  this.on('mousedown', onMouseDown);
	  this.on('mousemove', onMouseMove);
	  this.on('mouseup', onMouseUp);

	  // Listen for keyboard navigation
	  // Shouldn't need to use inProgress interval because of key repeat
	  this.on('keydown', onActivity);
	  this.on('keyup', onActivity);

	  // Run an interval every 250 milliseconds instead of stuffing everything into
	  // the mousemove/touchmove function itself, to prevent performance degradation.
	  // `this.reportUserActivity` simply sets this.userActivity_ to true, which
	  // then gets picked up by this loop
	  // http://ejohn.org/blog/learning-from-twitter/
	  activityCheck = this.setInterval(function() {
	    // Check to see if mouse/touch activity has happened
	    if (this.userActivity_) {
	      // Reset the activity tracker
	      this.userActivity_ = false;

	      // If the user state was inactive, set the state to active
	      this.userActive(true);

	      // Clear any existing inactivity timeout to start the timer over
	      this.clearTimeout(inactivityTimeout);

	      var timeout = this.options()['inactivityTimeout'];
	      if (timeout > 0) {
	          // In <timeout> milliseconds, if no more activity has occurred the
	          // user will be considered inactive
	          inactivityTimeout = this.setTimeout(function () {
	              // Protect against the case where the inactivityTimeout can trigger just
	              // before the next user activity is picked up by the activityCheck loop
	              // causing a flicker
	              if (!this.userActivity_) {
	                  this.userActive(false);
	              }
	          }, timeout);
	      }
	    }
	  }, 250);
	};

	/**
	 * Gets or sets the current playback rate.
	 * @param  {Boolean} rate   New playback rate to set.
	 * @return {Number}         Returns the new playback rate when setting
	 * @return {Number}         Returns the current playback rate when getting
	 */
	vjs.Player.prototype.playbackRate = function(rate) {
	  if (rate !== undefined) {
	    this.techCall('setPlaybackRate', rate);
	    return this;
	  }

	  if (this.tech && this.tech['featuresPlaybackRate']) {
	    return this.techGet('playbackRate');
	  } else {
	    return 1.0;
	  }

	};

	/**
	 * Store the current audio state
	 * @type {Boolean}
	 * @private
	 */
	vjs.Player.prototype.isAudio_ = false;

	/**
	 * Gets or sets the audio flag
	 *
	 * @param  {Boolean} bool    True signals that this is an audio player.
	 * @return {Boolean}         Returns true if player is audio, false if not when getting
	 * @return {vjs.Player}      Returns the player if setting
	 * @private
	 */
	vjs.Player.prototype.isAudio = function(bool) {
	  if (bool !== undefined) {
	    this.isAudio_ = !!bool;
	    return this;
	  }

	  return this.isAudio_;
	};

	/**
	 * Returns the current state of network activity for the element, from
	 * the codes in the list below.
	 * - NETWORK_EMPTY (numeric value 0)
	 *   The element has not yet been initialised. All attributes are in
	 *   their initial states.
	 * - NETWORK_IDLE (numeric value 1)
	 *   The element's resource selection algorithm is active and has
	 *   selected a resource, but it is not actually using the network at
	 *   this time.
	 * - NETWORK_LOADING (numeric value 2)
	 *   The user agent is actively trying to download data.
	 * - NETWORK_NO_SOURCE (numeric value 3)
	 *   The element's resource selection algorithm is active, but it has
	 *   not yet found a resource to use.
	 * @return {Number} the current network activity state
	 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
	 */
	vjs.Player.prototype.networkState = function(){
	  return this.techGet('networkState');
	};

	/**
	 * Returns a value that expresses the current state of the element
	 * with respect to rendering the current playback position, from the
	 * codes in the list below.
	 * - HAVE_NOTHING (numeric value 0)
	 *   No information regarding the media resource is available.
	 * - HAVE_METADATA (numeric value 1)
	 *   Enough of the resource has been obtained that the duration of the
	 *   resource is available.
	 * - HAVE_CURRENT_DATA (numeric value 2)
	 *   Data for the immediate current playback position is available.
	 * - HAVE_FUTURE_DATA (numeric value 3)
	 *   Data for the immediate current playback position is available, as
	 *   well as enough data for the user agent to advance the current
	 *   playback position in the direction of playback.
	 * - HAVE_ENOUGH_DATA (numeric value 4)
	 *   The user agent estimates that enough data is available for
	 *   playback to proceed uninterrupted.
	 * @return {Number} the current playback rendering state
	 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
	 */
	vjs.Player.prototype.readyState = function(){
	  return this.techGet('readyState');
	};

	/**
	 * Text tracks are tracks of timed text events.
	 * Captions - text displayed over the video for the hearing impaired
	 * Subtitles - text displayed over the video for those who don't understand language in the video
	 * Chapters - text displayed in a menu allowing the user to jump to particular points (chapters) in the video
	 * Descriptions (not supported yet) - audio descriptions that are read back to the user by a screen reading device
	 */

	/**
	 * Get an array of associated text tracks. captions, subtitles, chapters, descriptions
	 * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
	 * @return {Array}           Array of track objects
	 */
	vjs.Player.prototype.textTracks = function(){
	  // cannot use techGet directly because it checks to see whether the tech is ready.
	  // Flash is unlikely to be ready in time but textTracks should still work.
	  return this.tech && this.tech['textTracks']();
	};

	vjs.Player.prototype.remoteTextTracks = function() {
	  return this.tech && this.tech['remoteTextTracks']();
	};

	/**
	 * Add a text track
	 * In addition to the W3C settings we allow adding additional info through options.
	 * http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
	 * @param {String}  kind        Captions, subtitles, chapters, descriptions, or metadata
	 * @param {String=} label       Optional label
	 * @param {String=} language    Optional language
	 */
	vjs.Player.prototype.addTextTrack = function(kind, label, language) {
	  return this.tech && this.tech['addTextTrack'](kind, label, language);
	};

	vjs.Player.prototype.addRemoteTextTrack = function(options) {
	  return this.tech && this.tech['addRemoteTextTrack'](options);
	};

	vjs.Player.prototype.removeRemoteTextTrack = function(track) {
	  this.tech && this.tech['removeRemoteTextTrack'](track);
	};

	// Methods to add support for
	// initialTime: function(){ return this.techCall('initialTime'); },
	// startOffsetTime: function(){ return this.techCall('startOffsetTime'); },
	// played: function(){ return this.techCall('played'); },
	// seekable: function(){ return this.techCall('seekable'); },
	// videoTracks: function(){ return this.techCall('videoTracks'); },
	// audioTracks: function(){ return this.techCall('audioTracks'); },
	// videoWidth: function(){ return this.techCall('videoWidth'); },
	// videoHeight: function(){ return this.techCall('videoHeight'); },
	// defaultPlaybackRate: function(){ return this.techCall('defaultPlaybackRate'); },
	// mediaGroup: function(){ return this.techCall('mediaGroup'); },
	// controller: function(){ return this.techCall('controller'); },
	// defaultMuted: function(){ return this.techCall('defaultMuted'); }

	// TODO
	// currentSrcList: the array of sources including other formats and bitrates
	// playList: array of source lists in order of playback

	/**
	 * Container of main controls
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 * @extends vjs.Component
	 */
	vjs.ControlBar = vjs.Component.extend();

	vjs.ControlBar.prototype.options_ = {
	    loadEvent: 'play',
	    children: {
	        'playToggle': {},
	        'currentTimeDisplay': {},
	        'timeDivider': {},
	        'durationDisplay': {},
	        'remainingTimeDisplay': {},
	        // 'liveDisplay': {},
	        'progressControl': {},
	        'fullscreenToggle': {},
	        'volumeControl': {},
	        'muteToggle': {},
	        // 'volumeMenuButton': {},
	        'playbackRateMenuButton': {}
	        // 'subtitlesButton': {},
	        // 'captionsButton': {},
	        // 'chaptersButton': {}
	    }
	};

	vjs.ControlBar.prototype.createEl = function(){
	  return vjs.createEl('div', {
	    className: 'vjs-control-bar'
	  });
	};

	/**
	 * Displays the live indicator
	 * TODO - Future make it click to snap to live
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.LiveDisplay = vjs.Component.extend({
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.LiveDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-live-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-live-display',
	    innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE'),
	    'aria-live': 'off'
	  });

	  el.appendChild(this.contentEl_);

	  return el;
	};

	/**
	 * Button to toggle between play and pause
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.PlayToggle = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.on(player, 'play', this.onPlay);
	    this.on(player, 'pause', this.onPause);
	  }
	});

	vjs.PlayToggle.prototype.buttonText = 'Play';

	vjs.PlayToggle.prototype.buildCSSClass = function(){
	  return 'vjs-play-control ' + vjs.Button.prototype.buildCSSClass.call(this);
	};

	// OnClick - Toggle between play and pause
	vjs.PlayToggle.prototype.onClick = function(){
	  if (this.player_.paused()) {
	    this.player_.play();
	  } else {
	    this.player_.pause();
	  }
	};

	  // OnPlay - Add the vjs-playing class to the element so it can change appearance
	vjs.PlayToggle.prototype.onPlay = function(){
	  this.removeClass('vjs-paused');
	  this.addClass('vjs-playing');
	  this.el_.children[0].children[0].innerHTML = this.localize('Pause'); // change the button text to "Pause"
	};

	  // OnPause - Add the vjs-paused class to the element so it can change appearance
	vjs.PlayToggle.prototype.onPause = function(){
	  this.removeClass('vjs-playing');
	  this.addClass('vjs-paused');
	  this.el_.children[0].children[0].innerHTML = this.localize('Play'); // change the button text to "Play"
	};

	/**
	 * Displays the current time
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.CurrentTimeDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.on(player, 'timeupdate', this.updateContent);
	  }
	});

	vjs.CurrentTimeDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-current-time vjs-time-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-current-time-display',
	    innerHTML: '<span class="vjs-control-text">Current Time </span>' + '0:00', // label the current time for screen reader users
	    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
	  });

	  el.appendChild(this.contentEl_);
	  return el;
	};

	vjs.CurrentTimeDisplay.prototype.updateContent = function(){
	  // Allows for smooth scrubbing, when player can't keep up.
	  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	  this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Current Time') + '</span> ' + vjs.formatTime(time, this.player_.duration());
	};

	/**
	 * Displays the duration
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.DurationDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // this might need to be changed to 'durationchange' instead of 'timeupdate' eventually,
	    // however the durationchange event fires before this.player_.duration() is set,
	    // so the value cannot be written out using this method.
	    // Once the order of durationchange and this.player_.duration() being set is figured out,
	    // this can be updated.
	    this.on(player, 'timeupdate', this.updateContent);
	    this.on(player, 'loadedmetadata', this.updateContent);
	  }
	});

	vjs.DurationDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-duration vjs-time-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-duration-display',
	    innerHTML: '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + '0:00', // label the duration time for screen reader users
	    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
	  });

	  el.appendChild(this.contentEl_);
	  return el;
	};

	vjs.DurationDisplay.prototype.updateContent = function(){
	  var duration = this.player_.duration();
	  if (duration) {
	      this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Duration Time') + '</span> ' + vjs.formatTime(duration); // label the duration time for screen reader users
	  }
	};

	/**
	 * The separator between the current time and duration
	 *
	 * Can be hidden if it's not needed in the design.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.TimeDivider = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.TimeDivider.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-time-divider',
	    innerHTML: '<div><span>/</span></div>'
	  });
	};

	/**
	 * Displays the time left in the video
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.RemainingTimeDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.on(player, 'timeupdate', this.updateContent);
	  }
	});

	vjs.RemainingTimeDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-remaining-time vjs-time-controls vjs-control'
	  });

	  this.contentEl_ = vjs.createEl('div', {
	    className: 'vjs-remaining-time-display',
	    innerHTML: '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-0:00', // label the remaining time for screen reader users
	    'aria-live': 'off' // tell screen readers not to automatically read the time as it changes
	  });

	  el.appendChild(this.contentEl_);
	  return el;
	};

	vjs.RemainingTimeDisplay.prototype.updateContent = function(){
	  if (this.player_.duration()) {
	    this.contentEl_.innerHTML = '<span class="vjs-control-text">' + this.localize('Remaining Time') + '</span> ' + '-'+ vjs.formatTime(this.player_.remainingTime());
	  }

	  // Allows for smooth scrubbing, when player can't keep up.
	  // var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	  // this.contentEl_.innerHTML = vjs.formatTime(time, this.player_.duration());
	};

	/**
	 * Toggle fullscreen video
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @extends vjs.Button
	 */
	vjs.FullscreenToggle = vjs.Button.extend({
	  /**
	   * @constructor
	   * @memberof vjs.FullscreenToggle
	   * @instance
	   */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);
	  }
	});

	vjs.FullscreenToggle.prototype.buttonText = 'Fullscreen';

	vjs.FullscreenToggle.prototype.buildCSSClass = function(){
	  return 'vjs-fullscreen-control ' + vjs.Button.prototype.buildCSSClass.call(this);
	};

	vjs.FullscreenToggle.prototype.onClick = function(){
	  if (!this.player_.isFullscreen()) {
	    this.player_.requestFullscreen();
	    this.controlText_.innerHTML = this.localize('Non-Fullscreen');
	  } else {
	    this.player_.exitFullscreen();
	    this.controlText_.innerHTML = this.localize('Fullscreen');
	  }
	};

	/**
	 * The Progress Control component contains the seek bar, load progress,
	 * and play progress
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.ProgressControl = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.ProgressControl.prototype.options_ = {
	  children: {
	    'seekBar': {}
	  }
	};

	vjs.ProgressControl.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-progress-control vjs-control'
	  });
	};

	/**
	 * Seek Bar and holder for the progress bars
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.SeekBar = vjs.Slider.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Slider.call(this, player, options);
	    this.on(player, 'timeupdate', this.updateARIAAttributes);
	    player.ready(vjs.bind(this, this.updateARIAAttributes));
	  }
	});

	vjs.SeekBar.prototype.options_ = {
	  children: {
	    'loadProgressBar': {},
	    'playProgressBar': {},
	    'seekHandle': {}
	  },
	  'barName': 'playProgressBar',
	  'handleName': 'seekHandle'
	};

	vjs.SeekBar.prototype.playerEvent = 'timeupdate';

	vjs.SeekBar.prototype.createEl = function(){
	  return vjs.Slider.prototype.createEl.call(this, 'div', {
	    className: 'vjs-progress-holder',
	    'aria-label': 'video progress bar'
	  });
	};

	vjs.SeekBar.prototype.updateARIAAttributes = function(){
	    // Allows for smooth scrubbing, when player can't keep up.
	    var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	    this.el_.setAttribute('aria-valuenow',vjs.round(this.getPercent()*100, 2)); // machine readable value of progress bar (percentage complete)
	    this.el_.setAttribute('aria-valuetext',vjs.formatTime(time, this.player_.duration())); // human readable value of progress bar (time complete)
	};

	vjs.SeekBar.prototype.getPercent = function(){
	  return this.player_.currentTime() / this.player_.duration();
	};




	//remove all Seek Bar interactivity VID-2782
	/*
	///----- start seek bar interactivity section -----
	vjs.SeekBar.prototype.onMouseDown = function(event){
	  vjs.Slider.prototype.onMouseDown.call(this, event);

	  this.player_.scrubbing = true;
	  this.player_.addClass('vjs-scrubbing');

	  this.videoWasPlaying = !this.player_.paused();
	  this.player_.pause();
	};

	vjs.SeekBar.prototype.onMouseMove = function(event){
	  var newTime = this.calculateDistance(event) * this.player_.duration();

	  // Don't let video end while scrubbing.
	  if (newTime == this.player_.duration()) { newTime = newTime - 0.1; }

	  // Set new time (tell player to seek to new time)
	  this.player_.currentTime(newTime);
	};

	vjs.SeekBar.prototype.onMouseUp = function(event){
	  vjs.Slider.prototype.onMouseUp.call(this, event);

	  this.player_.scrubbing = false;
	  this.player_.removeClass('vjs-scrubbing');
	  if (this.videoWasPlaying) {
	    this.player_.play();
	  }
	};

	vjs.SeekBar.prototype.stepForward = function(){
	  this.player_.currentTime(this.player_.currentTime() + 5); // more quickly fast forward for keyboard-only users
	};

	vjs.SeekBar.prototype.stepBack = function(){
	  this.player_.currentTime(this.player_.currentTime() - 5); // more quickly rewind for keyboard-only users

	};
	///----- end seek bar interactivity section -----
	*/




	/**
	 * Shows load progress
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.LoadProgressBar = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	    this.on(player, 'progress', this.update);
	  }
	});

	vjs.LoadProgressBar.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-load-progress',
	    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
	  });
	};

	vjs.LoadProgressBar.prototype.update = function(){
	  var i, start, end, part,
	      buffered = this.player_.buffered(),
	      duration = this.player_.duration(),
	      bufferedEnd = this.player_.bufferedEnd(),
	      children = this.el_.children,
	      // get the percent width of a time compared to the total end
	      percentify = function (time, end){
	        var percent = (time / end) || 0; // no NaN
	        return (percent * 100) + '%';
	      };

	  // update the width of the progress bar
	  this.el_.style.width = percentify(bufferedEnd, duration);

	  // add child elements to represent the individual buffered time ranges
	  for (i = 0; i < buffered.length; i++) {
	    start = buffered.start(i),
	    end = buffered.end(i),
	    part = children[i];

	    if (!part) {
	      part = this.el_.appendChild(vjs.createEl());
	    }

	    // set the percent based on the width of the progress bar (bufferedEnd)
	    part.style.left = percentify(start, bufferedEnd);
	    part.style.width = percentify(end - start, bufferedEnd);
	  }

	  // remove unused buffered range elements
	  for (i = children.length; i > buffered.length; i--) {
	    this.el_.removeChild(children[i-1]);
	  }
	};

	/**
	 * Shows play progress
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.PlayProgressBar = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.PlayProgressBar.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-play-progress',
	    innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
	  });
	};

	/**
	 * The Seek Handle shows the current position of the playhead during playback,
	 * and can be dragged to adjust the playhead.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.SeekHandle = vjs.SliderHandle.extend({
	  init: function(player, options) {
	    vjs.SliderHandle.call(this, player, options);
	    this.on(player, 'timeupdate', this.updateContent);
	  }
	});

	/**
	 * The default value for the handle content, which may be read by screen readers
	 *
	 * @type {String}
	 * @private
	 */
	vjs.SeekHandle.prototype.defaultValue = '00:00';

	/** @inheritDoc */
	vjs.SeekHandle.prototype.createEl = function() {
	  return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
	    className: 'vjs-seek-handle',
	    'aria-live': 'off'
	  });
	};

	vjs.SeekHandle.prototype.updateContent = function() {
	  var time = (this.player_.scrubbing) ? this.player_.getCache().currentTime : this.player_.currentTime();
	  this.el_.innerHTML = '<span class="vjs-control-text">' + vjs.formatTime(time, this.player_.duration()) + '</span>';
	};

	/**
	 * The component for controlling the volume level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.VolumeControl = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // hide volume controls when they're not supported by the current tech
	    if (player.tech && player.tech['featuresVolumeControl'] === false) {
	      this.addClass('vjs-hidden');
	    }
	    this.on(player, 'loadstart', function(){
	      if (player.tech['featuresVolumeControl'] === false) {
	        this.addClass('vjs-hidden');
	      } else {
	        this.removeClass('vjs-hidden');
	      }
	    });
	  }
	});

	vjs.VolumeControl.prototype.options_ = {
	  children: {
	    'volumeBar': {}
	  }
	};

	vjs.VolumeControl.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-control vjs-control'
	  });
	};

	/**
	 * The bar that contains the volume level and can be clicked on to adjust the level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.VolumeBar = vjs.Slider.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Slider.call(this, player, options);
	    this.on(player, 'volumechange', this.updateARIAAttributes);
	    player.ready(vjs.bind(this, this.updateARIAAttributes));
	  }
	});

	vjs.VolumeBar.prototype.updateARIAAttributes = function(){
	  // Current value of volume bar as a percentage
	  this.el_.setAttribute('aria-valuenow',vjs.round(this.player_.volume()*100, 2));
	  this.el_.setAttribute('aria-valuetext',vjs.round(this.player_.volume()*100, 2)+'%');
	};

	vjs.VolumeBar.prototype.options_ = {
	  children: {
	    'volumeLevel': {},
	    'volumeHandle': {}
	  },
	  'barName': 'volumeLevel',
	  'handleName': 'volumeHandle'
	};

	vjs.VolumeBar.prototype.playerEvent = 'volumechange';

	vjs.VolumeBar.prototype.createEl = function(){
	  return vjs.Slider.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-bar',
	    'aria-label': 'volume level'
	  });
	};

	vjs.VolumeBar.prototype.onMouseMove = function(event) {
	  if (this.player_.muted()) {
	    //this.player_.muted(false);
	  }

	    //console.log("================ id : " + global_options.iframeVideoWrapperId);
	    //TODO minthe added to fix VID-209
	    var targetDocument = document.getElementById(global_options.iframeVideoWrapperId).contentWindow.document;
	    var targetElement = targetDocument.elementFromPoint(event.clientX, event.clientY);
	    if (targetElement && targetElement.tagName!="VIDEO" && targetElement.className.indexOf("vjs") >= 0) {
	        this.player_.volume(this.calculateDistance(event));
	    }

	};

	vjs.VolumeBar.prototype.getPercent = function(){
	  if (this.player_.muted()) {
	    return 0;
	  } else {
	    return this.player_.volume();
	  }
	};

	vjs.VolumeBar.prototype.stepForward = function(){
	  this.player_.volume(this.player_.volume() + 0.1);
	};

	vjs.VolumeBar.prototype.stepBack = function(){
	  this.player_.volume(this.player_.volume() - 0.1);
	};

	/**
	 * Shows volume level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.VolumeLevel = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);
	  }
	});

	vjs.VolumeLevel.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-level',
	    innerHTML: '<span class="vjs-control-text"></span>'
	  });
	};

	/**
	 * The volume handle can be dragged to adjust the volume level
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	 vjs.VolumeHandle = vjs.SliderHandle.extend();

	 vjs.VolumeHandle.prototype.defaultValue = '00:00';

	 /** @inheritDoc */
	 vjs.VolumeHandle.prototype.createEl = function(){
	   return vjs.SliderHandle.prototype.createEl.call(this, 'div', {
	     className: 'vjs-volume-handle'
	   });
	 };

	/**
	 * A button component for muting the audio
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.MuteToggle = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.on(player, 'volumechange', this.update);
	    var showMuteForIOS10 = player.getMuteSettingsForIOS10();
	    // hide mute toggle if the current tech doesn't support volume control
	    if (player.tech && player.tech['featuresVolumeControl'] === false && !showMuteForIOS10) {
	      this.addClass('vjs-hidden');
	    }

	    this.on(player, 'loadstart', function(){
	      if (player.tech['featuresVolumeControl'] === false && !showMuteForIOS10) {
	        this.addClass('vjs-hidden');
	      } else {
	        this.removeClass('vjs-hidden');
	      }
	    });
	  }
	});

	vjs.MuteToggle.prototype.createEl = function(){
	  return vjs.Button.prototype.createEl.call(this, 'div', {
	    className: 'vjs-mute-control vjs-control',
	    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
	  });
	};

	vjs.MuteToggle.prototype.onClick = function(){
	  this.player_.muted( this.player_.muted() ? false : true );
	};

	vjs.MuteToggle.prototype.update = function(){
	  var vol = this.player_.volume(),
	      level = 3;

	  if (vol === 0 || this.player_.muted()) {
	    level = 0;
	  } else if (vol < 0.33) {
	    level = 1;
	  } else if (vol < 0.67) {
	    level = 2;
	  }

	  // Don't rewrite the button text if the actual text doesn't change.
	  // This causes unnecessary and confusing information for screen reader users.
	  // This check is needed because this function gets called every time the volume level is changed.
	  if(this.player_.muted()){
	      if(this.el_.children[0].children[0].innerHTML!=this.localize('Unmute')){
	          this.el_.children[0].children[0].innerHTML = this.localize('Unmute'); // change the button text to "Unmute"
	      }
	  } else {
	      if(this.el_.children[0].children[0].innerHTML!=this.localize('Mute')){
	          this.el_.children[0].children[0].innerHTML = this.localize('Mute'); // change the button text to "Mute"
	      }
	  }

	  /* TODO improve muted icon classes */
	  for (var i = 0; i < 4; i++) {
	    vjs.removeClass(this.el_, 'vjs-vol-'+i);
	  }
	  vjs.addClass(this.el_, 'vjs-vol-'+level);
	};

	/**
	 * Menu button with a popup for showing the volume slider.
	 * @constructor
	 */
	vjs.VolumeMenuButton = vjs.MenuButton.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.MenuButton.call(this, player, options);

	    // Same listeners as MuteToggle
	    this.on(player, 'volumechange', this.volumeUpdate);

	    // hide mute toggle if the current tech doesn't support volume control
	    if (player.tech && player.tech['featuresVolumeControl'] === false) {
	      this.addClass('vjs-hidden');
	    }

	    this.on(player, 'loadstart', function(){
	      if (player.tech['featuresVolumeControl'] === false) {
	        this.addClass('vjs-hidden');
	      } else {
	        this.removeClass('vjs-hidden');
	      }
	    });
	    this.addClass('vjs-menu-button');
	  }
	});

	vjs.VolumeMenuButton.prototype.createMenu = function(){
	  var menu = new vjs.Menu(this.player_, {
	    contentElType: 'div'
	  });
	  var vc = new vjs.VolumeBar(this.player_, this.options_['volumeBar']);
	  vc.on('focus', function() {
	    menu.lockShowing();
	  });
	  vc.on('blur', function() {
	    menu.unlockShowing();
	  });
	  menu.addChild(vc);
	  return menu;
	};

	vjs.VolumeMenuButton.prototype.onClick = function(){
	  vjs.MuteToggle.prototype.onClick.call(this);
	  vjs.MenuButton.prototype.onClick.call(this);
	};

	vjs.VolumeMenuButton.prototype.createEl = function(){
	  return vjs.Button.prototype.createEl.call(this, 'div', {
	    className: 'vjs-volume-menu-button vjs-menu-button vjs-control',
	    innerHTML: '<div><span class="vjs-control-text">' + this.localize('Mute') + '</span></div>'
	  });
	};
	vjs.VolumeMenuButton.prototype.volumeUpdate = vjs.MuteToggle.prototype.update;

	/**
	 * The component for controlling the playback rate
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.PlaybackRateMenuButton = vjs.MenuButton.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.MenuButton.call(this, player, options);

	    this.updateVisibility();
	    this.updateLabel();

	    this.on(player, 'loadstart', this.updateVisibility);
	    this.on(player, 'ratechange', this.updateLabel);
	  }
	});

	vjs.PlaybackRateMenuButton.prototype.buttonText = 'Playback Rate';
	vjs.PlaybackRateMenuButton.prototype.className = 'vjs-playback-rate';

	vjs.PlaybackRateMenuButton.prototype.createEl = function(){
	  var el = vjs.MenuButton.prototype.createEl.call(this);

	  this.labelEl_ = vjs.createEl('div', {
	    className: 'vjs-playback-rate-value',
	    innerHTML: 1.0
	  });

	  el.appendChild(this.labelEl_);

	  return el;
	};

	// Menu creation
	vjs.PlaybackRateMenuButton.prototype.createMenu = function(){
	  var menu = new vjs.Menu(this.player());
	  var rates = this.player().options()['playbackRates'];

	  if (rates) {
	    for (var i = rates.length - 1; i >= 0; i--) {
	      menu.addChild(
	        new vjs.PlaybackRateMenuItem(this.player(), { 'rate': rates[i] + 'x'})
	        );
	    }
	  }

	  return menu;
	};

	vjs.PlaybackRateMenuButton.prototype.updateARIAAttributes = function(){
	  // Current playback rate
	  this.el().setAttribute('aria-valuenow', this.player().playbackRate());
	};

	vjs.PlaybackRateMenuButton.prototype.onClick = function(){
	  // select next rate option
	  var currentRate = this.player().playbackRate();
	  var rates = this.player().options()['playbackRates'];
	  // this will select first one if the last one currently selected
	  var newRate = rates[0];
	  for (var i = 0; i <rates.length ; i++) {
	    if (rates[i] > currentRate) {
	      newRate = rates[i];
	      break;
	    }
	  }
	  this.player().playbackRate(newRate);
	};

	vjs.PlaybackRateMenuButton.prototype.playbackRateSupported = function(){
	  return this.player().tech
	    && this.player().tech['featuresPlaybackRate']
	    && this.player().options()['playbackRates']
	    && this.player().options()['playbackRates'].length > 0
	  ;
	};

	/**
	 * Hide playback rate controls when they're no playback rate options to select
	 */
	vjs.PlaybackRateMenuButton.prototype.updateVisibility = function(){
	  if (this.playbackRateSupported()) {
	    this.removeClass('vjs-hidden');
	  } else {
	    this.addClass('vjs-hidden');
	  }
	};

	/**
	 * Update button label when rate changed
	 */
	vjs.PlaybackRateMenuButton.prototype.updateLabel = function(){
	  if (this.playbackRateSupported()) {
	    this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
	  }
	};

	/**
	 * The specific menu item type for selecting a playback rate
	 *
	 * @constructor
	 */
	vjs.PlaybackRateMenuItem = vjs.MenuItem.extend({
	  contentElType: 'button',
	  /** @constructor */
	  init: function(player, options){
	    var label = this.label = options['rate'];
	    var rate = this.rate = parseFloat(label, 10);

	    // Modify options for parent MenuItem class's init.
	    options['label'] = label;
	    options['selected'] = rate === 1;
	    vjs.MenuItem.call(this, player, options);

	    this.on(player, 'ratechange', this.update);
	  }
	});

	vjs.PlaybackRateMenuItem.prototype.onClick = function(){
	  vjs.MenuItem.prototype.onClick.call(this);
	  this.player().playbackRate(this.rate);
	};

	vjs.PlaybackRateMenuItem.prototype.update = function(){
	  this.selected(this.player().playbackRate() == this.rate);
	};

	/* Poster Image
	================================================================================ */
	/**
	 * The component that handles showing the poster image.
	 *
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.PosterImage = vjs.Button.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Button.call(this, player, options);

	    this.update();
	    player.on('posterchange', vjs.bind(this, this.update));
	  }
	});

	/**
	 * Clean up the poster image
	 */
	vjs.PosterImage.prototype.dispose = function(){
	  this.player().off('posterchange', this.update);
	  vjs.Button.prototype.dispose.call(this);
	};

	/**
	 * Create the poster image element
	 * @return {Element}
	 */
	vjs.PosterImage.prototype.createEl = function(){
	  var el = vjs.createEl('div', {
	    className: 'vjs-poster',

	    // Don't want poster to be tabbable.
	    tabIndex: -1
	  });

	  // To ensure the poster image resizes while maintaining its original aspect
	  // ratio, use a div with `background-size` when available. For browsers that
	  // do not support `background-size` (e.g. IE8), fall back on using a regular
	  // img element.
	  if (!vjs.BACKGROUND_SIZE_SUPPORTED) {
	    this.fallbackImg_ = vjs.createEl('img');
	    el.appendChild(this.fallbackImg_);
	  }

	  return el;
	};

	/**
	 * Event handler for updates to the player's poster source
	 */
	vjs.PosterImage.prototype.update = function(){
	  var url = this.player().poster();

	  this.setSrc(url);

	  // If there's no poster source we should display:none on this component
	  // so it's not still clickable or right-clickable
	  if (url) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};

	/**
	 * Set the poster source depending on the display method
	 */
	vjs.PosterImage.prototype.setSrc = function(url){
	  var backgroundImage;

	  if (this.fallbackImg_) {
	    this.fallbackImg_.src = url;
	  } else {
	    backgroundImage = '';
	    // Any falsey values should stay as an empty string, otherwise
	    // this will throw an extra error
	    if (url) {
	      backgroundImage = 'url("' + url + '")';
	    }

	    this.el_.style.backgroundImage = backgroundImage;
	  }
	};

	/**
	 * Event handler for clicks on the poster image
	 */
	vjs.PosterImage.prototype.onClick = function(){
	  // We don't want a click to trigger playback when controls are disabled
	  // but CSS should be hiding the poster to prevent that from happening
	  this.player_.play();
	};

	/* Loading Spinner
	================================================================================ */
	/**
	 * Loading spinner for waiting events
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.LoadingSpinner = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    // MOVING DISPLAY HANDLING TO CSS

	    // player.on('canplay', vjs.bind(this, this.hide));
	    // player.on('canplaythrough', vjs.bind(this, this.hide));
	    // player.on('playing', vjs.bind(this, this.hide));
	    // player.on('seeking', vjs.bind(this, this.show));

	    // in some browsers seeking does not trigger the 'playing' event,
	    // so we also need to trap 'seeked' if we are going to set a
	    // 'seeking' event
	    // player.on('seeked', vjs.bind(this, this.hide));

	    // player.on('ended', vjs.bind(this, this.hide));

	    // Not showing spinner on stalled any more. Browsers may stall and then not trigger any events that would remove the spinner.
	    // Checked in Chrome 16 and Safari 5.1.2. http://help.videojs.com/discussions/problems/883-why-is-the-download-progress-showing
	    // player.on('stalled', vjs.bind(this, this.show));

	    // player.on('waiting', vjs.bind(this, this.show));
	  }
	});

	vjs.LoadingSpinner.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-loading-spinner'
	  });
	};

	/* Big Play Button
	================================================================================ */
	/**
	 * Initial play button. Shows before the video has played. The hiding of the
	 * big play button is done via CSS and player states.
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @class
	 * @constructor
	 */
	vjs.BigPlayButton = vjs.Button.extend();

	vjs.BigPlayButton.prototype.createEl = function(){
	  return vjs.Button.prototype.createEl.call(this, 'div', {
	    className: 'vjs-big-play-button',
	    innerHTML: '<span aria-hidden="true"></span>',
	    'aria-label': 'play video'
	  });
	};

	vjs.BigPlayButton.prototype.onClick = function(){
	  this.player_.play();
	};

	/**
	 * Display that an error has occurred making the video unplayable
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @constructor
	 */
	vjs.ErrorDisplay = vjs.Component.extend({
	  init: function(player, options){
	    vjs.Component.call(this, player, options);

	    this.update();
	    this.on(player, 'error', this.update);
	  }
	});

	vjs.ErrorDisplay.prototype.createEl = function(){
	  var el = vjs.Component.prototype.createEl.call(this, 'div', {
	  });//VID-1444

	  this.contentEl_ = vjs.createEl('div');
	  el.appendChild(this.contentEl_);

	  return el;
	};

	vjs.ErrorDisplay.prototype.update = function(){
	  if (this.player().error()) {
	    this.contentEl_.innerHTML = this.localize(this.player().error().message);
	  }
	};

	(function() {
	  var createTrackHelper;
	/**
	 * @fileoverview Media Technology Controller - Base class for media playback
	 * technology controllers like Flash and HTML5
	 */

	/**
	 * Base class for media (HTML5 Video, Flash) controllers
	 * @param {vjs.Player|Object} player  Central player instance
	 * @param {Object=} options Options object
	 * @constructor
	 */
	vjs.MediaTechController = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    options = options || {};
	    // we don't want the tech to report user activity automatically.
	    // This is done manually in addControlsListeners
	    options.reportTouchActivity = false;
	    vjs.Component.call(this, player, options, ready);

	    // Manually track progress in cases where the browser/flash player doesn't report it.
	    if (!this['featuresProgressEvents']) {
	      this.manualProgressOn();
	    }

	    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
	    if (!this['featuresTimeupdateEvents']) {
	      this.manualTimeUpdatesOn();
	    }

	    this.initControlsListeners();

	    //if (!this['featuresNativeTextTracks']) {
	    //  this.emulateTextTracks();
	    //}

	    this.initTextTrackListeners();
	  }
	});

	/**
	 * Set up click and touch listeners for the playback element
	 * On desktops, a click on the video itself will toggle playback,
	 * on a mobile device a click on the video toggles controls.
	 * (toggling controls is done by toggling the user state between active and
	 * inactive)
	 *
	 * A tap can signal that a user has become active, or has become inactive
	 * e.g. a quick tap on an iPhone movie should reveal the controls. Another
	 * quick tap should hide them again (signaling the user is in an inactive
	 * viewing state)
	 *
	 * In addition to this, we still want the user to be considered inactive after
	 * a few seconds of inactivity.
	 *
	 * Note: the only part of iOS interaction we can't mimic with this setup
	 * is a touch and hold on the video element counting as activity in order to
	 * keep the controls showing, but that shouldn't be an issue. A touch and hold on
	 * any controls will still keep the user active
	 */
	vjs.MediaTechController.prototype.initControlsListeners = function(){
	  var player, activateControls;

	  player = this.player();

	  activateControls = function(){
	    if (player.controls() && !player.usingNativeControls()) {
	      this.addControlsListeners();
	    }
	  };

	  // Set up event listeners once the tech is ready and has an element to apply
	  // listeners to
	  this.ready(activateControls);
	  this.on(player, 'controlsenabled', activateControls);
	  this.on(player, 'controlsdisabled', this.removeControlsListeners);

	  // if we're loading the playback object after it has started loading or playing the
	  // video (often with autoplay on) then the loadstart event has already fired and we
	  // need to fire it manually because many things rely on it.
	  // Long term we might consider how we would do this for other events like 'canplay'
	  // that may also have fired.
	  this.ready(function(){
	    if (this.networkState && this.networkState() > 0) {
	      this.player().trigger('loadstart');
	    }
	  });
	};

	vjs.MediaTechController.prototype.addControlsListeners = function(){
	  var userWasActive;

	  // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
	  // trigger mousedown/up.
	  // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
	  // Any touch events are set to block the mousedown event from happening
	  this.on('mousedown', this.onClick);

	  // If the controls were hidden we don't want that to change without a tap event
	  // so we'll check if the controls were already showing before reporting user
	  // activity
	  this.on('touchstart', function(event) {
	    userWasActive = this.player_.userActive();
	  });

	  this.on('touchmove', function(event) {
	    if (userWasActive){
	      this.player().reportUserActivity();
	    }
	  });

	  this.on('touchend', function(event) {
	    // Stop the mouse events from also happening
	    event.preventDefault();
	  });

	  // Turn on component tap events
	  this.emitTapEvents();

	  // The tap listener needs to come after the touchend listener because the tap
	  // listener cancels out any reportedUserActivity when setting userActive(false)
	  this.on('tap', this.onTap);
	};

	/**
	 * Remove the listeners used for click and tap controls. This is needed for
	 * toggling to controls disabled, where a tap/touch should do nothing.
	 */
	vjs.MediaTechController.prototype.removeControlsListeners = function(){
	  // We don't want to just use `this.off()` because there might be other needed
	  // listeners added by techs that extend this.
	  this.off('tap');
	  this.off('touchstart');
	  this.off('touchmove');
	  this.off('touchleave');
	  this.off('touchcancel');
	  this.off('touchend');
	  this.off('click');
	  this.off('mousedown');
	};

	/**
	 * Handle a click on the media element. By default will play/pause the media.
	 */
	vjs.MediaTechController.prototype.onClick = function(event){
	  // We're using mousedown to detect clicks thanks to Flash, but mousedown
	  // will also be triggered with right-clicks, so we need to prevent that
	  if (event.button !== 0) return;

	  // When controls are disabled a click should not toggle playback because
	  // the click is considered a control
	  if (this.player().controls()) {
	    if (this.player().paused()) {
	      this.player().play();
	    } else {
	      this.player().pause();
	    }
	  }
	};

	/**
	 * Handle a tap on the media element. By default it will toggle the user
	 * activity state, which hides and shows the controls.
	 */
	vjs.MediaTechController.prototype.onTap = function(){
	  this.player().userActive(!this.player().userActive());
	};

	/* Fallbacks for unsupported event types
	================================================================================ */
	// Manually trigger progress events based on changes to the buffered amount
	// Many flash players and older HTML5 browsers don't send progress or progress-like events
	vjs.MediaTechController.prototype.manualProgressOn = function(){
	  this.manualProgress = true;

	  // Trigger progress watching when a source begins loading
	  this.trackProgress();
	};

	vjs.MediaTechController.prototype.manualProgressOff = function(){
	  this.manualProgress = false;
	  this.stopTrackingProgress();
	};

	vjs.MediaTechController.prototype.trackProgress = function(){
	  this.progressInterval = this.setInterval(function(){
	    // Don't trigger unless buffered amount is greater than last time

	    var bufferedPercent = this.player().bufferedPercent();

	    if (this.bufferedPercent_ != bufferedPercent) {
	      this.player().trigger('progress');
	    }

	    this.bufferedPercent_ = bufferedPercent;

	    if (bufferedPercent === 1) {
	      this.stopTrackingProgress();
	    }
	  }, 500);
	};
	vjs.MediaTechController.prototype.stopTrackingProgress = function(){ this.clearInterval(this.progressInterval); };

	/*! Time Tracking -------------------------------------------------------------- */
	vjs.MediaTechController.prototype.manualTimeUpdatesOn = function(){
	  var player = this.player_;

	  this.manualTimeUpdates = true;

	  this.on(player, 'play', this.trackCurrentTime);
	  this.on(player, 'pause', this.stopTrackingCurrentTime);
	  // timeupdate is also called by .currentTime whenever current time is set

	  // Watch for native timeupdate event
	  this.one('timeupdate', function(){
	    // Update known progress support for this playback technology
	    this['featuresTimeupdateEvents'] = true;
	    // Turn off manual progress tracking
	    this.manualTimeUpdatesOff();
	  });
	};

	vjs.MediaTechController.prototype.manualTimeUpdatesOff = function(){
	  var player = this.player_;

	  this.manualTimeUpdates = false;
	  this.stopTrackingCurrentTime();
	  this.off(player, 'play', this.trackCurrentTime);
	  this.off(player, 'pause', this.stopTrackingCurrentTime);
	};

	vjs.MediaTechController.prototype.trackCurrentTime = function(){
	  if (this.currentTimeInterval) { this.stopTrackingCurrentTime(); }
	  this.currentTimeInterval = this.setInterval(function(){
	    this.player().trigger('timeupdate');
	  }, 250); // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
	};

	// Turn off play progress tracking (when paused or dragging)
	vjs.MediaTechController.prototype.stopTrackingCurrentTime = function(){
	  this.clearInterval(this.currentTimeInterval);

	  // #1002 - if the video ends right before the next timeupdate would happen,
	  // the progress bar won't make it all the way to the end
	  this.player().trigger('timeupdate');
	};

	vjs.MediaTechController.prototype.dispose = function() {
	  // Turn off any manual progress or timeupdate tracking
	  if (this.manualProgress) { this.manualProgressOff(); }

	  if (this.manualTimeUpdates) { this.manualTimeUpdatesOff(); }

	  vjs.Component.prototype.dispose.call(this);
	};

	vjs.MediaTechController.prototype.setCurrentTime = function() {
	  // improve the accuracy of manual timeupdates
	  if (this.manualTimeUpdates) { this.player().trigger('timeupdate'); }
	};

	// TODO: Consider looking at moving this into the text track display directly
	// https://github.com/videojs/video.js/issues/1863
	vjs.MediaTechController.prototype.initTextTrackListeners = function() {
	  var player = this.player_,
	      tracks,
	      textTrackListChanges = function() {
	        var textTrackDisplay = player.getChild('textTrackDisplay'),
	            controlBar;

	        if (textTrackDisplay) {
	          textTrackDisplay.updateDisplay();
	        }
	      };

	  tracks = this.textTracks();

	  if (!tracks) {
	    return;
	  }

	  tracks.addEventListener('removetrack', textTrackListChanges);
	  tracks.addEventListener('addtrack', textTrackListChanges);

	  this.on('dispose', vjs.bind(this, function() {
	    tracks.removeEventListener('removetrack', textTrackListChanges);
	    tracks.removeEventListener('addtrack', textTrackListChanges);
	  }));
	};

	vjs.MediaTechController.prototype.emulateTextTracks = function() {
	  var player = this.player_,
	      textTracksChanges,
	      tracks,
	      script;

	  if (!window['WebVTT']) {
	    //script = document.createElement('script');
	    //script.src = player.options()['vtt.js'] || '../node_modules/vtt.js/dist/vtt.js';
	    //player.el().appendChild(script);
	    //window['WebVTT'] = true;
	  }

	  tracks = this.textTracks();
	  if (!tracks) {
	    return;
	  }

	  textTracksChanges = function() {
	    var i, track, textTrackDisplay;

	    textTrackDisplay = player.getChild('textTrackDisplay'),

	    textTrackDisplay.updateDisplay();

	    for (i = 0; i < this.length; i++) {
	      track = this[i];
	      track.removeEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
	      if (track.mode === 'showing') {
	        track.addEventListener('cuechange', vjs.bind(textTrackDisplay, textTrackDisplay.updateDisplay));
	      }
	    }
	  };

	  tracks.addEventListener('change', textTracksChanges);

	  this.on('dispose', vjs.bind(this, function() {
	    tracks.removeEventListener('change', textTracksChanges);
	  }));
	};

	/**
	 * Provide default methods for text tracks.
	 *
	 * Html5 tech overrides these.
	 */

	/**
	 * List of associated text tracks
	 * @type {Array}
	 * @private
	 */
	vjs.MediaTechController.prototype.textTracks_;

	vjs.MediaTechController.prototype.textTracks = function() {
	  this.player_.textTracks_ = this.player_.textTracks_ || new vjs.TextTrackList();
	  return this.player_.textTracks_;
	};

	vjs.MediaTechController.prototype.remoteTextTracks = function() {
	  this.player_.remoteTextTracks_ = this.player_.remoteTextTracks_ || new vjs.TextTrackList();
	  return this.player_.remoteTextTracks_;
	};

	createTrackHelper = function(self, kind, label, language, options) {
	  var tracks = self.textTracks(),
	      track;

	  options = options || {};

	  options['kind'] = kind;
	  if (label) {
	    options['label'] = label;
	  }
	  if (language) {
	    options['language'] = language;
	  }
	  options['player'] = self.player_;

	  track = new vjs.TextTrack(options);
	  tracks.addTrack_(track);

	  return track;
	};

	vjs.MediaTechController.prototype.addTextTrack = function(kind, label, language) {
	  if (!kind) {
	    throw new Error('TextTrack kind is required but was not provided');
	  }

	  return createTrackHelper(this, kind, label, language);
	};

	vjs.MediaTechController.prototype.addRemoteTextTrack = function(options) {
	  var track = createTrackHelper(this, options['kind'], options['label'], options['language'], options);
	  this.remoteTextTracks().addTrack_(track);
	  return {
	    track: track
	  };
	};

	vjs.MediaTechController.prototype.removeRemoteTextTrack = function(track) {
	  this.textTracks().removeTrack_(track);
	  this.remoteTextTracks().removeTrack_(track);
	};

	/**
	 * Provide a default setPoster method for techs
	 *
	 * Poster support for techs should be optional, so we don't want techs to
	 * break if they don't have a way to set a poster.
	 */
	vjs.MediaTechController.prototype.setPoster = function(){};

	vjs.MediaTechController.prototype['featuresVolumeControl'] = true;

	// Resizing plugins using request fullscreen reloads the plugin
	vjs.MediaTechController.prototype['featuresFullscreenResize'] = false;
	vjs.MediaTechController.prototype['featuresPlaybackRate'] = false;

	// Optional events that we can manually mimic with timers
	// currently not triggered by video-js-swf
	vjs.MediaTechController.prototype['featuresProgressEvents'] = false;
	vjs.MediaTechController.prototype['featuresTimeupdateEvents'] = false;

	vjs.MediaTechController.prototype['featuresNativeTextTracks'] = false;

	/**
	 * A functional mixin for techs that want to use the Source Handler pattern.
	 *
	 * ##### EXAMPLE:
	 *
	 *   videojs.MediaTechController.withSourceHandlers.call(MyTech);
	 *
	 */
	vjs.MediaTechController.withSourceHandlers = function(Tech){
	  /**
	   * Register a source handler
	   * Source handlers are scripts for handling specific formats.
	   * The source handler pattern is used for adaptive formats (HLS, DASH) that
	   * manually load video data and feed it into a Source Buffer (Media Source Extensions)
	   * @param  {Function} handler  The source handler
	   * @param  {Boolean}  first    Register it before any existing handlers
	   */
	  Tech.registerSourceHandler = function(handler, index){
	    var handlers = Tech.sourceHandlers;

	    if (!handlers) {
	      handlers = Tech.sourceHandlers = [];
	    }

	    if (index === undefined) {
	      // add to the end of the list
	      index = handlers.length;
	    }

	    handlers.splice(index, 0, handler);
	  };

	  /**
	   * Return the first source handler that supports the source
	   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
	   * @param  {Object} source The source object
	   * @returns {Object}       The first source handler that supports the source
	   * @returns {null}         Null if no source handler is found
	   */
	  Tech.selectSourceHandler = function(source){
	    var handlers = Tech.sourceHandlers || [],
	        can;

	    for (var i = 0; i < handlers.length; i++) {
	      can = handlers[i].canHandleSource(source);

	      if (can) {
	        return handlers[i];
	      }
	    }

	    return null;
	  };

	  /**
	  * Check if the tech can support the given source
	  * @param  {Object} srcObj  The source object
	  * @return {String}         'probably', 'maybe', or '' (empty string)
	  */
	  Tech.canPlaySource = function(srcObj){
	    var sh = Tech.selectSourceHandler(srcObj);

	    if (sh) {
	      return sh.canHandleSource(srcObj);
	    }

	    return '';
	  };

	  /**
	   * Create a function for setting the source using a source object
	   * and source handlers.
	   * Should never be called unless a source handler was found.
	   * @param {Object} source  A source object with src and type keys
	   * @return {vjs.MediaTechController} self
	   */
	  Tech.prototype.setSource = function(source){
	    var sh = Tech.selectSourceHandler(source);

	    if (!sh) {
	      // Fall back to a native source hander when unsupported sources are
	      // deliberately set
	      if (Tech.nativeSourceHandler) {
	        sh = Tech.nativeSourceHandler;
	      } else {
	        vjs.log.error('No source hander found for the current source.');
	      }
	    }

	    // Dispose any existing source handler
	    this.disposeSourceHandler();
	    this.off('dispose', this.disposeSourceHandler);

	    this.currentSource_ = source;
	    this.sourceHandler_ = sh.handleSource(source, this);
	    this.on('dispose', this.disposeSourceHandler);

	    return this;
	  };

	  /**
	   * Clean up any existing source handler
	   */
	  Tech.prototype.disposeSourceHandler = function(){
	    if (this.sourceHandler_ && this.sourceHandler_.dispose) {
	      this.sourceHandler_.dispose();
	    }
	  };

	};

	vjs.media = {};

	})();

	/**
	 * @fileoverview HTML5 Media Controller - Wrapper for HTML5 Media API
	 */

	/**
	 * HTML5 Media Controller - Wrapper for HTML5 Media API
	 * @param {vjs.Player|Object} player
	 * @param {Object=} options
	 * @param {Function=} ready
	 * @constructor
	 */
	vjs.Html5 = vjs.MediaTechController.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    var  nodes, nodesLength, i, node, nodeName, removeNodes;

	    if (options['nativeCaptions'] === false || options['nativeTextTracks'] === false) {
	      this['featuresNativeTextTracks'] = false;
	    }

	    vjs.MediaTechController.call(this, player, options, ready);

	    this.setupTriggers();

	    var source = options['source'];

	    // Set the source if one is provided
	    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
	    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
	    // anyway so the error gets fired.
	    if (source && (this.el_.currentSrc !== source.src || (player.tag && player.tag.initNetworkState_ === 3))) {
	      this.setSource(source);
	    }

	    if (this.el_.hasChildNodes()) {

	      nodes = this.el_.childNodes;
	      nodesLength = nodes.length;
	      removeNodes = [];

	      while (nodesLength--) {
	        node = nodes[nodesLength];
	        nodeName = node.nodeName.toLowerCase();
	        if (nodeName === 'track') {
	          if (!this['featuresNativeTextTracks']) {
	            // Empty video tag tracks so the built-in player doesn't use them also.
	            // This may not be fast enough to stop HTML5 browsers from reading the tags
	            // so we'll need to turn off any default tracks if we're manually doing
	            // captions and subtitles. videoElement.textTracks
	            removeNodes.push(node);
	          } else {
	            this.remoteTextTracks().addTrack_(node['track']);
	          }
	        }
	      }

	      for (i=0; i<removeNodes.length; i++) {
	        this.el_.removeChild(removeNodes[i]);
	      }
	    }

	    if (this['featuresNativeTextTracks']) {
	      this.on('loadstart', vjs.bind(this, this.hideCaptions));
	    }

	    // Determine if native controls should be used
	    // Our goal should be to get the custom controls on mobile solid everywhere
	    // so we can remove this all together. Right now this will block custom
	    // controls on touch enabled laptops like the Chrome Pixel
	    if (vjs.TOUCH_ENABLED && player.options()['nativeControlsForTouch'] === true) {
	      this.useNativeControls();
	    }

	    // Chrome and Safari both have issues with autoplay.
	    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
	    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
	    // This fixes both issues. Need to wait for API, so it updates displays correctly
	    player.ready(function(){
	      if (this.src() && this.tag && this.options_['autoplay'] && this.paused()) {
	        delete this.tag['poster']; // Chrome Fix. Fixed in Chrome v16.
	        this.play();
	      }
	    });

	    this.triggerReady();
	  }
	});

	vjs.Html5.prototype.dispose = function(){
	  vjs.Html5.disposeMediaElement(this.el_);
	  vjs.MediaTechController.prototype.dispose.call(this);
	};

	vjs.Html5.prototype.createEl = function(){
	  var player = this.player_,
	      track,
	      trackEl,
	      i,
	      // If possible, reuse original tag for HTML5 playback technology element
	      el = player.tag,
	      attributes,
	      newEl,
	      clone;

	  // Check if this browser supports moving the element into the box.
	  // On the iPhone video will break if you move the element,
	  // So we have to create a brand new element.
	  if (!el || this['movingMediaElementInDOM'] === false) {

	    // If the original tag is still there, clone and remove it.
	    if (el) {
	      clone = el.cloneNode(false);
	      vjs.Html5.disposeMediaElement(el);
	      el = clone;
	      player.tag = null;
	    } else {
	      el = vjs.createEl('video');

	      // determine if native controls should be used
	      attributes = videojs.util.mergeOptions({}, player.tagAttributes);
	      if (!vjs.TOUCH_ENABLED || player.options()['nativeControlsForTouch'] !== true) {
	        delete attributes.controls;
	      }

	      vjs.setElementAttributes(el,
	        vjs.obj.merge(attributes, {
	          id:player.id() + '_html5_api',
	          'class':'vjs-tech'
	        })
	      );
	    }
	    // associate the player with the new tag
	    el['player'] = player;

	    if (player.options_.tracks) {
	      for (i = 0; i < player.options_.tracks.length; i++) {
	        track = player.options_.tracks[i];
	        trackEl = document.createElement('track');
	        trackEl.kind = track.kind;
	        trackEl.label = track.label;
	        trackEl.srclang = track.srclang;
	        trackEl.src = track.src;
	        if ('default' in track) {
	          trackEl.setAttribute('default', 'default');
	        }
	        el.appendChild(trackEl);
	      }
	    }

	    vjs.insertFirst(el, player.el());
	  }

	  // Update specific tag settings, in case they were overridden
	  var settingsAttrs = ['autoplay','preload','loop','muted'];
	  for (i = settingsAttrs.length - 1; i >= 0; i--) {
	    var attr = settingsAttrs[i];
	    var overwriteAttrs = {};
	    if (typeof player.options_[attr] !== 'undefined') {
	      overwriteAttrs[attr] = player.options_[attr];
	    }
	    vjs.setElementAttributes(el, overwriteAttrs);
	  }

	    //changes for VID-2669 - inline setting for Safari and Mobile SDKS's WebView as following this announcement - https://webkit.org/blog/6784/new-video-policies-for-ios/
	    if (player.options_.enableNativeInline) {
	        el.setAttribute("playsinline","");//setting W3C standard inline video attribute on Safari and Mobile SDK's WebView
	        el.setAttribute("webkit-playsinline","");//setting Apple's inline video on Mobile SDK's WebView to have backward compatibility on older version of iOS(~9)
	    }

	  return el;
	  // jenniisawesome = true;
	};


	vjs.Html5.prototype.hideCaptions = function() {
	  var tracks = this.el_.querySelectorAll('track'),
	      track,
	      i = tracks.length,
	      kinds = {
	        'captions': 1,
	        'subtitles': 1
	      };

	  while (i--) {
	    track = tracks[i].track;
	    if ((track && track['kind'] in kinds) &&
	        (!tracks[i]['default'])) {
	      track.mode = 'disabled';
	    }
	  }
	};

	// Make video events trigger player events
	// May seem verbose here, but makes other APIs possible.
	// Triggers removed using this.off when disposed
	vjs.Html5.prototype.setupTriggers = function(){
	  for (var i = vjs.Html5.Events.length - 1; i >= 0; i--) {
	    this.on(vjs.Html5.Events[i], this.eventHandler);
	  }
	};

	vjs.Html5.prototype.eventHandler = function(evt){
	  // In the case of an error on the video element, set the error prop
	  // on the player and let the player handle triggering the event. On
	  // some platforms, error events fire that do not cause the error
	  // property on the video element to be set. See #1465 for an example.
	  if (evt.type == 'error' && this.error()) {
	    this.player().error(this.error().code);

	  // in some cases we pass the event directly to the player
	  } else {
	    // No need for media events to bubble up.
	    evt.bubbles = false;

	    this.player().trigger(evt);
	  }
	};

	vjs.Html5.prototype.useNativeControls = function(){
	  var tech, player, controlsOn, controlsOff, cleanUp;

	  tech = this;
	  player = this.player();

	  // If the player controls are enabled turn on the native controls
	  tech.setControls(player.controls());

	  // Update the native controls when player controls state is updated
	  controlsOn = function(){
	    tech.setControls(true);
	  };
	  controlsOff = function(){
	    tech.setControls(false);
	  };
	  player.on('controlsenabled', controlsOn);
	  player.on('controlsdisabled', controlsOff);

	  // Clean up when not using native controls anymore
	  cleanUp = function(){
	    player.off('controlsenabled', controlsOn);
	    player.off('controlsdisabled', controlsOff);
	  };
	  tech.on('dispose', cleanUp);
	  player.on('usingcustomcontrols', cleanUp);

	  // Update the state of the player to using native controls
	  player.usingNativeControls(true);
	};


	vjs.Html5.prototype.play = function(){ this.el_.play(); };
	vjs.Html5.prototype.pause = function(){ this.el_.pause(); };
	vjs.Html5.prototype.paused = function(){ return this.el_.paused; };

	// vjs.Html5.prototype.currentTime = function(){ return this.el_.currentTime; };
	// vjs.Html5.prototype.setCurrentTime = function(seconds){
	//   try {
	//     this.el_.currentTime = seconds;
	//   } catch(e) {
	//     vjs.log(e, 'Video is not ready. (Video.js)');
	//     // this.warning(VideoJS.warnings.videoNotReady);
	//   }
	// };

	vjs.Html5.prototype.currentTime = function(){
	    return this.el_.currentTime || this.el_.currentTimeForOutstream || 0;//ks : comment out due to Safari, FireFox, doesn't set currentTime of the video element if the video element doesn't have propoer source, so if JSVPAID creative getnerates their own video element, this current Time will not be set on Desktop Safari, Firefox
	};

	vjs.Html5.prototype.setCurrentTime = function(seconds){
	    try {
	        this.el_.currentTimeForOutstream = seconds;
	        this.el_.currentTime = seconds;
	    } catch(e) {
	        vjs.log(e, 'Video is not ready. (Video.js)');
	    }
	};



	vjs.Html5.prototype.duration = function(){ return this.el_.duration || 0; };
	vjs.Html5.prototype.buffered = function(){ return this.el_.buffered; };

	vjs.Html5.prototype.volume = function(){ return this.el_.volume; };
	vjs.Html5.prototype.setVolume = function(percentAsDecimal){ this.el_.volume = percentAsDecimal; };
	vjs.Html5.prototype.muted = function(){ return this.el_.muted; };
	vjs.Html5.prototype.setMuted = function(muted){ this.el_.muted = muted; };

	vjs.Html5.prototype.width = function(){ return this.el_.offsetWidth; };
	vjs.Html5.prototype.height = function(){ return this.el_.offsetHeight; };

	vjs.Html5.prototype.supportsFullScreen = function(){
	  if (typeof this.el_.webkitEnterFullScreen == 'function') {

	    // Seems to be broken in Chromium/Chrome && Safari in Leopard
	    if (/Android/.test(vjs.USER_AGENT) || !/Chrome|Mac OS X 10.5/.test(vjs.USER_AGENT)) {
	      return true;
	    }
	  }
	  return false;
	};

	vjs.Html5.prototype.enterFullScreen = function(){
	  var video = this.el_;

	  if ('webkitDisplayingFullscreen' in video) {
	    this.one('webkitbeginfullscreen', function() {
	      this.player_.isFullscreen(true);

	      this.one('webkitendfullscreen', function() {
	        this.player_.isFullscreen(false);
	        this.player_.trigger('fullscreenchange');
	      });

	      this.player_.trigger('fullscreenchange');
	    });
	  }

	  if (video.paused && video.networkState <= video.HAVE_METADATA) {
	    // attempt to prime the video element for programmatic access
	    // this isn't necessary on the desktop but shouldn't hurt
	    this.el_.play();

	    // playing and pausing synchronously during the transition to fullscreen
	    // can get iOS ~6.1 devices into a play/pause loop
	    this.setTimeout(function(){
	      video.pause();
	      video.webkitEnterFullScreen();
	    }, 0);
	  } else {
	    video.webkitEnterFullScreen();
	  }
	};

	vjs.Html5.prototype.exitFullScreen = function(){
	  this.el_.webkitExitFullScreen();
	};

	// Checks to see if the element's reported URI (either from `el_.src`
	// or `el_.currentSrc`) is a blob-uri and, if so, returns the uri that
	// was passed into the source-handler when it was first invoked instead
	// of the blob-uri
	vjs.Html5.prototype.returnOriginalIfBlobURI_ = function (elementURI, originalURI) {
	  var blobURIRegExp = /^blob\:/i;

	  // If originalURI is undefined then we are probably in a non-source-handler-enabled
	  // tech that inherits from the Html5 tech so we should just return the elementURI
	  // regardless of it's blobby-ness
	  if (originalURI && elementURI && blobURIRegExp.test(elementURI)) {
	    return originalURI;
	  }
	  return elementURI;
	};

	vjs.Html5.prototype.src = function(src) {
	  var elementSrc = this.el_.src;

	  if (src === undefined) {
	    return this.returnOriginalIfBlobURI_(elementSrc, this.source_);
	  } else {
	    // Setting src through `src` instead of `setSrc` will be deprecated
	    this.setSrc(src);
	  }
	};

	vjs.Html5.prototype.setSrc = function(src) {
	  this.el_.src = src;
	};

	vjs.Html5.prototype.load = function(){ this.el_.load(); };
	vjs.Html5.prototype.currentSrc = function(){
	  var elementSrc = this.el_.currentSrc;

	  if (!this.currentSource_) {
	    return elementSrc;
	  }

	  return this.returnOriginalIfBlobURI_(elementSrc, this.currentSource_.src);
	};

	vjs.Html5.prototype.poster = function(){ return this.el_.poster; };
	vjs.Html5.prototype.setPoster = function(val){ this.el_.poster = val; };

	vjs.Html5.prototype.preload = function(){ return this.el_.preload; };
	vjs.Html5.prototype.setPreload = function(val){ this.el_.preload = val; };

	vjs.Html5.prototype.autoplay = function(){ return this.el_.autoplay; };
	vjs.Html5.prototype.setAutoplay = function(val){ this.el_.autoplay = val; };

	vjs.Html5.prototype.controls = function(){ return this.el_.controls; };
	vjs.Html5.prototype.setControls = function(val){ this.el_.controls = !!val; };

	vjs.Html5.prototype.loop = function(){ return this.el_.loop; };
	vjs.Html5.prototype.setLoop = function(val){ this.el_.loop = val; };

	vjs.Html5.prototype.error = function(){ return this.el_.error; };
	vjs.Html5.prototype.seeking = function(){ return this.el_.seeking; };
	vjs.Html5.prototype.seekable = function(){ return this.el_.seekable; };
	vjs.Html5.prototype.ended = function(){ return this.el_.ended; };
	vjs.Html5.prototype.defaultMuted = function(){ return this.el_.defaultMuted; };

	vjs.Html5.prototype.playbackRate = function(){ return this.el_.playbackRate; };
	vjs.Html5.prototype.setPlaybackRate = function(val){ this.el_.playbackRate = val; };

	vjs.Html5.prototype.networkState = function(){ return this.el_.networkState; };
	vjs.Html5.prototype.readyState = function(){ return this.el_.readyState; };

	vjs.Html5.prototype.textTracks = function() {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.textTracks.call(this);
	  }

	  return this.el_.textTracks;
	};
	vjs.Html5.prototype.addTextTrack = function(kind, label, language) {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.addTextTrack.call(this, kind, label, language);
	  }

	  return this.el_.addTextTrack(kind, label, language);
	};

	vjs.Html5.prototype.addRemoteTextTrack = function(options) {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.addRemoteTextTrack.call(this, options);
	  }

	  var track = document.createElement('track');
	  options = options || {};

	  if (options['kind']) {
	    track['kind'] = options['kind'];
	  }
	  if (options['label']) {
	    track['label'] = options['label'];
	  }
	  if (options['language'] || options['srclang']) {
	    track['srclang'] = options['language'] || options['srclang'];
	  }
	  if (options['default']) {
	    track['default'] = options['default'];
	  }
	  if (options['id']) {
	    track['id'] = options['id'];
	  }
	  if (options['src']) {
	    track['src'] = options['src'];
	  }

	  this.el().appendChild(track);

	  if (track.track['kind'] === 'metadata') {
	    track['track']['mode'] = 'hidden';
	  } else {
	    track['track']['mode'] = 'disabled';
	  }

	  track['onload'] = function() {
	    var tt = track['track'];
	    if (track.readyState >= 2) {
	      if (tt['kind'] === 'metadata' && tt['mode'] !== 'hidden') {
	        tt['mode'] = 'hidden';
	      } else if (tt['kind'] !== 'metadata' && tt['mode'] !== 'disabled') {
	        tt['mode'] = 'disabled';
	      }
	      track['onload'] = null;
	    }
	  };

	  this.remoteTextTracks().addTrack_(track.track);

	  return track;
	};

	vjs.Html5.prototype.removeRemoteTextTrack = function(track) {
	  if (!this['featuresNativeTextTracks']) {
	    return vjs.MediaTechController.prototype.removeRemoteTextTrack.call(this, track);
	  }

	  var tracks, i;

	  this.remoteTextTracks().removeTrack_(track);

	  tracks = this.el()['querySelectorAll']('track');

	  for (i = 0; i < tracks.length; i++) {
	    if (tracks[i] === track || tracks[i]['track'] === track) {
	      tracks[i]['parentNode']['removeChild'](tracks[i]);
	      break;
	    }
	  }
	};

	/* HTML5 Support Testing ---------------------------------------------------- */

	/**
	 * Check if HTML5 video is supported by this browser/device
	 * @return {Boolean}
	 */
	vjs.Html5.isSupported = function(){
	  // IE9 with no Media Player is a LIAR! (#984)
	  try {
	    vjs.TEST_VID['volume'] = 0.5;
	  } catch (e) {
	    return false;
	  }

	  return !!vjs.TEST_VID.canPlayType;
	};

	// Add Source Handler pattern functions to this tech
	vjs.MediaTechController.withSourceHandlers(vjs.Html5);

	/*
	 * Override the withSourceHandler mixin's methods with our own because
	 * the HTML5 Media Element returns blob urls when utilizing MSE and we
	 * want to still return proper source urls even when in that case
	 */
	(function(){
	  var
	    origSetSource = vjs.Html5.prototype.setSource,
	    origDisposeSourceHandler = vjs.Html5.prototype.disposeSourceHandler;

	  vjs.Html5.prototype.setSource = function (source) {
	    var retVal = origSetSource.call(this, source);
	    this.source_ = source.src;
	    return retVal;
	  };

	  vjs.Html5.prototype.disposeSourceHandler = function () {
	    this.source_ = undefined;
	    return origDisposeSourceHandler.call(this);
	  };
	})();

	/**
	 * The default native source handler.
	 * This simply passes the source to the video element. Nothing fancy.
	 * @param  {Object} source   The source object
	 * @param  {vjs.Html5} tech  The instance of the HTML5 tech
	 */
	vjs.Html5.nativeSourceHandler = {};

	/**
	 * Check if the video element can handle the source natively
	 * @param  {Object} source  The source object
	 * @return {String}         'probably', 'maybe', or '' (empty string)
	 */
	vjs.Html5.nativeSourceHandler.canHandleSource = function(source){
	  var match, ext;

	  function canPlayType(type){
	    // IE9 on Windows 7 without MediaPlayer throws an error here
	    // https://github.com/videojs/video.js/issues/519
	    try {
	      return vjs.TEST_VID.canPlayType(type);
	    } catch(e) {
	      return '';
	    }
	  }

	  // If a type was provided we should rely on that
	  if (source.type) {
	    return canPlayType(source.type);
	  } else if (source.src) {
	    // If no type, fall back to checking 'video/[EXTENSION]'
	    match = source.src.match(/\.([^.\/\?]+)(\?[^\/]+)?$/i);
	    ext = match && match[1];

	    return canPlayType('video/'+ext);
	  }

	  return '';
	};

	/**
	 * Pass the source to the video element
	 * Adaptive source handlers will have more complicated workflows before passing
	 * video data to the video element
	 * @param  {Object} source    The source object
	 * @param  {vjs.Html5} tech   The instance of the Html5 tech
	 */
	vjs.Html5.nativeSourceHandler.handleSource = function(source, tech){
	  tech.setSrc(source.src);
	};

	/**
	 * Clean up the source handler when disposing the player or switching sources..
	 * (no cleanup is needed when supporting the format natively)
	 */
	vjs.Html5.nativeSourceHandler.dispose = function(){};

	// Register the native source handler
	vjs.Html5.registerSourceHandler(vjs.Html5.nativeSourceHandler);

	/**
	 * Check if the volume can be changed in this browser/device.
	 * Volume cannot be changed in a lot of mobile devices.
	 * Specifically, it can't be changed from 1 on iOS.
	 * @return {Boolean}
	 */
	vjs.Html5.canControlVolume = function(){
	  var volume =  vjs.TEST_VID.volume;
	  vjs.TEST_VID.volume = (volume / 2) + 0.1;
	  return volume !== vjs.TEST_VID.volume;
	};

	/**
	 * Check if playbackRate is supported in this browser/device.
	 * @return {[type]} [description]
	 */
	vjs.Html5.canControlPlaybackRate = function(){
	  var playbackRate =  vjs.TEST_VID.playbackRate;
	  vjs.TEST_VID.playbackRate = (playbackRate / 2) + 0.1;
	  return playbackRate !== vjs.TEST_VID.playbackRate;
	};

	/**
	 * Check to see if native text tracks are supported by this browser/device
	 * @return {Boolean}
	 */
	vjs.Html5.supportsNativeTextTracks = function() {
	  var supportsTextTracks;

	  // Figure out native text track support
	  // If mode is a number, we cannot change it because it'll disappear from view.
	  // Browsers with numeric modes include IE10 and older (<=2013) samsung android models.
	  // Firefox isn't playing nice either with modifying the mode
	  // TODO: Investigate firefox: https://github.com/videojs/video.js/issues/1862
	  supportsTextTracks = !!vjs.TEST_VID.textTracks;
	  if (supportsTextTracks && vjs.TEST_VID.textTracks.length > 0) {
	    supportsTextTracks = typeof vjs.TEST_VID.textTracks[0]['mode'] !== 'number';
	  }
	  if (supportsTextTracks && vjs.IS_FIREFOX) {
	    supportsTextTracks = false;
	  }

	  return supportsTextTracks;
	};

	/**
	 * Set the tech's volume control support status
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['featuresVolumeControl'] = vjs.Html5.canControlVolume();

	/**
	 * Set the tech's playbackRate support status
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['featuresPlaybackRate'] = vjs.Html5.canControlPlaybackRate();

	/**
	 * Set the tech's status on moving the video element.
	 * In iOS, if you move a video element in the DOM, it breaks video playback.
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['movingMediaElementInDOM'] = !vjs.IS_IOS;

	/**
	 * Set the the tech's fullscreen resize support status.
	 * HTML video is able to automatically resize when going to fullscreen.
	 * (No longer appears to be used. Can probably be removed.)
	 */
	vjs.Html5.prototype['featuresFullscreenResize'] = true;

	/**
	 * Set the tech's progress event support status
	 * (this disables the manual progress events of the MediaTechController)
	 */
	vjs.Html5.prototype['featuresProgressEvents'] = true;

	/**
	 * Sets the tech's status on native text track support
	 * @type {Boolean}
	 */
	vjs.Html5.prototype['featuresNativeTextTracks'] = vjs.Html5.supportsNativeTextTracks();

	// HTML5 Feature detection and Device Fixes --------------------------------- //
	(function() {
	  var canPlayType,
	      mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i,
	      mp4RE = /^video\/mp4/i;

	  vjs.Html5.patchCanPlayType = function() {
	    // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
	    if (vjs.ANDROID_VERSION >= 4.0) {
	      if (!canPlayType) {
	        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
	      }

	      vjs.TEST_VID.constructor.prototype.canPlayType = function(type) {
	        if (type && mpegurlRE.test(type)) {
	          return 'maybe';
	        }
	        return canPlayType.call(this, type);
	      };
	    }

	    // Override Android 2.2 and less canPlayType method which is broken
	    if (vjs.IS_OLD_ANDROID) {
	      if (!canPlayType) {
	        canPlayType = vjs.TEST_VID.constructor.prototype.canPlayType;
	      }

	      vjs.TEST_VID.constructor.prototype.canPlayType = function(type){
	        if (type && mp4RE.test(type)) {
	          return 'maybe';
	        }
	        return canPlayType.call(this, type);
	      };
	    }
	  };

	  vjs.Html5.unpatchCanPlayType = function() {
	    var r = vjs.TEST_VID.constructor.prototype.canPlayType;
	    vjs.TEST_VID.constructor.prototype.canPlayType = canPlayType;
	    canPlayType = null;
	    return r;
	  };

	  // by default, patch the video element
	  vjs.Html5.patchCanPlayType();
	})();

	// List of all HTML5 events (various uses).
	vjs.Html5.Events = 'loadstart,suspend,abort,error,emptied,stalled,loadedmetadata,loadeddata,canplay,canplaythrough,playing,waiting,seeking,seeked,ended,durationchange,timeupdate,progress,play,pause,ratechange,volumechange'.split(',');

	vjs.Html5.disposeMediaElement = function(el){
	  if (!el) { return; }

	  el['player'] = null;

	  if (el.parentNode) {
	    el.parentNode.removeChild(el);
	  }

	  // remove any child track or source nodes to prevent their loading
	  while(el.hasChildNodes()) {
	    el.removeChild(el.firstChild);
	  }

	  // remove any src reference. not setting `src=''` because that causes a warning
	  // in firefox
	  el.removeAttribute('src');

	  // force the media element to update its loading state by calling load()
	  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
	  if (typeof el.load === 'function') {
	    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
	    (function() {
	      try {
	        el.load();
	      } catch (e) {
	        // not supported
	      }
	    })();
	  }
	};

	/**
	 * The Media Loader is the component that decides which playback technology to load
	 * when the player is initialized.
	 *
	 * @constructor
	 */
	vjs.MediaLoader = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.Component.call(this, player, options, ready);

	    // If there are no sources when the player is initialized,
	    // load the first supported playback technology.
	    if (!player.options_['sources'] || player.options_['sources'].length === 0) {
	      for (var i=0,j=player.options_['techOrder']; i<j.length; i++) {
	        var techName = vjs.capitalize(j[i]),
	            tech = window['videojs_apn'][techName];

	        // Check if the browser supports this technology
	        if (tech && tech.isSupported()) {
	          player.loadTech(techName);
	          break;
	        }
	      }
	    } else {
	      // // Loop through playback technologies (HTML5, Flash) and check for support.
	      // // Then load the best source.
	      // // A few assumptions here:
	      // //   All playback technologies respect preload false.
	      player.src(player.options_['sources']);
	    }
	  }
	});

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
	 *
	 * enum TextTrackMode { "disabled",  "hidden",  "showing" };
	 */
	vjs.TextTrackMode = {
	  'disabled': 'disabled',
	  'hidden': 'hidden',
	  'showing': 'showing'
	};

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackkind
	 *
	 * enum TextTrackKind { "subtitles",  "captions",  "descriptions",  "chapters",  "metadata" };
	 */
	vjs.TextTrackKind = {
	  'subtitles': 'subtitles',
	  'captions': 'captions',
	  'descriptions': 'descriptions',
	  'chapters': 'chapters',
	  'metadata': 'metadata'
	};

	(function() {
	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack
	 *
	 * interface TextTrack : EventTarget {
	 *   readonly attribute TextTrackKind kind;
	 *   readonly attribute DOMString label;
	 *   readonly attribute DOMString language;
	 *
	 *   readonly attribute DOMString id;
	 *   readonly attribute DOMString inBandMetadataTrackDispatchType;
	 *
	 *   attribute TextTrackMode mode;
	 *
	 *   readonly attribute TextTrackCueList? cues;
	 *   readonly attribute TextTrackCueList? activeCues;
	 *
	 *   void addCue(TextTrackCue cue);
	 *   void removeCue(TextTrackCue cue);
	 *
	 *   attribute EventHandler oncuechange;
	 * };
	 */

	vjs.TextTrack = function(options) {
	  var tt, id, mode, kind, label, language, cues, activeCues, timeupdateHandler, changed, prop;

	  options = options || {};

	  if (!options['player']) {
	    throw new Error('A player was not provided.');
	  }

	  tt = this;
	  if (vjs.IS_IE8) {
	    tt = document.createElement('custom');

	    for (prop in vjs.TextTrack.prototype) {
	      tt[prop] = vjs.TextTrack.prototype[prop];
	    }
	  }

	  tt.player_ = options['player'];

	  mode = vjs.TextTrackMode[options['mode']] || 'disabled';
	  kind = vjs.TextTrackKind[options['kind']] || 'subtitles';
	  label = options['label'] || '';
	  language = options['language'] || options['srclang'] || '';
	  id = options['id'] || 'vjs_text_track_' + vjs.guid++;

	  if (kind === 'metadata' || kind === 'chapters') {
	    mode = 'hidden';
	  }

	  tt.cues_ = [];
	  tt.activeCues_ = [];

	  cues = new vjs.TextTrackCueList(tt.cues_);
	  activeCues = new vjs.TextTrackCueList(tt.activeCues_);

	  changed = false;
	  timeupdateHandler = vjs.bind(tt, function() {
	    this['activeCues'];
	    if (changed) {
	      this['trigger']('cuechange');
	      changed = false;
	    }
	  });
	  if (mode !== 'disabled') {
	    tt.player_.on('timeupdate', timeupdateHandler);
	  }

	  Object.defineProperty(tt, 'kind', {
	    get: function() {
	      return kind;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'label', {
	    get: function() {
	      return label;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'language', {
	    get: function() {
	      return language;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'id', {
	    get: function() {
	      return id;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'mode', {
	    get: function() {
	      return mode;
	    },
	    set: function(newMode) {
	      if (!vjs.TextTrackMode[newMode]) {
	        return;
	      }
	      mode = newMode;
	      if (mode === 'showing') {
	        this.player_.on('timeupdate', timeupdateHandler);
	      }
	      this.trigger('modechange');
	    }
	  });

	  Object.defineProperty(tt, 'cues', {
	    get: function() {
	      if (!this.loaded_) {
	        return null;
	      }

	      return cues;
	    },
	    set: Function.prototype
	  });

	  Object.defineProperty(tt, 'activeCues', {
	    get: function() {
	      var i, l, active, ct, cue;

	      if (!this.loaded_) {
	        return null;
	      }

	      if (this['cues'].length === 0) {
	        return activeCues; // nothing to do
	      }

	      ct = this.player_.currentTime();
	      i = 0;
	      l = this['cues'].length;
	      active = [];

	      for (; i < l; i++) {
	        cue = this['cues'][i];
	        if (cue['startTime'] <= ct && cue['endTime'] >= ct) {
	          active.push(cue);
	        } else if (cue['startTime'] === cue['endTime'] && cue['startTime'] <= ct && cue['startTime'] + 0.5 >= ct) {
	          active.push(cue);
	        }
	      }

	      changed = false;

	      if (active.length !== this.activeCues_.length) {
	        changed = true;
	      } else {
	        for (i = 0; i < active.length; i++) {
	          if (indexOf.call(this.activeCues_, active[i]) === -1) {
	            changed = true;
	          }
	        }
	      }

	      this.activeCues_ = active;
	      activeCues.setCues_(this.activeCues_);

	      return activeCues;
	    },
	    set: Function.prototype
	  });

	  if (options.src) {
	    loadTrack(options.src, tt);
	  } else {
	    tt.loaded_ = true;
	  }

	  if (vjs.IS_IE8) {
	    return tt;
	  }
	};

	vjs.TextTrack.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
	vjs.TextTrack.prototype.constructor = vjs.TextTrack;

	/*
	 * cuechange - One or more cues in the track have become active or stopped being active.
	 */
	vjs.TextTrack.prototype.allowedEvents_ = {
	  'cuechange': 'cuechange'
	};

	vjs.TextTrack.prototype.addCue = function(cue) {
	  var tracks = this.player_.textTracks(),
	      i = 0;

	  if (tracks) {
	    for (; i < tracks.length; i++) {
	      if (tracks[i] !== this) {
	        tracks[i].removeCue(cue);
	      }
	    }
	  }

	  this.cues_.push(cue);
	  this['cues'].setCues_(this.cues_);
	};

	vjs.TextTrack.prototype.removeCue = function(removeCue) {
	  var i = 0,
	      l = this.cues_.length,
	      cue,
	      removed = false;

	  for (; i < l; i++) {
	    cue = this.cues_[i];
	    if (cue === removeCue) {
	      this.cues_.splice(i, 1);
	      removed = true;
	    }
	  }

	  if (removed) {
	    this.cues.setCues_(this.cues_);
	  }
	};

	/*
	 * Downloading stuff happens below this point
	 */
	var loadTrack, parseCues, indexOf;

	loadTrack = function(src, track) {
	  vjs.xhr(src, vjs.bind(this, function(err, response, responseBody){
	    if (err) {
	      return vjs.log.error(err);
	    }


	    track.loaded_ = true;
	    parseCues(responseBody, track);
	  }));
	};

	parseCues = function(srcContent, track) {
	  if (typeof window['WebVTT'] !== 'function') {
	    //try again a bit later
	    return window.setTimeout(function() {
	      parseCues(srcContent, track);
	    }, 25);
	  }

	  var parser = new window['WebVTT']['Parser'](window, window['vttjs'], window['WebVTT']['StringDecoder']());

	  parser['oncue'] = function(cue) {
	    track.addCue(cue);
	  };
	  parser['onparsingerror'] = function(error) {
	    vjs.log.error(error);
	  };

	  parser['parse'](srcContent);
	  parser['flush']();
	};

	indexOf = function(searchElement, fromIndex) {

	  var k;

	  if (this == null) {
	    throw new TypeError('"this" is null or not defined');
	  }

	  var O = Object(this);

	  var len = O.length >>> 0;

	  if (len === 0) {
	    return -1;
	  }

	  var n = +fromIndex || 0;

	  if (Math.abs(n) === Infinity) {
	    n = 0;
	  }

	  if (n >= len) {
	    return -1;
	  }

	  k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

	  while (k < len) {
	    if (k in O && O[k] === searchElement) {
	      return k;
	    }
	    k++;
	  }
	  return -1;
	};

	})();

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist
	 *
	 * interface TextTrackList : EventTarget {
	 *   readonly attribute unsigned long length;
	 *   getter TextTrack (unsigned long index);
	 *   TextTrack? getTrackById(DOMString id);
	 *
	 *   attribute EventHandler onchange;
	 *   attribute EventHandler onaddtrack;
	 *   attribute EventHandler onremovetrack;
	 * };
	 */
	vjs.TextTrackList = function(tracks) {
	  var list = this,
	      prop,
	      i = 0;

	  if (vjs.IS_IE8) {
	    list = document.createElement('custom');

	    for (prop in vjs.TextTrackList.prototype) {
	      list[prop] = vjs.TextTrackList.prototype[prop];
	    }
	  }

	  tracks = tracks || [];
	  list.tracks_ = [];

	  Object.defineProperty(list, 'length', {
	    get: function() {
	      return this.tracks_.length;
	    }
	  });

	  for (; i < tracks.length; i++) {
	    list.addTrack_(tracks[i]);
	  }

	  if (vjs.IS_IE8) {
	    return list;
	  }
	};

	vjs.TextTrackList.prototype = vjs.obj.create(vjs.EventEmitter.prototype);
	vjs.TextTrackList.prototype.constructor = vjs.TextTrackList;

	/*
	 * change - One or more tracks in the track list have been enabled or disabled.
	 * addtrack - A track has been added to the track list.
	 * removetrack - A track has been removed from the track list.
	*/
	vjs.TextTrackList.prototype.allowedEvents_ = {
	  'change': 'change',
	  'addtrack': 'addtrack',
	  'removetrack': 'removetrack'
	};

	// emulate attribute EventHandler support to allow for feature detection
	(function() {
	  var event;

	  for (event in vjs.TextTrackList.prototype.allowedEvents_) {
	    vjs.TextTrackList.prototype['on' + event] = null;
	  }
	})();

	vjs.TextTrackList.prototype.addTrack_ = function(track) {
	  var index = this.tracks_.length;
	  if (!(''+index in this)) {
	    Object.defineProperty(this, index, {
	      get: function() {
	        return this.tracks_[index];
	      }
	    });
	  }

	  track.addEventListener('modechange', vjs.bind(this, function() {
	    this.trigger('change');
	  }));
	  this.tracks_.push(track);

	  this.trigger({
	    type: 'addtrack',
	    track: track
	  });
	};

	vjs.TextTrackList.prototype.removeTrack_ = function(rtrack) {
	  var i = 0,
	      l = this.length,
	      result = null,
	      track;

	  for (; i < l; i++) {
	    track = this[i];
	    if (track === rtrack) {
	      this.tracks_.splice(i, 1);
	      break;
	    }
	  }

	  this.trigger({
	    type: 'removetrack',
	    track: rtrack
	  });
	};

	vjs.TextTrackList.prototype.getTrackById = function(id) {
	  var i = 0,
	      l = this.length,
	      result = null,
	      track;

	  for (; i < l; i++) {
	    track = this[i];
	    if (track.id === id) {
	      result = track;
	      break;
	    }
	  }

	  return result;
	};

	/*
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist
	 *
	 * interface TextTrackCueList {
	 *   readonly attribute unsigned long length;
	 *   getter TextTrackCue (unsigned long index);
	 *   TextTrackCue? getCueById(DOMString id);
	 * };
	 */

	vjs.TextTrackCueList = function(cues) {
	  var list = this,
	      prop;

	  if (vjs.IS_IE8) {
	    list = document.createElement('custom');

	    for (prop in vjs.TextTrackCueList.prototype) {
	      list[prop] = vjs.TextTrackCueList.prototype[prop];
	    }
	  }

	  vjs.TextTrackCueList.prototype.setCues_.call(list, cues);

	  Object.defineProperty(list, 'length', {
	    get: function() {
	      return this.length_;
	    }
	  });

	  if (vjs.IS_IE8) {
	    return list;
	  }
	};

	vjs.TextTrackCueList.prototype.setCues_ = function(cues) {
	  var oldLength = this.length || 0,
	      i = 0,
	      l = cues.length,
	      defineProp;

	  this.cues_ = cues;
	  this.length_ = cues.length;

	  defineProp = function(i) {
	    if (!(''+i in this)) {
	      Object.defineProperty(this, '' + i, {
	        get: function() {
	          return this.cues_[i];
	        }
	      });
	    }
	  };

	  if (oldLength < l) {
	    i = oldLength;
	    for(; i < l; i++) {
	      defineProp.call(this, i);
	    }
	  }
	};

	vjs.TextTrackCueList.prototype.getCueById = function(id) {
	  var i = 0,
	      l = this.length,
	      result = null,
	      cue;

	  for (; i < l; i++) {
	    cue = this[i];
	    if (cue.id === id) {
	      result = cue;
	      break;
	    }
	  }

	  return result;
	};

	(function() {
	'use strict';

	/* Text Track Display
	============================================================================= */
	// Global container for both subtitle and captions text. Simple div container.

	/**
	 * The component for displaying text track cues
	 *
	 * @constructor
	 */
	vjs.TextTrackDisplay = vjs.Component.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.Component.call(this, player, options, ready);

	    player.on('loadstart', vjs.bind(this, this.toggleDisplay));

	    // This used to be called during player init, but was causing an error
	    // if a track should show by default and the display hadn't loaded yet.
	    // Should probably be moved to an external track loader when we support
	    // tracks that don't need a display.
	    player.ready(vjs.bind(this, function() {
	      if (player.tech && player.tech['featuresNativeTextTracks']) {
	        this.hide();
	        return;
	      }

	      var i, tracks, track;

	      player.on('fullscreenchange', vjs.bind(this, this.updateDisplay));

	      tracks = player.options_['tracks'] || [];
	      for (i = 0; i < tracks.length; i++) {
	        track = tracks[i];
	        this.player_.addRemoteTextTrack(track);
	      }
	    }));
	  }
	});

	vjs.TextTrackDisplay.prototype.toggleDisplay = function() {
	  if (this.player_.tech && this.player_.tech['featuresNativeTextTracks']) {
	    this.hide();
	  } else {
	    this.show();
	  }
	};

	vjs.TextTrackDisplay.prototype.createEl = function(){
	  return vjs.Component.prototype.createEl.call(this, 'div', {
	    className: 'vjs-text-track-display'
	  });
	};

	vjs.TextTrackDisplay.prototype.clearDisplay = function() {
	  if (typeof window['WebVTT'] === 'function') {
	    window['WebVTT']['processCues'](window, [], this.el_);
	  }
	};

	// Add cue HTML to display
	var constructColor = function(color, opacity) {
	  return 'rgba(' +
	    // color looks like "#f0e"
	    parseInt(color[1] + color[1], 16) + ',' +
	    parseInt(color[2] + color[2], 16) + ',' +
	    parseInt(color[3] + color[3], 16) + ',' +
	    opacity + ')';
	};
	var darkGray = '#222';
	var lightGray = '#ccc';
	var fontMap = {
	  monospace:             'monospace',
	  sansSerif:             'sans-serif',
	  serif:                 'serif',
	  monospaceSansSerif:    '"Andale Mono", "Lucida Console", monospace',
	  monospaceSerif:        '"Courier New", monospace',
	  proportionalSansSerif: 'sans-serif',
	  proportionalSerif:     'serif',
	  casual:                '"Comic Sans MS", Impact, fantasy',
	  script:                '"Monotype Corsiva", cursive',
	  smallcaps:             '"Andale Mono", "Lucida Console", monospace, sans-serif'
	};
	var tryUpdateStyle = function(el, style, rule) {
	  // some style changes will throw an error, particularly in IE8. Those should be noops.
	  try {
	    el.style[style] = rule;
	  } catch (e) {}
	};

	vjs.TextTrackDisplay.prototype.updateDisplay = function() {
	  var tracks = this.player_.textTracks(),
	      i = 0,
	      track;

	  this.clearDisplay();

	  if (!tracks) {
	    return;
	  }

	  for (; i < tracks.length; i++) {
	    track = tracks[i];
	    if (track['mode'] === 'showing') {
	      this.updateForTrack(track);
	    }
	  }
	};

	vjs.TextTrackDisplay.prototype.updateForTrack = function(track) {
	  if (typeof window['WebVTT'] !== 'function' || !track['activeCues']) {
	    return;
	  }

	  var i = 0,
	      property,
	      cueDiv,
	      overrides = this.player_['textTrackSettings'].getValues(),
	      fontSize,
	      cues = [];

	  for (; i < track['activeCues'].length; i++) {
	    cues.push(track['activeCues'][i]);
	  }

	  window['WebVTT']['processCues'](window, track['activeCues'], this.el_);

	  i = cues.length;
	  while (i--) {
	    cueDiv = cues[i].displayState;
	    if (overrides.color) {
	      cueDiv.firstChild.style.color = overrides.color;
	    }
	    if (overrides.textOpacity) {
	      tryUpdateStyle(cueDiv.firstChild,
	                     'color',
	                     constructColor(overrides.color || '#fff',
	                                    overrides.textOpacity));
	    }
	    if (overrides.backgroundColor) {
	      cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
	    }
	    if (overrides.backgroundOpacity) {
	      tryUpdateStyle(cueDiv.firstChild,
	                     'backgroundColor',
	                     constructColor(overrides.backgroundColor || '#000',
	                                    overrides.backgroundOpacity));
	    }
	    if (overrides.windowColor) {
	      if (overrides.windowOpacity) {
	        tryUpdateStyle(cueDiv,
	                       'backgroundColor',
	                       constructColor(overrides.windowColor, overrides.windowOpacity));
	      } else {
	        cueDiv.style.backgroundColor = overrides.windowColor;
	      }
	    }
	    if (overrides.edgeStyle) {
	      if (overrides.edgeStyle === 'dropshadow') {
	        cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
	      } else if (overrides.edgeStyle === 'raised') {
	        cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
	      } else if (overrides.edgeStyle === 'depressed') {
	        cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
	      } else if (overrides.edgeStyle === 'uniform') {
	        cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
	      }
	    }
	    if (overrides.fontPercent && overrides.fontPercent !== 1) {
	      fontSize = window.parseFloat(cueDiv.style.fontSize);
	      cueDiv.style.fontSize = (fontSize * overrides.fontPercent) + 'px';
	      cueDiv.style.height = 'auto';
	      cueDiv.style.top = 'auto';
	      cueDiv.style.bottom = '2px';
	    }
	    if (overrides.fontFamily && overrides.fontFamily !== 'default') {
	      if (overrides.fontFamily === 'small-caps') {
	        cueDiv.firstChild.style.fontVariant = 'small-caps';
	      } else {
	        cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
	      }
	    }
	  }
	};


	/**
	 * The specific menu item type for selecting a language within a text track kind
	 *
	 * @constructor
	 */
	vjs.TextTrackMenuItem = vjs.MenuItem.extend({
	  /** @constructor */
	  init: function(player, options){
	    var track = this.track = options['track'],
	        tracks = player.textTracks(),
	        changeHandler,
	        event;

	    if (tracks) {
	      changeHandler = vjs.bind(this, function() {
	        var selected = this.track['mode'] === 'showing',
	            track,
	            i,
	            l;

	        if (this instanceof vjs.OffTextTrackMenuItem) {
	          selected = true;

	          i = 0,
	          l = tracks.length;

	          for (; i < l; i++) {
	            track = tracks[i];
	            if (track['kind'] === this.track['kind'] && track['mode'] === 'showing') {
	              selected = false;
	              break;
	            }
	          }
	        }

	        this.selected(selected);
	      });
	      tracks.addEventListener('change', changeHandler);
	      player.on('dispose', function() {
	        tracks.removeEventListener('change', changeHandler);
	      });
	    }

	    // Modify options for parent MenuItem class's init.
	    options['label'] = track['label'] || track['language'] || 'Unknown';
	    options['selected'] = track['default'] || track['mode'] === 'showing';
	    vjs.MenuItem.call(this, player, options);

	    // iOS7 doesn't dispatch change events to TextTrackLists when an
	    // associated track's mode changes. Without something like
	    // Object.observe() (also not present on iOS7), it's not
	    // possible to detect changes to the mode attribute and polyfill
	    // the change event. As a poor substitute, we manually dispatch
	    // change events whenever the controls modify the mode.
	    if (tracks && tracks.onchange === undefined) {
	      this.on(['tap', 'click'], function() {
	        if (typeof window.Event !== 'object') {
	          // Android 2.3 throws an Illegal Constructor error for window.Event
	          try {
	            event = new window.Event('change');
	          } catch(err){}
	        }

	        if (!event) {
	          event = document.createEvent('Event');
	          event.initEvent('change', true, true);
	        }

	        tracks.dispatchEvent(event);
	      });
	    }
	  }
	});

	vjs.TextTrackMenuItem.prototype.onClick = function(){
	  var kind = this.track['kind'],
	      tracks = this.player_.textTracks(),
	      mode,
	      track,
	      i = 0;

	  vjs.MenuItem.prototype.onClick.call(this);

	  if (!tracks) {
	    return;
	  }

	  for (; i < tracks.length; i++) {
	    track = tracks[i];

	    if (track['kind'] !== kind) {
	      continue;
	    }

	    if (track === this.track) {
	      track['mode'] = 'showing';
	    } else {
	      track['mode'] = 'disabled';
	    }
	  }
	};

	/**
	 * A special menu item for turning of a specific type of text track
	 *
	 * @constructor
	 */
	vjs.OffTextTrackMenuItem = vjs.TextTrackMenuItem.extend({
	  /** @constructor */
	  init: function(player, options){
	    // Create pseudo track info
	    // Requires options['kind']
	    options['track'] = {
	      'kind': options['kind'],
	      'player': player,
	      'label': options['kind'] + ' off',
	      'default': false,
	      'mode': 'disabled'
	    };
	    vjs.TextTrackMenuItem.call(this, player, options);
	    this.selected(true);
	  }
	});

	vjs.CaptionSettingsMenuItem = vjs.TextTrackMenuItem.extend({
	  init: function(player, options) {
	    options['track'] = {
	      'kind': options['kind'],
	      'player': player,
	      'label': options['kind'] + ' settings',
	      'default': false,
	      mode: 'disabled'
	    };

	    vjs.TextTrackMenuItem.call(this, player, options);
	    this.addClass('vjs-texttrack-settings');
	  }
	});

	vjs.CaptionSettingsMenuItem.prototype.onClick = function() {
	  this.player().getChild('textTrackSettings').show();
	};

	/**
	 * The base class for buttons that toggle specific text track types (e.g. subtitles)
	 *
	 * @constructor
	 */
	vjs.TextTrackButton = vjs.MenuButton.extend({
	  /** @constructor */
	  init: function(player, options){
	    var tracks, updateHandler;

	    vjs.MenuButton.call(this, player, options);

	    tracks = this.player_.textTracks();

	    if (this.items.length <= 1) {
	      this.hide();
	    }

	    if (!tracks) {
	      return;
	    }

	    updateHandler = vjs.bind(this, this.update);
	    tracks.addEventListener('removetrack', updateHandler);
	    tracks.addEventListener('addtrack', updateHandler);

	    this.player_.on('dispose', function() {
	      tracks.removeEventListener('removetrack', updateHandler);
	      tracks.removeEventListener('addtrack', updateHandler);
	    });
	  }
	});

	// Create a menu item for each text track
	vjs.TextTrackButton.prototype.createItems = function(){
	  var items = [], track, tracks;

	  if (this instanceof vjs.CaptionsButton && !(this.player().tech && this.player().tech['featuresNativeTextTracks'])) {
	    items.push(new vjs.CaptionSettingsMenuItem(this.player_, { 'kind': this.kind_ }));
	  }

	  // Add an OFF menu item to turn all tracks off
	  items.push(new vjs.OffTextTrackMenuItem(this.player_, { 'kind': this.kind_ }));

	  tracks = this.player_.textTracks();

	  if (!tracks) {
	    return items;
	  }

	  for (var i = 0; i < tracks.length; i++) {
	    track = tracks[i];

	    // only add tracks that are of the appropriate kind and have a label
	    if (track['kind'] === this.kind_) {
	      items.push(new vjs.TextTrackMenuItem(this.player_, {
	        'track': track
	      }));
	    }
	  }

	  return items;
	};

	/**
	 * The button component for toggling and selecting captions
	 *
	 * @constructor
	 */
	vjs.CaptionsButton = vjs.TextTrackButton.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.TextTrackButton.call(this, player, options, ready);
	    this.el_.setAttribute('aria-label','Captions Menu');
	  }
	});
	vjs.CaptionsButton.prototype.kind_ = 'captions';
	vjs.CaptionsButton.prototype.buttonText = 'Captions';
	vjs.CaptionsButton.prototype.className = 'vjs-captions-button';

	vjs.CaptionsButton.prototype.update = function() {
	  var threshold = 2;
	  vjs.TextTrackButton.prototype.update.call(this);

	  // if native, then threshold is 1 because no settings button
	  if (this.player().tech && this.player().tech['featuresNativeTextTracks']) {
	    threshold = 1;
	  }

	  if (this.items && this.items.length > threshold) {
	    this.show();
	  } else {
	    this.hide();
	  }
	};

	/**
	 * The button component for toggling and selecting subtitles
	 *
	 * @constructor
	 */
	vjs.SubtitlesButton = vjs.TextTrackButton.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.TextTrackButton.call(this, player, options, ready);
	    this.el_.setAttribute('aria-label','Subtitles Menu');
	  }
	});
	vjs.SubtitlesButton.prototype.kind_ = 'subtitles';
	vjs.SubtitlesButton.prototype.buttonText = 'Subtitles';
	vjs.SubtitlesButton.prototype.className = 'vjs-subtitles-button';

	// Chapters act much differently than other text tracks
	// Cues are navigation vs. other tracks of alternative languages
	/**
	 * The button component for toggling and selecting chapters
	 *
	 * @constructor
	 */
	vjs.ChaptersButton = vjs.TextTrackButton.extend({
	  /** @constructor */
	  init: function(player, options, ready){
	    vjs.TextTrackButton.call(this, player, options, ready);
	    this.el_.setAttribute('aria-label','Chapters Menu');
	  }
	});
	vjs.ChaptersButton.prototype.kind_ = 'chapters';
	vjs.ChaptersButton.prototype.buttonText = 'Chapters';
	vjs.ChaptersButton.prototype.className = 'vjs-chapters-button';

	// Create a menu item for each text track
	vjs.ChaptersButton.prototype.createItems = function(){
	  var items = [], track, tracks;

	  tracks = this.player_.textTracks();

	  if (!tracks) {
	    return items;
	  }

	  for (var i = 0; i < tracks.length; i++) {
	    track = tracks[i];
	    if (track['kind'] === this.kind_) {
	      items.push(new vjs.TextTrackMenuItem(this.player_, {
	        'track': track
	      }));
	    }
	  }

	  return items;
	};

	vjs.ChaptersButton.prototype.createMenu = function(){
	  var tracks = this.player_.textTracks() || [],
	      i = 0,
	      l = tracks.length,
	      track, chaptersTrack,
	      items = this.items = [];

	  for (; i < l; i++) {
	    track = tracks[i];
	    if (track['kind'] == this.kind_) {
	      if (!track.cues) {
	        track['mode'] = 'hidden';
	        /* jshint loopfunc:true */
	        // TODO see if we can figure out a better way of doing this https://github.com/videojs/video.js/issues/1864
	        window.setTimeout(vjs.bind(this, function() {
	          this.createMenu();
	        }), 100);
	        /* jshint loopfunc:false */
	      } else {
	        chaptersTrack = track;
	        break;
	      }
	    }
	  }

	  var menu = this.menu;
	  if (menu === undefined) {
	    menu = new vjs.Menu(this.player_);
	    menu.contentEl().appendChild(vjs.createEl('li', {
	      className: 'vjs-menu-title',
	      innerHTML: vjs.capitalize(this.kind_),
	      tabindex: -1
	    }));
	  }

	  if (chaptersTrack) {
	    var cues = chaptersTrack['cues'], cue, mi;
	    i = 0;
	    l = cues.length;

	    for (; i < l; i++) {
	      cue = cues[i];

	      mi = new vjs.ChaptersTrackMenuItem(this.player_, {
	        'track': chaptersTrack,
	        'cue': cue
	      });

	      items.push(mi);

	      menu.addChild(mi);
	    }
	    this.addChild(menu);
	  }

	  if (this.items.length > 0) {
	    this.show();
	  }

	  return menu;
	};


	/**
	 * @constructor
	 */
	vjs.ChaptersTrackMenuItem = vjs.MenuItem.extend({
	  /** @constructor */
	  init: function(player, options){
	    var track = this.track = options['track'],
	        cue = this.cue = options['cue'],
	        currentTime = player.currentTime();

	    // Modify options for parent MenuItem class's init.
	    options['label'] = cue.text;
	    options['selected'] = (cue['startTime'] <= currentTime && currentTime < cue['endTime']);
	    vjs.MenuItem.call(this, player, options);

	    track.addEventListener('cuechange', vjs.bind(this, this.update));
	  }
	});

	vjs.ChaptersTrackMenuItem.prototype.onClick = function(){
	  vjs.MenuItem.prototype.onClick.call(this);
	  this.player_.currentTime(this.cue.startTime);
	  this.update(this.cue.startTime);
	};

	vjs.ChaptersTrackMenuItem.prototype.update = function(){
	  var cue = this.cue,
	      currentTime = this.player_.currentTime();

	  // vjs.log(currentTime, cue.startTime);
	  this.selected(cue['startTime'] <= currentTime && currentTime < cue['endTime']);
	};
	})();

	(function() {
	  'use strict';

	  vjs.TextTrackSettings = vjs.Component.extend({
	    init: function(player, options) {
	      vjs.Component.call(this, player, options);
	      this.hide();

	      vjs.on(this.el().querySelector('.vjs-done-button'), 'click', vjs.bind(this, function() {
	        this.saveSettings();
	        this.hide();
	      }));

	      vjs.on(this.el().querySelector('.vjs-default-button'), 'click', vjs.bind(this, function() {
	        this.el().querySelector('.vjs-fg-color > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-bg-color > select').selectedIndex = 0;
	        this.el().querySelector('.window-color > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-text-opacity > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-bg-opacity > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-window-opacity > select').selectedIndex = 0;
	        this.el().querySelector('.vjs-edge-style select').selectedIndex = 0;
	        this.el().querySelector('.vjs-font-family select').selectedIndex = 0;
	        this.el().querySelector('.vjs-font-percent select').selectedIndex = 2;
	        this.updateDisplay();
	      }));

	      vjs.on(this.el().querySelector('.vjs-fg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-bg-color > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.window-color > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-text-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-bg-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-window-opacity > select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-font-percent select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-edge-style select'), 'change', vjs.bind(this, this.updateDisplay));
	      vjs.on(this.el().querySelector('.vjs-font-family select'), 'change', vjs.bind(this, this.updateDisplay));

	      if (player.options()['persistTextTrackSettings']) {
	        this.restoreSettings();
	      }
	    }
	  });

	  vjs.TextTrackSettings.prototype.createEl = function() {
	    return vjs.Component.prototype.createEl.call(this, 'div', {
	      className: 'vjs-caption-settings vjs-modal-overlay',
	      innerHTML: captionOptionsMenuTemplate()
	    });
	  };

	  vjs.TextTrackSettings.prototype.getValues = function() {
	    var el, bgOpacity, textOpacity, windowOpacity, textEdge, fontFamily, fgColor, bgColor, windowColor, result, name, fontPercent;

	    el = this.el();

	    textEdge = getSelectedOptionValue(el.querySelector('.vjs-edge-style select'));
	    fontFamily = getSelectedOptionValue(el.querySelector('.vjs-font-family select'));
	    fgColor = getSelectedOptionValue(el.querySelector('.vjs-fg-color > select'));
	    textOpacity = getSelectedOptionValue(el.querySelector('.vjs-text-opacity > select'));
	    bgColor = getSelectedOptionValue(el.querySelector('.vjs-bg-color > select'));
	    bgOpacity = getSelectedOptionValue(el.querySelector('.vjs-bg-opacity > select'));
	    windowColor = getSelectedOptionValue(el.querySelector('.window-color > select'));
	    windowOpacity = getSelectedOptionValue(el.querySelector('.vjs-window-opacity > select'));
	    fontPercent = window['parseFloat'](getSelectedOptionValue(el.querySelector('.vjs-font-percent > select')));

	    result = {
	      'backgroundOpacity': bgOpacity,
	      'textOpacity': textOpacity,
	      'windowOpacity': windowOpacity,
	      'edgeStyle': textEdge,
	      'fontFamily': fontFamily,
	      'color': fgColor,
	      'backgroundColor': bgColor,
	      'windowColor': windowColor,
	      'fontPercent': fontPercent
	    };
	    for (name in result) {
	      if (result[name] === '' || result[name] === 'none' || (name === 'fontPercent' && result[name] === 1.00)) {
	        delete result[name];
	      }
	    }
	    return result;
	  };

	  vjs.TextTrackSettings.prototype.setValues = function(values) {
	    var el = this.el(), fontPercent;

	    setSelectedOption(el.querySelector('.vjs-edge-style select'), values.edgeStyle);
	    setSelectedOption(el.querySelector('.vjs-font-family select'), values.fontFamily);
	    setSelectedOption(el.querySelector('.vjs-fg-color > select'), values.color);
	    setSelectedOption(el.querySelector('.vjs-text-opacity > select'), values.textOpacity);
	    setSelectedOption(el.querySelector('.vjs-bg-color > select'), values.backgroundColor);
	    setSelectedOption(el.querySelector('.vjs-bg-opacity > select'), values.backgroundOpacity);
	    setSelectedOption(el.querySelector('.window-color > select'), values.windowColor);
	    setSelectedOption(el.querySelector('.vjs-window-opacity > select'), values.windowOpacity);

	    fontPercent = values.fontPercent;

	    if (fontPercent) {
	      fontPercent = fontPercent.toFixed(2);
	    }

	    setSelectedOption(el.querySelector('.vjs-font-percent > select'), fontPercent);
	  };

	  vjs.TextTrackSettings.prototype.restoreSettings = function() {
	    var values;
	    try {
	      values = JSON.parse(window.localStorage.getItem('vjs-text-track-settings'));
	    } catch (e) {}

	    if (values) {
	      this.setValues(values);
	    }
	  };

	  vjs.TextTrackSettings.prototype.saveSettings = function() {
	    var values;

	    if (!this.player_.options()['persistTextTrackSettings']) {
	      return;
	    }

	    values = this.getValues();
	    try {
	      if (!vjs.isEmpty(values)) {
	        window.localStorage.setItem('vjs-text-track-settings', JSON.stringify(values));
	      } else {
	        window.localStorage.removeItem('vjs-text-track-settings');
	      }
	    } catch (e) {}
	  };

	  vjs.TextTrackSettings.prototype.updateDisplay = function() {
	    var ttDisplay = this.player_.getChild('textTrackDisplay');
	    if (ttDisplay) {
	      ttDisplay.updateDisplay();
	    }
	  };

	  function getSelectedOptionValue(target) {
	    var selectedOption;
	    // not all browsers support selectedOptions, so, fallback to options
	    if (target.selectedOptions) {
	      selectedOption = target.selectedOptions[0];
	    } else if (target.options) {
	      selectedOption = target.options[target.options.selectedIndex];
	    }

	    return selectedOption.value;
	  }

	  function setSelectedOption(target, value) {
	    var i, option;

	    if (!value) {
	      return;
	    }

	    for (i = 0; i < target.options.length; i++) {
	      option = target.options[i];
	      if (option.value === value) {
	        break;
	      }
	    }

	    target.selectedIndex = i;
	  }

	  function captionOptionsMenuTemplate() {
	    return '<div class="vjs-tracksettings">' +
	        '<div class="vjs-tracksettings-colors">' +
	          '<div class="vjs-fg-color vjs-tracksetting">' +
	              '<label class="vjs-label">Foreground</label>' +
	              '<select>' +
	                '<option value="">---</option>' +
	                '<option value="#FFF">White</option>' +
	                '<option value="#000">Black</option>' +
	                '<option value="#F00">Red</option>' +
	                '<option value="#0F0">Green</option>' +
	                '<option value="#00F">Blue</option>' +
	                '<option value="#FF0">Yellow</option>' +
	                '<option value="#F0F">Magenta</option>' +
	                '<option value="#0FF">Cyan</option>' +
	              '</select>' +
	              '<span class="vjs-text-opacity vjs-opacity">' +
	                '<select>' +
	                  '<option value="">---</option>' +
	                  '<option value="1">Opaque</option>' +
	                  '<option value="0.5">Semi-Opaque</option>' +
	                '</select>' +
	              '</span>' +
	          '</div>' + // vjs-fg-color
	          '<div class="vjs-bg-color vjs-tracksetting">' +
	              '<label class="vjs-label">Background</label>' +
	              '<select>' +
	                '<option value="">---</option>' +
	                '<option value="#FFF">White</option>' +
	                '<option value="#000">Black</option>' +
	                '<option value="#F00">Red</option>' +
	                '<option value="#0F0">Green</option>' +
	                '<option value="#00F">Blue</option>' +
	                '<option value="#FF0">Yellow</option>' +
	                '<option value="#F0F">Magenta</option>' +
	                '<option value="#0FF">Cyan</option>' +
	              '</select>' +
	              '<span class="vjs-bg-opacity vjs-opacity">' +
	                  '<select>' +
	                    '<option value="">---</option>' +
	                    '<option value="1">Opaque</option>' +
	                    '<option value="0.5">Semi-Transparent</option>' +
	                    '<option value="0">Transparent</option>' +
	                  '</select>' +
	              '</span>' +
	          '</div>' + // vjs-bg-color
	          '<div class="window-color vjs-tracksetting">' +
	              '<label class="vjs-label">Window</label>' +
	              '<select>' +
	                '<option value="">---</option>' +
	                '<option value="#FFF">White</option>' +
	                '<option value="#000">Black</option>' +
	                '<option value="#F00">Red</option>' +
	                '<option value="#0F0">Green</option>' +
	                '<option value="#00F">Blue</option>' +
	                '<option value="#FF0">Yellow</option>' +
	                '<option value="#F0F">Magenta</option>' +
	                '<option value="#0FF">Cyan</option>' +
	              '</select>' +
	              '<span class="vjs-window-opacity vjs-opacity">' +
	                  '<select>' +
	                    '<option value="">---</option>' +
	                    '<option value="1">Opaque</option>' +
	                    '<option value="0.5">Semi-Transparent</option>' +
	                    '<option value="0">Transparent</option>' +
	                  '</select>' +
	              '</span>' +
	          '</div>' + // vjs-window-color
	        '</div>' + // vjs-tracksettings
	        '<div class="vjs-tracksettings-font">' +
	          '<div class="vjs-font-percent vjs-tracksetting">' +
	            '<label class="vjs-label">Font Size</label>' +
	            '<select>' +
	              '<option value="0.50">50%</option>' +
	              '<option value="0.75">75%</option>' +
	              '<option value="1.00" selected>100%</option>' +
	              '<option value="1.25">125%</option>' +
	              '<option value="1.50">150%</option>' +
	              '<option value="1.75">175%</option>' +
	              '<option value="2.00">200%</option>' +
	              '<option value="3.00">300%</option>' +
	              '<option value="4.00">400%</option>' +
	            '</select>' +
	          '</div>' + // vjs-font-percent
	          '<div class="vjs-edge-style vjs-tracksetting">' +
	            '<label class="vjs-label">Text Edge Style</label>' +
	            '<select>' +
	              '<option value="none">None</option>' +
	              '<option value="raised">Raised</option>' +
	              '<option value="depressed">Depressed</option>' +
	              '<option value="uniform">Uniform</option>' +
	              '<option value="dropshadow">Dropshadow</option>' +
	            '</select>' +
	          '</div>' + // vjs-edge-style
	          '<div class="vjs-font-family vjs-tracksetting">' +
	            '<label class="vjs-label">Font Family</label>' +
	            '<select>' +
	              '<option value="">Default</option>' +
	              '<option value="monospaceSerif">Monospace Serif</option>' +
	              '<option value="proportionalSerif">Proportional Serif</option>' +
	              '<option value="monospaceSansSerif">Monospace Sans-Serif</option>' +
	              '<option value="proportionalSansSerif">Proportional Sans-Serif</option>' +
	              '<option value="casual">Casual</option>' +
	              '<option value="script">Script</option>' +
	              '<option value="small-caps">Small Caps</option>' +
	            '</select>' +
	          '</div>' + // vjs-font-family
	        '</div>' +
	      '</div>' +
	      '<div class="vjs-tracksettings-controls">' +
	        '<button class="vjs-default-button">Defaults</button>' +
	        '<button class="vjs-done-button">Done</button>' +
	      '</div>';
	  }

	})();

	/**
	 * @fileoverview Add JSON support
	 * @suppress {undefinedVars}
	 * (Compiler doesn't like JSON not being declared)
	 */

	/**
	 * Javascript JSON implementation
	 * (Parse Method Only)
	 * https://github.com/douglascrockford/JSON-js/blob/master/json2.js
	 * Only using for parse method when parsing data-setup attribute JSON.
	 * @suppress {undefinedVars}
	 * @namespace
	 * @private
	 */
	vjs.JSON;

	if (typeof window.JSON !== 'undefined' && typeof window.JSON.parse === 'function') {
	  vjs.JSON = window.JSON;

	} else {
	  vjs.JSON = {};

	  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

	  /**
	   * parse the json
	   *
	   * @memberof vjs.JSON
	   * @param {String} text The JSON string to parse
	   * @param {Function=} [reviver] Optional function that can transform the results
	   * @return {Object|Array} The parsed JSON
	   */
	  vjs.JSON.parse = function (text, reviver) {
	      var j;

	      function walk(holder, key) {
	          var k, v, value = holder[key];
	          if (value && typeof value === 'object') {
	              for (k in value) {
	                  if (Object.prototype.hasOwnProperty.call(value, k)) {
	                      v = walk(value, k);
	                      if (v !== undefined) {
	                          value[k] = v;
	                      } else {
	                          delete value[k];
	                      }
	                  }
	              }
	          }
	          return reviver.call(holder, key, value);
	      }
	      text = String(text);
	      cx.lastIndex = 0;
	      if (cx.test(text)) {
	          text = text.replace(cx, function (a) {
	              return '\\u' +
	                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	          });
	      }

	      if (/^[\],:{}\s]*$/
	              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
	                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
	                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

	          j = eval('(' + text + ')');

	          return typeof reviver === 'function' ?
	              walk({'': j}, '') : j;
	      }

	      throw new SyntaxError('JSON.parse(): invalid or malformed JSON data');
	  };
	}

	/**
	 * @fileoverview Functions for automatically setting up a player
	 * based on the data-setup attribute of the video tag
	 */

	// Automatically set up any tags that have a data-setup attribute
	vjs.autoSetup = function(){
	  var options, mediaEl, player, i, e;

	  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
	  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
	  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
	  // var mediaEls = vids.concat(audios);

	  // Because IE8 doesn't support calling slice on a node list, we need to loop through each list of elements
	  // to build up a new, combined list of elements.
	  var vids = document.getElementsByTagName('video');
	  var audios = document.getElementsByTagName('audio');
	  var mediaEls = [];
	  if (vids && vids.length > 0) {
	    for(i=0, e=vids.length; i<e; i++) {
	      mediaEls.push(vids[i]);
	    }
	  }
	  if (audios && audios.length > 0) {
	    for(i=0, e=audios.length; i<e; i++) {
	      mediaEls.push(audios[i]);
	    }
	  }

	  // Check if any media elements exist
	  if (mediaEls && mediaEls.length > 0) {

	    for (i=0,e=mediaEls.length; i<e; i++) {
	      mediaEl = mediaEls[i];

	      // Check if element exists, has getAttribute func.
	      // IE seems to consider typeof el.getAttribute == 'object' instead of 'function' like expected, at least when loading the player immediately.
	      if (mediaEl && mediaEl.getAttribute) {

	        // Make sure this player hasn't already been set up.
	        if (mediaEl['player'] === undefined) {
	          options = mediaEl.getAttribute('data-setup');

	          // Check if data-setup attr exists.
	          // We only auto-setup if they've added the data-setup attr.
	          if (options !== null) {
	            // Create new video.js instance.
	            player = videojs(mediaEl);
	          }
	        }

	      // If getAttribute isn't defined, we need to wait for the DOM.
	      } else {
	        vjs.autoSetupTimeout(1);
	        break;
	      }
	    }

	  // No videos were found, so keep looping unless page is finished loading.
	  } else if (!vjs.windowLoaded) {
	    vjs.autoSetupTimeout(1);
	  }
	};

	// Pause to let the DOM keep processing
	vjs.autoSetupTimeout = function(wait){
	  setTimeout(vjs.autoSetup, wait);
	};

	if (document.readyState === 'complete') {
	  vjs.windowLoaded = true;
	} else {
	  vjs.one(window, 'load', function(){
	    vjs.windowLoaded = true;
	  });
	}

	// Run Auto-load players
	// You have to wait at least once in case this script is loaded after your video in the DOM (weird behavior only with minified version)
	vjs.autoSetupTimeout(1);

	/**
	 * the method for registering a video.js plugin
	 *
	 * @param  {String} name The name of the plugin
	 * @param  {Function} init The function that is run when the player inits
	 */
	vjs.plugin = function(name, init){
	  vjs.Player.prototype[name] = init;
	};

	/* jshint ignore:end */
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var Html5PlayerObj = __webpack_require__(8);//html5 player framework
	var Html5IosPlayerObj = __webpack_require__(13);//iOS inline video player framework
	var FlashPlayerObj = __webpack_require__(19);
	var VideoSizeHandler = __webpack_require__(20);
	var Utils = __webpack_require__(9);

	var prefixOfLog = "PlayerManager_BuildPlayer";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };

	var buildPlayer = function (_callbackForAdUnit, _options, playerManager) {


	    debug("buildPlayer");
	    var triggerCheckingMouseLeave;

	    //join parameter and object in outside of this object
	    var options = _options;

	    var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);

	    var isMobile = function () {
	        var index = navigator.appVersion.indexOf("Mobile");
	        var indexForAndroid = navigator.appVersion.indexOf("Android");
	        return (index > -1) || (indexForAndroid > -1);
	    };

	    var isIOS = function () {
	        var indexForIOS = /iPad|iPhone|iPod/.test(navigator.appVersion);
	        return indexForIOS;
	    };


	    //define and set default options by parameters
	    var setDefaultOptions = function (_options) {

	        _options.nativeControlsForTouch = false;
	        _options.controls = true;
	        _options.preload = "auto";

	        if (!_options.extensions) {
	            _options.extensions = '';
	        }

	        VideoSizeHandler.setSizeForInitialRender(_options);


	        if (isIOS()) {
	            if (_options.sideStream && _options.sideStream.enabled === false) {//side options should be allowed for iOS
	                _options.nonViewableBehavior = "pause";
	            }
	        }

	        switch (_options.initialPlayback) {
	            case "auto":
	                _options.autoplay = false;
	                break;
	            case "click":
	                _options.autoplay = false;
	                break;
	            case "mouseover":
	                _options.autoplay = false;
	                break;
	            default:

	        }

	        if (!_options.hasOwnProperty("disableTopBar")) {
	            _options.disableTopBar = false;
	        }

	        //define communicator with flash
	        _options.communicator = playerManager.externalNameOfVideoPlayer;

	        if (Utils.isAndroid()) {
	            _options.controlBarPosition = "below";
	        }

	        return _options;
	    };


	    //set required default value
	    options = setDefaultOptions(options);

	    if (options.initialAudio === "off") {
	        playerManager.isMuted = true;
	    }

	    //set default swf if it doesn't have
	    options.flash = options.flash ? options.flash : {swf: "http://video.devnxs.net/players/flash/AppnexusFlashPlayer.swf"};


	    playerManager.options = options;


	    //callback for inject event to player : player should returen element of itself
	    var cbInjectEventToPlayer = function (el_wholeArea, el_videoArea) {


	        //set playOnMouseover
	        if (options.playOnMouseover === true) {

	            var _tmpMouseoverListenerForce = function () {
	                if (playerManager.isDoneInitialPlay === true && !playerManager.explicitPaused && playerManager.isViewable && playerManager.isPlayingVideo === false) {
	                    playerManager.play();
	                }
	            };
	            var _tmpMouseOutListenerForce = function () {
	                playerManager.pause();
	            };
	            el_wholeArea.addEventListener("mouseenter", _tmpMouseoverListenerForce);
	            el_wholeArea.addEventListener("mouseleave", _tmpMouseOutListenerForce);

	        }

	        //set audioOnMouseover
	        if (options.audioOnMouseover !== false) {
	            var unmuteTimeout = 0;
	            var unmuteTimeoutFn;
	            if (typeof options.audioOnMouseover === "number") {
	                unmuteTimeout = options.audioOnMouseover;
	            }

	            var _tmpMouseoutListenerForceAudio = function () {
	                if (!playerManager.isFullscreen && playerManager.isDoneInitialPlay) {
	                    clearTimeout(unmuteTimeoutFn);
	                    playerManager.mute();
	                    el_wholeArea.removeEventListener("mouseleave", _tmpMouseoutListenerForceAudio);
	                }
	            };

	            var _tmpMouseoverListenerForceAudio = function () {
	                if (!playerManager.isFullscreen && playerManager.isDoneInitialPlay && !playerManager.mutedByViewability) {
	                    unmuteTimeoutFn = setTimeout(function () {
	                        playerManager.unmute();
	                    }, unmuteTimeout);
	                }
	                el_wholeArea.addEventListener("mouseleave", _tmpMouseoutListenerForceAudio, false);
	            };


	            //this shouldn't be invoked when it's iOS because it doesn't have mouse(for some reason, browsing out will cause mouseenter event in mobile Safari browser)
	            if (!isIosInlineRequired()) {

	                triggerCheckingMouseLeave = setInterval(function () {
	                    if (playerManager && playerManager.isFullscreen && _tmpMouseoutListenerForceAudio && el_wholeArea) {
	                        el_wholeArea.removeEventListener("mouseleave", _tmpMouseoutListenerForceAudio);
	                    }
	                }, 500);

	                el_wholeArea.addEventListener("mouseenter", _tmpMouseoverListenerForceAudio, false);
	            }
	        }

	        //set resposive behavior on desktop for VID-1080
	        //mobile already has this feature so we handles it only for desktop
	        //also this should work for VID3 and VID2
	        //special case : if autoInitialSize is false and a width doesn't have a value then a behavior of this will work like autoInitialSize=true, this case is declared at ExtendDefaultOption.js
	        if (options.autoInitialSize && !isMobile()) {
	            window.addEventListener("resize", function () {

	                //for VID-1898 going to fullscreen on flash caused window resize on several OS, and it can interfere with CSS of outstreae like sidestream case, also it actually makes sense to not resize video if it's in fullscreen on Flash
	                //as a result if sideStream is enabled we don't need to resize video by window.resize event.
	                var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStreamObject && typeof(playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	                if (shouldNotResizeWhenSideStreamActivated) {
	                    return;
	                }


	                if (options.targetElement && options.targetElement.style && options.targetElement.style.height && Number(options.targetElement.style.height.replace("px", "")) === 0) {//returns only when collapse for VID-2149
	                    //initial target element height : 0.1px which is required to avoid the blocking flash on chrome.
	                    //target element height after collsapse : 0px
	                    return;//don't need to resize if video is already collapsed
	                }

	                setTimeout(function () {
	                    if (!options.disableCollapse && (playerManager.isSkipped || playerManager.isCompleted)) {
	                        return;
	                    }
	                    options.width = options.targetElement.offsetWidth;

	                    var isAndroid = (/android/i.test(navigator.userAgent.toLowerCase()));
	                    if (isAndroid) {
	                        //for android4
	                        options.targetElement.style.webkitTransition = "height 0s ease";
	                    } else {
	                        //for most of modern browser
	                        options.targetElement.style.transition = "height 0s ease";
	                    }

	                    playerManager.resizeVideo(-1);
	                    options.targetElement.style.height = options.height + "px";
	                    var videoObject = document.getElementById(playerManager.videoObjectId);
	                    if (videoObject && typeof videoObject !== undefined) {
	                        videoObject.style.width = options.width;
	                        videoObject.style.height = options.height;
	                    }

	                    setTimeout(function () {
	                        var convertToSeconds = function (ms) {
	                            if (ms < 0) {
	                                return 0;
	                            }
	                            return ms / 1000;
	                        };
	                        var animationSpeed = convertToSeconds(options.expandTime);
	                        animationSpeed = (animationSpeed <= 0) ? 0.001 : animationSpeed;//because if it's under zero, transitionEnd event is not reliable
	                        if (isAndroid) {
	                            //for android4
	                            options.targetElement.style.webkitTransition = "height " + animationSpeed + "s ease";
	                        } else {
	                            //for most of modern browser
	                            options.targetElement.style.transition = "height " + animationSpeed + "s ease";
	                        }
	                    }, 500);


	                }, 0);//we have to use this timer to avoid timing issue on Safari

	            });
	        }


	        if (playerManager.decidePlayer(options.requiredPlayer) === 'flash') {

	            el_wholeArea.addEventListener("mouseenter", function () {
	                playerManager.mouseIn();
	            });
	            el_wholeArea.addEventListener("mouseleave", function () {
	                playerManager.mouseOut();
	            });

	        }

	        //define click event
	        el_wholeArea.style.cursor = "pointer";

	        if (el_videoArea && el_videoArea !== undefined) {

	            //handle click to browse out
	            el_videoArea.onclick = function () {

	                // For JS VPAID Ads rely on AdClickThru event sent by the creative.
	                if (playerManager.decidePlayer(options.requiredPlayer) === "html5" && !options.vpaid) {
	                    if (options.learnMore.enabled === true) {
	                        if (options.learnMore.clickToPause === true) {
	                            if (playerManager.isPlayingVideo) {
	                                playerManager.explicitPause();
	                            } else {
	                                playerManager.explicitPlay();
	                            }
	                        }
	                    } else {
	                        playerManager.click();
	                    }
	                }
	            };
	        }


	        //for VID-2742 some of elements which are not used for native player now has interfered with proper rendering on iOS10 and small devices
	        //it may be a bug on iOS10 because iOS8 and iOS9 doesn't have this problem. this is for VID-2742

	        var hasCustomPlayerSkin = playerManager.options && playerManager.options.playerSkin && playerManager.options.playerSkin.customPlayerSkin;
	        if (isIOS() && playerManager.overlayPlayer && playerManager.options && playerManager.options.enableInlineVideoForIos === false && hasCustomPlayerSkin) {

	            playerManager.adVideoPlayer.controlBar.fullscreenToggle.dispose();

	            //experemental to improve more for resolving 1px moving up
	            //why this required? : even if we performed above remedy, video is still moving about 1px up so we have to re-render conrolbar where has critical part caused this issue.
	            playerManager.adVideoPlayer.one("playing",function() {//only one time! - this issue hapens only first time when we play the video, so no need to do again
	                playerManager.adVideoPlayer.controlBar.el().style.display = "none";//for re-drawing element
	                setTimeout(function() {
	                    playerManager.adVideoPlayer.controlBar.el().style.display = "block";//for re-drawing element
	                },7000);//7000ms is the time iOS10 re-renders (moving element up) after playing a video for some unknown reason on the browser
	            });
	        }
	    };


	    switch (playerManager.decidePlayer(options.requiredPlayer)) {
	        case "html5":
	            //activate new inline video for iOS if only "enableInlineVideoForIos" is true
	            if (isIosInlineRequired()) {
	                new Html5IosPlayerObj(playerManager, cbInjectEventToPlayer).start();
	            } else {
	                new Html5PlayerObj(playerManager, cbInjectEventToPlayer).start();
	            }
	            break;
	        case "flash":
	            FlashPlayerObj(playerManager, cbInjectEventToPlayer);
	            break;
	        default:
	    }






	};


	module.exports = buildPlayer;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	//declare module
	var utils = __webpack_require__(9);
	var _logger = __webpack_require__(2);

	var info = function (message) {
	    _logger.info("Video Player: " + message);
	};

	/**
	 * Html5Player
	 * At the end of this process, it will invoke "callbackForAdUnit.cbWhenReady" to continute a flow of video player this is asynchoronous action and Outstream will wait this callback to start doing something (expanding...)
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 */
	module.exports = function (playerManager, cbInjectEventToPlayer) {

	    var html5PlayerSelf = this;

	    this.options = playerManager.options;//getting required object from adVideoPlayerManager
	    this.an_video_ad_player_id = "";
	    this.an_video_ad_player_html5_api_id = "";
	    this.targetElement = "";
	    this.videojsOrigin = playerManager.videoPlayerObj;
	    this.dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
	    this.callbackForAdUnit = playerManager.callbackForAdUnit;
	    this.topChromeHeight = 24;
	    this.pendingFullscreenExit = false;//there is a 1000ms timeout between pressing the exit fullscreen icon and the status being updated in the player,mthis variable will let us know this is the case, since a lot happens in those ms
	    this.bigbuttonUnmuteTimeout = 250; // videojs takes a while to sync mute, so we wait 250ms for safari
	    this.CONST_MESSAGE_GENERAL_ERROR = "General error reported from HTML5 video player";//const variables

	    //redefine utitlity function to have backward compatibility
	    this.isIos = utils.isIos;
	    this.isAndroid = utils.isAndroid;
	    this.isMobile = utils.isMobile;
	    this.refreshVideoLookAndFeel = utils.refreshVideoLookAndFeel;


	    this.start = function () {
	        info("WE ARE USING HTML5 PLAYER");
	        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);//define iframe's uniqueu id

	        //override options
	        html5PlayerSelf.options.techOrder = ["html5"];//force to use html5 for video.js because flash will be handled by diffrent swf owned by us
	        html5PlayerSelf.options.iframeVideoWrapperId = "iframeVideoWrapper_" + UID;

	        //set flasg
	        html5PlayerSelf.an_video_ad_player_id = "an_video_ad_player_" + UID;
	        html5PlayerSelf.an_video_ad_player_html5_api_id = "an_video_ad_player_" + UID + "_html5_api";
	        html5PlayerSelf.targetElement = html5PlayerSelf.options.targetElement;

	        html5PlayerSelf.createIframe(html5PlayerSelf.fnMainProcess);//execute main process after create iframe
	    };
	    this.displayVolumeControls = function () {
	        if (html5PlayerSelf.isAndroid()) {
	            if (typeof html5PlayerSelf.options.enableAndroidVolumeControls === "boolean" && html5PlayerSelf.options.enableAndroidVolumeControls === true) {
	                return true;
	            } else {
	                return false;
	            }
	        } else {
	            return true;
	        }
	    };

	    this.createIframe = __webpack_require__(10)(html5PlayerSelf,playerManager).createIframe;
	    this.fnMainProcess = __webpack_require__(11)(html5PlayerSelf,playerManager,cbInjectEventToPlayer).fnMainProcess;

	};



/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Utility class
	 */

	var prefixOfLog = "PlayerManager_Utils";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };


	var isIphone = function () {
	    var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	};

	var isIos = function () {
	    var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	};

	var isAndroid = function () {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	};

	var isMobile = function () {
	    return navigator.appVersion.indexOf("Mobile") > -1 || navigator.appVersion.indexOf("Android") > -1;
	};

	var getIOSVersion = function() {
	    var match =navigator.userAgent.match(/OS (\d+)_/i);
	    if (match && match[1]) {
	        return match[1];
	    }
	};

	var refreshVideoLookAndFeel = function (options, playerManager) {

	    if (playerManager.isSkipped || !playerManager.isExpanded) {
	        return;
	    }

	    if (options.autoInitialSize) {
	        options.width = options.targetElement.offsetWidth;
	    }
	    playerManager.resizeVideo(-1, isMobile());
	    options.targetElement.style.height = options.height + "px";
	};


	var fireEvent = function (obj, eventName) {
	    var event = document.createEvent("HTMLEvents");
	    event.initEvent(eventName, true, true);
	    event.eventName = eventName;
	    obj.dispatchEvent(event);
	};


	//rules regards VID-1529
	/*
	 1.Callback(VAST) : should suppress all callback related to tracking
	 2.Callback(VPAID) : don't suppress followings (which is not related to tracking or report in VAST)
	 AdLoaded
	 AdStarted
	 AdStopped
	 AdSkippableStateChange
	 AdLinearChange
	 AdDurationChange
	 AdRemainingTimeChange
	 AdLog
	 AdError
	 3.Callback(AdUnit) : don't suppressed
	 4.Tracking url : should suppress
	 5.eventCB for AST : don't suppressed
	 */
	/**
	 * Utility class for handling late invoking, orignally made for VID-1505
	 * structure : FIFO (First in - First out)
	 * @constructor
	 */
	var DelayEventHandler = function () {
	    this.queue = [];
	    this.id = "";
	    this.isSuppress = false;
	    this.isPaused = false;
	    this.isCompleted = false;

	    var timerInterval = 100;
	    var ignoreNextQueue = false;

	    /**
	     * push function or event
	     * @param cb
	     */
	    this.push = function (cb) {

	        if (this.isSuppress === false && typeof cb === 'function') {
	            cb();
	            return;
	        }

	        if (ignoreNextQueue) {
	            ignoreNextQueue = false;//TODO can occur concurrent issue but it's okay for usage of JSVPAIDConfigure.js
	            return;
	        }

	        if (this.isPaused === false) {
	            this.queue.push(cb);
	        }
	    };

	    /**
	     * start timer to consume this queue
	     */
	    this.start = function () {
	        debug("delay event starts");
	        var delayEventHandler = this;
	        var pullAndInvoke = function () {
	            if (delayEventHandler.isSuppress === false) {
	                var cb = delayEventHandler.queue.shift();
	                if (cb && typeof(cb) === "function") {
	                    cb();
	                }
	            }
	            setTimeout(function () {
	                if (delayEventHandler.isCompleted === false) {
	                    pullAndInvoke();//recursion until video is completed
	                }
	            }, timerInterval);
	        };
	        pullAndInvoke();
	    };

	    /**
	     * Immediate stop the timer
	     * @constructor
	     */
	    this.ImmediateStop = function () {
	        this.isCompleted = true;
	    };

	    /**
	     * push a function to stop the timer, the timer will stop when it's order
	     */
	    this.lazyTerminate = function () {
	        var delayEventHandler = this;
	        var cb = function () {
	            delayEventHandler.ImmediateStop();
	        };
	        this.queue.push(cb);
	    };

	    /**
	     * method to release suppressed functions or events
	     * @param o
	     */
	    this.suppress = function (o) {
	        this.isSuppress = o;
	    };

	    /**
	     * clear queue for Waterfall project
	     */
	    this.clearQueue = function () {
	        this.queue = [];
	    };

	    this.ignoreNextQueue = function () {
	        ignoreNextQueue = true;
	    };
	};


	var isEmpty = function (obj) {
	    return (typeof(obj) === "undefined" || obj === "" || obj === false || obj === null) ? true : false;
	};

	var unique = function () {
	    var uniqueObject = {};//clousure, uniqueObject in sub function will point this in runtime
	    return {
	        pushAndCheck: function (key_, str_) {
	            var key = key_ + "_" + str_;
	            if (!uniqueObject[key]) {
	                uniqueObject[key] = true;
	                return true;
	            } else {
	                return false;
	            }
	        }
	    };
	};


	var isNumeric = function (n) {
	    var result = false;
	    try {
	        result = !isNaN(parseFloat(n)) && isFinite(n);
	    } catch(ex) {
	        debug(ex);
	    }
	    return result;
	};


	var getMsecTime = function(strTime, duration) {
	    try {
	        var nPos = strTime.indexOf('%');
	        if (nPos > 0) {
	            if (duration && duration > 0) {
	                var _tmpPerc = Number(strTime.substring(0, nPos));
	                if (_tmpPerc >= 0 && _tmpPerc <= 100) {
	                    return Math.round(duration * (_tmpPerc / 100));//apply duration to this calculation
	                } else {
	                    return -1;
	                }
	            }
	            else {
	                return -1;
	            }
	        } else {
	            nPos = strTime.indexOf('.');
	            var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1).substr(0,3)) : 0;//only allow 3 digit of under 0
	            if (nPos > 0) {
	                strTime = strTime.substring(0, nPos);
	            }
	            var arr = strTime.split(':');
	            if (arr.length === 3) {
	                for (var _tmp = 0; _tmp < arr.length; _tmp++) {
	                    var token = arr[_tmp];
	                    if (token && isNumeric(token) === false || Number.parseInt(token) < 0) {//handle inacceptable values as -1
	                        return -1;
	                    }
	                }
	                var result = (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
	                if (result <= duration) {
	                    return result;
	                } else {
	                    return -1;
	                }
	            } else {
	                return -1;
	            }
	        }
	    } catch (ex) {
	        debug(ex);
	        return -1;
	    }
	};


	module.exports = {
	    isIphone: isIphone,
	    isIos: isIos,
	    isAndroid: isAndroid,
	    isMobile: isMobile,
	    getIOSVersion: getIOSVersion,
	    refreshVideoLookAndFeel: refreshVideoLookAndFeel,
	    fireEvent: fireEvent,
	    DelayEventHandler: DelayEventHandler,
	    isEmpty: isEmpty,
	    unique: unique,
	    getMsecTime: getMsecTime,
	    isNumeric: isNumeric
	};




/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(2);
	var log = function (message) {
	    _logger.log("Video Player: " + message);
	};
	var debug = function (message) {
	    _logger.debug("Video Player: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("Video Player: " + message);
	};

	/**
	 * InitializeElements
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @returns {{createIframe: "createIframe"}}
	 */
	module.exports = function (html5PlayerSelf, playerManager) {

	    return {
	        "createIframe": function (callback) {

	            log("createIframe");

	            var iframeVideoWrapper;
	            var found = false;


	            if (playerManager.autoplayHandler.isRequiredFakeAndroidAutoStart(html5PlayerSelf.options.initialPlayback, html5PlayerSelf.options.initialAudio, html5PlayerSelf.options.automatedTestingOnlyAndroidSkipTouchStart, true)) {
	                verbose("Setting correct iframe for androids 'fake' autostart");
	                var iframes = html5PlayerSelf.options.targetElement.getElementsByTagName("iframe");
	                for (var i = 0; i < iframes.length; i++) {
	                    var iframe = iframes[i];
	                    var name = playerManager.autoplayHandler.APN_MOBILE_IFRAME_NAME;
	                    if (html5PlayerSelf.isAndroid() && html5PlayerSelf.options.firstAdAttempted && html5PlayerSelf.options.adAttempt) {
	                        name = playerManager.autoplayHandler.APN_MOBILE_IFRAME_NAME + "_Waterfall_" + html5PlayerSelf.options.adAttempt;
	                    }
	                    if (iframes && iframe.name && iframe.name === name) {
	                        found = true;
	                        iframeVideoWrapper = iframe;
	                        break;
	                    }
	                }
	            }

	            if (!found) {
	                verbose("Creating new iframe if one is not already created.");
	                iframeVideoWrapper = document.createElement("iframe");
	                iframeVideoWrapper.src = "about:blank";
	                html5PlayerSelf.targetElement.appendChild(iframeVideoWrapper);


	                //VIDLA-90 fix IAS viewability tracking issue to have proper Iframe.location.origin
	                //var defaultTemplate = "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body style=\"margin:0px;overflow:hidden;\">\n</body>\n</html>\n";
	                var defaultTemplate = "<html></html>";//fix VIDLA-320 to have null doctype like we did before - it means this is the same with not invoking .write("") like we did at the begining of this project

	                iframeVideoWrapper.contentWindow.document.open();
	                iframeVideoWrapper.contentWindow.document.write(defaultTemplate);
	                iframeVideoWrapper.contentWindow.document.close();

	            }

	            //generate iframe
	            iframeVideoWrapper.id = html5PlayerSelf.options.iframeVideoWrapperId;
	            iframeVideoWrapper.style.width = html5PlayerSelf.options.width + "px";
	            iframeVideoWrapper.style.height = html5PlayerSelf.options.height + "px";
	            iframeVideoWrapper.style.display = "";
	            //TODO: maybe set all of these to initial, but IE does not support so maybe not
	            //iframeVideoWrapper.id = "iframeVideoWrapper";

	            //allow fullscreen in iframe
	            iframeVideoWrapper.setAttribute("allowfullscreen", "true");
	            iframeVideoWrapper.setAttribute("webkitallowfullscreen", "true");
	            iframeVideoWrapper.setAttribute("mozallowfullscreen", "true");

	            var handleCallback = function () {

	                var IframeDocument = iframeVideoWrapper.contentWindow.document;
	                var IframeWindow = iframeVideoWrapper.contentWindow.window;


	                //create top chrome bar
	                debug("Creating and styling top chrome bar");
	                var topChrome = IframeDocument.createElement("div");
	                topChrome.id = "top_chrome";
	                topChrome.style.height = (function () {
	                    if (html5PlayerSelf.options.playerSkin && typeof html5PlayerSelf.options.playerSkin.dividerHeight === "number") {
	                        return html5PlayerSelf.topChromeHeight - html5PlayerSelf.options.playerSkin.dividerHeight + "px";
	                    }
	                    // in order to keep the top chrome 24 px, we subtract the width of the divider
	                    // (default of 1px) from the height of the chrome bar
	                    return html5PlayerSelf.topChromeHeight - 1 + "px";
	                })();
	                topChrome.style.width = html5PlayerSelf.options.width + "px";
	                topChrome.style.marginRight = "auto";
	                topChrome.style.marginLeft = "auto";
	                topChrome.className = "video-js vjs-default-skin";

	                //generate video object
	                debug("Generating and styling video object");
	                var videoEl;
	                var found = false;

	                if (playerManager.autoplayHandler.isRequiredFakeAndroidAutoStart(html5PlayerSelf.options.initialPlayback, html5PlayerSelf.options.initialAudio, html5PlayerSelf.options.automatedTestingOnlyAndroidSkipTouchStart, true)) {

	                    var prebuiltVideo = iframeVideoWrapper.contentWindow[playerManager.autoplayHandler.APN_MOBILE_VIDEO_PLACEMENT_ID];
	                    if (prebuiltVideo) {
	                        found = true;
	                        videoEl = prebuiltVideo;//override video object to resolve autoplay issue on Android
	                    }

	                }

	                if (!found) {
	                    videoEl = IframeDocument.createElement("video");
	                }

	                videoEl.id = html5PlayerSelf.an_video_ad_player_id;
	                videoEl.className = "video-js vjs-default-skin";
	                videoEl.style.marginRight = "auto";
	                videoEl.style.marginLeft = "auto";

	                topChrome.style["z-index"] = videoEl.style["z-index"] + 1;


	                //add condtition to figure out video.js problem in high latency network - video.js doesn't load video in high latency netowrk if we pass this source so that setting src should be done after video.js initalized
	                //generate source object
	                if (html5PlayerSelf.options.vpaid === false) {
	                    debug("Generating source object");
	                    var mp4Source = IframeDocument.createElement("source");
	                    mp4Source.type = html5PlayerSelf.options.video.type;
	                    mp4Source.src = html5PlayerSelf.options.videoUrl;
	                    if (!html5PlayerSelf.options.vpaid) {
	                        videoEl.appendChild(mp4Source);
	                    }
	                }


	                //inject required object into iframe
	                debug("Injecting required elements into iframe");
	                if (!html5PlayerSelf.options.disableTopBar) {
	                    IframeDocument.body.appendChild(topChrome);
	                    //topChrome.appendChild(customDivider);
	                }

	                IframeDocument.body.appendChild(videoEl);
	                IframeWindow.videojs = html5PlayerSelf.videojsOrigin;

	                if (html5PlayerSelf.options.vpaid) {
	                    //inject javascript vpaid module to iframe
	                    var videojsVpaidScript = IframeDocument.createElement("script");
	                    videojsVpaidScript.innerHTML = playerManager.videojs_vpaid;
	                    IframeDocument.head.appendChild(videojsVpaidScript);
	                }


	                IframeDocument.body.style.margin = "0px";
	                IframeDocument.body.style.overflow = "hidden";
	                callback(iframeVideoWrapper);

	            };


	            var isCompletedHandleCallbcak = false;
	            var is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	            if (is_firefox && playerManager.overlayPlayer === false) {
	                iframeVideoWrapper.onload = function () {
	                    handleCallback();
	                    isCompletedHandleCallbcak = true;
	                };
	                //for Outstream + Firefox combination, adunit will be terminated in vpaid timeout if window.load event is not delivered.
	                setTimeout(function() {
	                    if (isCompletedHandleCallbcak === false) {
	                        verbose("destroying due to an error in firefox");
	                        playerManager.destroyWithoutSkip(true, html5PlayerSelf.CONST_MESSAGE_GENERAL_ERROR, null, 900);
	                    }
	                },html5PlayerSelf.options.vpaidTimeout);
	            } else {
	                handleCallback();
	            }

	        },
	    };
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var utils = __webpack_require__(9);
	var JSVPAIDConfigure = __webpack_require__(12);
	var _logger = __webpack_require__(2);

	var error = function (message) {
	    _logger.error("Video Player: " + message);
	};
	var log = function (message) {
	    _logger.log("Video Player: " + message);
	};
	var debug = function (message) {
	    _logger.debug("Video Player: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("Video Player: " + message);
	};

	/**
	 * Events
	 * @param html5PlayerSelf
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 * @returns {{fnMainProcess: "fnMainProcess"}}
	 */
	module.exports = function (html5PlayerSelf, playerManager, cbInjectEventToPlayer) {
	    return {
	        "fnMainProcess": function (iframeVideoWrapper) {
	            /**
	             * this method for customizing video.js player by its own API
	             * @param iframeVideoWrapper
	             */


	            log("fnMainProcess");

	            //video object in iframe
	            var an_html5_video_object = iframeVideoWrapper.contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
	            playerManager.iframeVideoWrapper = iframeVideoWrapper;

	            //activate JSVPAID plug-in this should be actiavated before video.js intialized
	            if (html5PlayerSelf.options.vpaid) {
	                try {
	                    JSVPAIDConfigure(playerManager);
	                } catch (ex) {
	                    error(ex);
	                }
	            } else {
	                //Cleanup previous plugin reference.
	                //VID-2023 Specific waterfall placement times out due to error on IE and Edge browsers on PC
	                if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.plugins) {
	                    html5PlayerSelf.options.plugins = null;
	                }
	            }


	            var customizeVideoJS = function (videojsPlayer) {

	                debug("Customizing Video JS");

	                //TODO for debugging
	                // window.debugPlayerAN = videojsPlayer;
	                playerManager.adVideoPlayer = videojsPlayer;

	                html5PlayerSelf.options.nativeControlsForTouch = false;
	                html5PlayerSelf.options.customControlsOnMobile = false;

	                //TODO for researching mobile features
	                if (html5PlayerSelf.isMobile()) {
	                    videojsPlayer.enableTouchActivity();
	                }

	                //custom skinning
	                playerManager.customSkinning.render(html5PlayerSelf, videojsPlayer, iframeVideoWrapper.contentWindow.document, false);

	                //setup html5 video player by html5PlayerSelf.options coming from impbus or publisher's site
	                (function () {

	                    if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.vpaid) {
	                        //For vpaid ads in waterfall hide controls untill the impression occurs to avoid flicker during failed attempts.
	                        videojsPlayer.controlBar.hide();
	                        if (html5PlayerSelf.options.firstAdAttempted) {
	                            videojsPlayer.bigPlayButton.hide();
	                        }
	                    }

	                    //disable scrubbing
	                    verbose("disabling scrubbing");
	                    videojsPlayer.controlBar.progressControl.seekBar.off("mousedown");
	                    videojsPlayer.controlBar.progressControl.seekBar.off("touchstart");
	                    videojsPlayer.controlBar.progressControl.seekBar.off("click");

	                    verbose("setting initial audio");
	                    if (html5PlayerSelf.options.initialAudio === "off") {
	                        videojsPlayer.muted(true);
	                        playerManager.isMuted = true;
	                    } else {
	                        videojsPlayer.muted(false);
	                        playerManager.isMuted = false;
	                    }

	                    //set mouseover to play video option
	                    verbose("setting initial playback");
	                    if (html5PlayerSelf.options.initialPlayback === "mouseover") {

	                        var _tmpMouseoverListener = function () {
	                            playerManager.play();
	                            videojsPlayer.el().removeEventListener("mouseover", _tmpMouseoverListener);
	                        };
	                        videojsPlayer.el().addEventListener("mouseover", _tmpMouseoverListener);
	                    }

	                    //set maintainAspectRatio
	                    verbose("setting aspect ratio"); //this doesn't do anything, remove?
	                    if (html5PlayerSelf.options.maintainAspectRatio === true) {
	                    } else {
	                    }

	                    var isMuteNeeded = function () {
	                        return (html5PlayerSelf.options.showMute === true && (html5PlayerSelf.displayVolumeControls() || html5PlayerSelf.isAndroid()));
	                    };

	                    //set showVolume
	                    if (html5PlayerSelf.options.showVolume === false || !html5PlayerSelf.displayVolumeControls()) {
	                        verbose("removing volume controls");
	                        videojsPlayer.controlBar.volumeControl.dispose();
	                    }

	                    if (html5PlayerSelf.options.showPlayToggle === false) {
	                        videojsPlayer.controlBar.playToggle.hide();
	                    }

	                    if (html5PlayerSelf.options.showBigPlayButton === false) {
	                        videojsPlayer.bigPlayButton.hide();
	                    }

	                    //set showMute
	                    if (isMuteNeeded()) {
	                        verbose("setting mute functionality");
	                        var muteHandler = function () {
	                            if (playerManager.isMuted) {
	                                if (videojsPlayer.volume() > 0) {
	                                    playerManager.explicitUnmute();
	                                }
	                            } else {
	                                playerManager.explicitMute();
	                            }
	                        };

	                        //for browsers
	                        videojsPlayer.controlBar.muteToggle.on("click", muteHandler);

	                        //for devices
	                        videojsPlayer.controlBar.muteToggle.on("touchend", muteHandler);
	                    } else {
	                        verbose("removing mute button");
	                        videojsPlayer.controlBar.muteToggle.dispose();
	                    }

	                    //invoke mute

	                    if (html5PlayerSelf.options.showVolume === true && html5PlayerSelf.displayVolumeControls()) {
	                        videojsPlayer.controlBar.volumeControl.volumeBar.on("mousedown", function () {
	                            var volume = videojsPlayer.volume();
	                            if (volume <= 0 && !playerManager.isMuted) {
	                                verbose("muting from volume scrubber");
	                                playerManager.explicitMute();
	                            }
	                            if (volume > 0 && playerManager.isMuted) {
	                                verbose("unmuting from volume scrubber");
	                                playerManager.explicitUnmute();
	                            }
	                        });
	                    }

	                    //For iOS10 force the mute button update
	                    if (utils.isIos() && html5PlayerSelf.options.enableNativeInline && parseInt(utils.getIOSVersion()) > 9 && html5PlayerSelf.options.initialPlayback !== "click") {
	                        videojsPlayer.muted(true);
	                        videojsPlayer.controlBar.muteToggle.update();
	                    }

	                    if (typeof html5PlayerSelf.options.customButton.enabled === "boolean" && html5PlayerSelf.options.customButton.enabled === true) {
	                        var controlBarHeight = html5PlayerSelf.options.playerSkin.controlBarHeight || 30;
	                        var imgWidth = Math.min(50, html5PlayerSelf.options.customButton.imgWidth);
	                        var imgHeight = Math.min(controlBarHeight, html5PlayerSelf.options.customButton.imgHeight);
	                        var topMargin = Math.floor((controlBarHeight - imgHeight) / 2);
	                        var spanOrAnchor = "a";
	                        if (html5PlayerSelf.isMobile()) {
	                            spanOrAnchor = "span";
	                        }

	                        var customButton = html5PlayerSelf.videojsOrigin.createEl('div', {
	                            'innerHTML': '<' + spanOrAnchor + ' href="' + html5PlayerSelf.options.customButton.url + '" target="_blank"><img style="height:' + imgHeight + 'px;width:' + imgWidth + 'px;margin-top:' + topMargin + 'px" class="home-button-image" src="' + html5PlayerSelf.options.customButton.imageSrc + '" alt="' + html5PlayerSelf.options.customButton.altText + '"></' + spanOrAnchor + '>',
	                            'role': 'button',
	                            'aria-live': 'polite',
	                            'tabindex': '0'
	                        });
	                        customButton.style.cssText = "float:right;font-family:VideoJS;font-size:1.5em;line-height:2;width:50px;height:100%;text-align:center";
	                        videojsPlayer.controlBar.addChild('button', {
	                            'el': customButton
	                        });
	                        videojsPlayer.controlBar.el().insertBefore(customButton, videojsPlayer.controlBar.fullscreenToggle.el());
	                    }

	                    //set showProgressBar
	                    videojsPlayer.controlBar.progressControl.seekBar.seekHandle.hide();
	                    videojsPlayer.controlBar.progressControl.seekBar.el_.style.pointerEvents = 'none';
	                    if (typeof html5PlayerSelf.options.showProgressBar === "boolean") {
	                        if (html5PlayerSelf.options.showProgressBar === false) {
	                            verbose("removing progress bar");
	                            videojsPlayer.controlBar.currentTimeDisplay.hide();
	                            videojsPlayer.controlBar.timeDivider.hide();
	                            videojsPlayer.controlBar.durationDisplay.hide();
	                        }
	                        videojsPlayer.controlBar.progressControl.seekBar.hide();
	                    } else {
	                        if (html5PlayerSelf.options.showProgressBar === "text") {
	                            verbose("removing progress text");
	                            videojsPlayer.controlBar.progressControl.seekBar.hide();
	                        } else if (html5PlayerSelf.options.showProgressBar === "bar") {
	                            verbose("removing progress bar");
	                            videojsPlayer.controlBar.currentTimeDisplay.hide();
	                            videojsPlayer.controlBar.timeDivider.hide();
	                            videojsPlayer.controlBar.durationDisplay.hide();
	                        }
	                    }

	                    //set allowFullscreen
	                    if (html5PlayerSelf.options.allowFullscreen === false) {
	                        verbose("removing fullscreen toggle");
	                        videojsPlayer.controlBar.fullscreenToggle.el().style.visibility = "hidden";
	                    }

	                    var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

	                    debug("Creating top chrome buttons/text");
	                    verbose("creating and styling ad indicator");
	                    var adIndicatorText = iframeVideoWrapper.contentWindow.document.createElement("div");
	                    adIndicatorText.id = "ad_indicator_text";

	                    var adIndicatorTextContent = html5PlayerSelf.options.adText;
	                    if (html5PlayerSelf.options.learnMore.enabled === true) {
	                        if (html5PlayerSelf.options.skippable.skipLocation === "top-right") {
	                            adIndicatorTextContent = html5PlayerSelf.options.learnMore.text + " " + html5PlayerSelf.options.learnMore.separator + " " + adIndicatorTextContent;
	                        } else {
	                            adIndicatorTextContent += " " + html5PlayerSelf.options.learnMore.separator + " " + html5PlayerSelf.options.learnMore.text;
	                        }
	                    }

	                    adIndicatorText.innerHTML = adIndicatorTextContent;
	                    adIndicatorText.className = 'top-bar-text';
	                    adIndicatorText.role = 'button';

	                    adIndicatorText.style['text-align'] = "right";
	                    adIndicatorText.style['margin-right'] = "1em";
	                    adIndicatorText.style['margin-left'] = "1em";
	                    adIndicatorText.style['font-size'] = "1em";
	                    adIndicatorText.style['right'] = "0px";
	                    adIndicatorText.style['left'] = "";
	                    adIndicatorText.style['line-height'] = "24px";
	                    adIndicatorText.style['outline'] = "0";
	                    adIndicatorText.style['position'] = "absolute";
	                    adIndicatorText.style['padding'] = "0";
	                    adIndicatorText.style['height'] = "auto";
	                    adIndicatorText.style['width'] = "auto";
	                    adIndicatorText.style['max-width'] = "35%";
	                    adIndicatorText.style['white-space'] = "nowrap";
	                    adIndicatorText.style['overflow'] = "hidden";
	                    adIndicatorText.style['text-overflow'] = "ellipsis";
	                    if (html5PlayerSelf.options.learnMore.enabled !== true) {
	                        adIndicatorText.style['pointer-events'] = "none";
	                    } else {
	                        adIndicatorText.style['cursor'] = "pointer";
	                    }

	                    var floatingAdIndicator = html5PlayerSelf.videojsOrigin.createEl('div', {
	                        'role': 'button',
	                        'innerHTML': adIndicatorTextContent,
	                        'className': "top-bar-text"
	                    });
	                    var floatingSkipButton;
	                    var floatingAdSkipText;
	                    var readyForSkip = false;

	                    floatingAdIndicator.style['text-align'] = "right";
	                    floatingAdIndicator.style['margin-right'] = "1em";
	                    floatingAdIndicator.style['margin-left'] = "1em";
	                    floatingAdIndicator.style['font-size'] = "1em";
	                    floatingAdIndicator.style['right'] = "0px";
	                    floatingAdIndicator.style['left'] = "";
	                    floatingAdIndicator.style['line-height'] = "3em";
	                    floatingAdIndicator.style['outline'] = "0";
	                    floatingAdIndicator.style['position'] = "absolute";
	                    floatingAdIndicator.style['padding'] = "0";
	                    floatingAdIndicator.style['height'] = "3em";
	                    floatingAdIndicator.style['max-width'] = "35%";
	                    floatingAdIndicator.style['width'] = "auto";
	                    floatingAdIndicator.style['text-overflow'] = "ellipsis";
	                    floatingAdIndicator.style['white-space'] = "nowrap";
	                    floatingAdIndicator.style['overflow'] = "hidden";
	                    floatingAdIndicator.style['display'] = "none";
	                    if (html5PlayerSelf.options.learnMore.enabled !== true) {
	                        floatingAdIndicator.style['pointer-events'] = "none";
	                    } else {
	                        floatingAdIndicator.style['cursor'] = "pointer";

	                        var learnMoreHandler = function (e) {
	                            playerManager.click();

	                            if (html5PlayerSelf.isMobile()) {
	                                e.stopPropagation();
	                                e.preventDefault(); // prevents a touch event from also triggering a click event
	                            }
	                        };

	                        adIndicatorText.addEventListener("click", learnMoreHandler);
	                        floatingAdIndicator.addEventListener("click", learnMoreHandler);
	                    }

	                    videojsPlayer.addChild('button', {
	                        'el': floatingAdIndicator
	                    });

	                    var skipButton;
	                    var adSkipText;
	                    //set skip button
	                    if (html5PlayerSelf.options.skippable.enabled === true) {
	                        verbose("creating and styling skip buttons and skip texts");

	                        var videoThreshold = html5PlayerSelf.options.skippable.videoThreshold;
	                        var skipText = html5PlayerSelf.options.skippable.skipText;
	                        var skipButtonText = html5PlayerSelf.options.skippable.skipButtonText;

	                        skipButton = iframeVideoWrapper.contentWindow.document.createElement("div");
	                        skipButton.id = "skip_button";

	                        skipButton.innerHTML = skipButtonText;
	                        skipButton.className = 'top-bar-text';
	                        skipButton.role = 'button';

	                        var skipHitBoxHeight = "";
	                        if (html5PlayerSelf.isMobile()) {
	                            skipHitBoxHeight = "5.0em";
	                        }

	                        skipButton.style['display'] = "none";
	                        skipButton.style['cursor'] = "pointer";
	                        skipButton.style['font-weight'] = "bold";
	                        skipButton.style['margin-right'] = "1em";
	                        skipButton.style['margin-left'] = "1em";
	                        skipButton.style['font-size'] = "1em";
	                        skipButton.style['right'] = "";
	                        skipButton.style['left'] = "0px";
	                        skipButton.style['line-height'] = "24px";
	                        skipButton.style['outline'] = "0";
	                        skipButton.style['position'] = "absolute";
	                        skipButton.style['padding'] = "0";
	                        skipButton.style['height'] = skipHitBoxHeight;
	                        skipButton.style['width'] = "auto";
	                        skipButton.style['min-width'] = "5em";
	                        skipButton.style['text-align'] = "left";

	                        //skip button
	                        floatingSkipButton = html5PlayerSelf.videojsOrigin.createEl('div', {
	                            'className': 'top-bar-text',
	                            'role': 'button',
	                            'innerHTML': skipButtonText
	                        });

	                        floatingSkipButton.style['display'] = "none";
	                        floatingSkipButton.style['cursor'] = "pointer";
	                        floatingSkipButton.style['font-weight'] = "bold";
	                        floatingSkipButton.style['margin-right'] = "1em";
	                        floatingSkipButton.style['margin-left'] = "1em";
	                        floatingSkipButton.style['font-size'] = "1em";
	                        floatingSkipButton.style['right'] = "";
	                        floatingSkipButton.style['left'] = "0px";
	                        floatingSkipButton.style['line-height'] = "3em";
	                        floatingSkipButton.style['outline'] = "0";
	                        floatingSkipButton.style['position'] = "absolute";
	                        floatingSkipButton.style['padding'] = "0";
	                        floatingSkipButton.style['height'] = skipHitBoxHeight;
	                        floatingSkipButton.style['min-width'] = "5em";
	                        floatingSkipButton.style['width'] = "auto";
	                        floatingSkipButton.style['display'] = "none";
	                        floatingSkipButton.style['text-align'] = "left";

	                        videojsPlayer.addChild('button', {
	                            'el': floatingSkipButton
	                        });

	                        var skipHandler = function (e) {
	                            debug("SKIP clicked, destroying player");
	                            // For JS-VPAID Ads trigger skip on Creative and wait for it to respond back with 'AdSkipped to perform action
	                            if (html5PlayerSelf.options.vpaid) {
	                                videojsPlayer.trigger('skip');
	                                if (html5PlayerSelf.isMobile()) {
	                                    e.stopPropagation();
	                                    e.preventDefault(); // prevents a touch event from also triggering a click event
	                                }
	                                return;
	                            }
	                            // Must call this *before* setting isCompleted flag for skip tracking events to be sent
	                            playerManager.destroy();

	                            if (html5PlayerSelf.isMobile()) {
	                                e.stopPropagation();
	                                e.preventDefault(); // prevents a touch event from also triggering a click event
	                                playerManager.isCompleted = true;//added for VID-1047
	                            }
	                        };

	                        if (html5PlayerSelf.isMobile()) {
	                            skipButton.addEventListener("touchend", skipHandler);
	                            floatingSkipButton.addEventListener("touchend", skipHandler);
	                            floatingSkipButton.addEventListener("mousedown", function (e) {
	                                e.preventDefault();
	                            });
	                        }

	                        skipButton.addEventListener("click", skipHandler);
	                        floatingSkipButton.addEventListener("click", skipHandler);

	                        //skip text
	                        floatingAdSkipText = html5PlayerSelf.videojsOrigin.createEl('div', {
	                            'className': 'top-bar-text',
	                            'role': 'button',
	                            'innerHTML': ""
	                        });

	                        floatingAdSkipText.style['margin-left'] = "1em";
	                        floatingAdSkipText.style['margin-right'] = "1em";
	                        floatingAdSkipText.style['right'] = "";
	                        floatingAdSkipText.style['left'] = "0px";
	                        floatingAdSkipText.style['font-size'] = "1em";
	                        floatingAdSkipText.style['line-height'] = "3em";
	                        floatingAdSkipText.style['outline'] = "0";
	                        floatingAdSkipText.style['position'] = "absolute";
	                        floatingAdSkipText.style['text-align'] = "left";
	                        floatingAdSkipText.style['padding'] = "0";
	                        floatingAdSkipText.style['height'] = "3em";
	                        floatingAdSkipText.style['width'] = "auto";
	                        floatingAdSkipText.style['pointer-events'] = "none";
	                        floatingAdSkipText.style['display'] = "none";

	                        videojsPlayer.addChild('button', {
	                            'el': floatingAdSkipText
	                        });

	                        //skip text
	                        adSkipText = iframeVideoWrapper.contentWindow.document.createElement("div");
	                        adSkipText.id = "ad_skip_text";

	                        adSkipText.innerHTML = skipButtonText;
	                        adSkipText.className = 'top-bar-text';
	                        adSkipText.role = 'button';

	                        adSkipText.style['margin-left'] = "1em";
	                        adSkipText.style['margin-right'] = "1em";
	                        adSkipText.style['right'] = "";
	                        adSkipText.style['left'] = "0px";
	                        adSkipText.style['font-size'] = "1em";
	                        adSkipText.style['line-height'] = "24px";
	                        adSkipText.style['outline'] = "0";
	                        adSkipText.style['position'] = "absolute";
	                        adSkipText.style['text-align'] = "left";
	                        adSkipText.style['padding'] = "0";
	                        adSkipText.style['height'] = "3em";
	                        adSkipText.style['width'] = "auto";
	                        adSkipText.style['pointer-events'] = "none";
	                        adSkipText.style['display'] = "none";

	                        //switch position by option
	                        switch (html5PlayerSelf.options.skippable.skipLocation) {
	                            case "top-right":
	                                skipButton.style['right'] = "0px";
	                                skipButton.style['left'] = "";
	                                skipButton.style['text-align'] = "right";

	                                adSkipText.style['right'] = "0px";
	                                adSkipText.style['left'] = "";

	                                floatingSkipButton.style['right'] = "0px";
	                                floatingSkipButton.style['left'] = "";
	                                floatingSkipButton.style['text-align'] = "right";

	                                floatingAdSkipText.style['right'] = "0px";
	                                floatingAdSkipText.style['left'] = "";
	                                break;
	                            default :
	                                break;
	                        }

	                        //quartile status to invoke only once
	                        var quartile1status = false;
	                        var quartile2status = false;
	                        var quartile3status = false;


	                        var _trackedProgressOffsetSorted = {};

	                        //handle tick event from video.js
	                        videojsPlayer.on("timeupdate", function () {
	                            var _vastProgressEvent = playerManager.options.data.vastProgressEvent;

	                            if (html5PlayerSelf.options.isWaterfall && html5PlayerSelf.options.vpaid && !html5PlayerSelf.options.vpaidImpressionFired) {
	                                return;
	                            }
	                            var currentTime = Math.round(videojsPlayer.player().currentTime());
	                            var _currentTimeMsec = currentTime * 1000;

	                            var offsetTime;
	                            if (playerManager.options.skippable.allowOverride) {
	                                offsetTime = Math.round(html5PlayerSelf.options.data.skipOffsetMsec / 1000);//trust vast3 setting
	                            } else {
	                                offsetTime = html5PlayerSelf.options.skippable.videoOffset;//trust console setting
	                            }

	                            var remainTime = offsetTime - currentTime;
	                            var videoDuration = Math.round(videojsPlayer.player().duration());

	                            //handle vast3 progress event
	                            if (_vastProgressEvent && typeof(_vastProgressEvent) === "object") {

	                                var _progressCallback = function () {
	                                    playerManager.test("VIDLA163_Tracking", _trackedProgressOffsetSorted);
	                                };
	                                for (var _eventKey in _vastProgressEvent) {
	                                    var _progressMsec = _vastProgressEvent[_eventKey];
	                                    if (_progressMsec && _progressMsec >= 0 && _currentTimeMsec >= _progressMsec && Object.keys(_trackedProgressOffsetSorted).indexOf(_eventKey) === -1) {
	                                        _trackedProgressOffsetSorted[_eventKey] = _progressMsec;
	                                        var obj = {};
	                                        obj.name = _eventKey;
	                                        if (obj.name) {
	                                            playerManager.dispatchEventToAdunit(obj, _progressCallback);
	                                        }
	                                    }
	                                }
	                            }
	                            var needToShowSkip = (html5PlayerSelf.options.skippable.allowOverride) ? html5PlayerSelf.options.data.isVastVideoSkippable : true;
	                            needToShowSkip = (offsetTime > videoDuration) ? false :  needToShowSkip;
	                            playerManager.test("VIDLA163_needToShowSkip",needToShowSkip);
	                            if (videoThreshold <= videoDuration && !html5PlayerSelf.options.disableTopBar && needToShowSkip) {
	                                if (remainTime > 0) {
	                                    floatingAdSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                                    adSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                                    adSkipText.style.display = "block";
	                                    skipButton.style.display = "none";
	                                } else {
	                                    if (!readyForSkip) {
	                                        playerManager.test("log", currentTime);
	                                        playerManager.test("VIDLA163_skip", currentTime);
	                                    }
	                                    readyForSkip = true;

	                                    if (playerManager.isFullscreen && !html5PlayerSelf.pendingFullscreenExit) {
	                                        floatingAdSkipText.style.display = "none";
	                                        floatingSkipButton.style.display = "block";
	                                    }

	                                    adSkipText.style.display = "none";
	                                    skipButton.style.display = "block";
	                                }
	                            }
	                        });
	                    }

	                    //switch position by option
	                    if (html5PlayerSelf.options.skippable && html5PlayerSelf.options.skippable.skipLocation) {
	                        switch (html5PlayerSelf.options.skippable.skipLocation) {
	                            case "top-right":
	                                adIndicatorText.style['right'] = "";
	                                adIndicatorText.style['left'] = "0px";

	                                floatingAdIndicator.style['right'] = "";
	                                floatingAdIndicator.style['left'] = "0px";
	                                break;
	                            default :
	                                break;
	                        }
	                    }

	                    if (!html5PlayerSelf.options.disableTopBar && topChrome) {
	                        if (html5PlayerSelf.options.skippable.enabled === true) {
	                            topChrome.appendChild(skipButton);
	                            topChrome.appendChild(adSkipText);
	                        }
	                        topChrome.appendChild(adIndicatorText);
	                    }

	                    //set quartile event
	                    videojsPlayer.on("timeupdate", function () {
	                        if (html5PlayerSelf.options.vpaid) {
	                            return;
	                        }
	                        var currentTime = Math.round(videojsPlayer.player().currentTime());
	                        var videoDuration = videojsPlayer.player().duration();
	                        if (!videoDuration) {
	                            return;
	                        }
	                        var quartile1 = videoDuration / 4;
	                        var quartile2 = videoDuration / 4 * 2;
	                        var quartile3 = videoDuration / 4 * 3;


	                        if (!quartile1status && currentTime >= quartile1 && currentTime < quartile2) {
	                            html5PlayerSelf.dispatchEventToAdunit({"name": "video-first-quartile"});
	                            quartile1status = true;
	                        }

	                        if (!quartile2status && currentTime >= quartile2 && currentTime < quartile3) {
	                            html5PlayerSelf.dispatchEventToAdunit({"name": "video-mid"});
	                            quartile2status = true;
	                        }

	                        if (!quartile3status && currentTime >= quartile3) {
	                            html5PlayerSelf.dispatchEventToAdunit({"name": "video-third-quartile"});
	                            quartile3status = true;
	                        }
	                    });

	                    //set explictPaused
	                    videojsPlayer.controlBar.playToggle.on("click", function () {
	                        verbose("play button click");
	                        playerManager.explicitPaused = !playerManager.explicitPaused;
	                    });

	                    //set explictPaused
	                    videojsPlayer.controlBar.playToggle.on("touchend", function () {
	                        verbose("play button touchend");
	                        playerManager.explicitPaused = !playerManager.explicitPaused;
	                    });

	                    //set destroy event
	                    videojsPlayer.on("ended", function () {
	                        var callbackFunctionAfterVideoComplete = function () {
	                            verbose("hiding control bar and big play button");
	                            var _controlBar = videojsPlayer.controlBar;
	                            if (_controlBar.currentTimeDisplay) {
	                                _controlBar.currentTimeDisplay.hide();
	                            }
	                            if (_controlBar.durationDisplay) {
	                                _controlBar.durationDisplay.hide();
	                            }
	                            if (_controlBar.timeDivider) {
	                                _controlBar.timeDivider.hide();
	                            }
	                            if (_controlBar.muteToggle) {
	                                _controlBar.muteToggle.hide();
	                            }
	                            if (_controlBar.playToggle) {
	                                _controlBar.playToggle.hide();
	                            }
	                            if (_controlBar.fullscreenToggle) {
	                                _controlBar.fullscreenToggle.hide();
	                            }
	                            if (_controlBar.progressControl) {
	                                _controlBar.progressControl.hide();
	                            }
	                            if (_controlBar.volumeControl) {
	                                _controlBar.volumeControl.hide();
	                            }
	                            videojsPlayer.bigPlayButton.hide();

	                            //destroyWithoutSkip should invoke only one time, seconds time will be igonored by existing rules
	                            //for that reason if disableCollapse is true, there will be second chance to invoke destroyWithoutSkip() when user click "skip" button
	                            //so following condition is required
	                            if (!html5PlayerSelf.options.disableCollapse) {
	                                playerManager.isSkipped = true;//this flag should set for VID-1885, and if disableCollapse is false and video complete means skip, we have to set isSkipped to true.
	                                playerManager.destroyWithoutSkip();//this actual termination logic should be invoked after video_complete triggered. so this callbackFunctionAfterVideoComplete is being passed into eventHandling logic
	                            }

	                            if (playerManager.isFullscreen) {//if video is on fullscreen then it will exit out of fullscreen when video is finished
	                                // exit full-screen
	                                verbose("exiting fullscreen before destroy()");
	                                if (document.exitFullscreen) {
	                                    document.exitFullscreen();
	                                } else if (document.webkitExitFullscreen) {
	                                    document.webkitExitFullscreen();
	                                } else if (document.mozCancelFullScreen) {
	                                    document.mozCancelFullScreen();
	                                } else if (document.msExitFullscreen) {
	                                    document.msExitFullscreen();
	                                }
	                            }
	                            verbose("isCompleted = true");
	                            playerManager.isCompleted = true;
	                        };

	                        if (html5PlayerSelf.options.vpaid) {
	                            callbackFunctionAfterVideoComplete();//JSVPAID has it's own logic to invoke html5PlayerSelf.dispatchEventToAdunit for "video_complete", so it doesn't need to be invoked twice here
	                        } else {
	                            html5PlayerSelf.dispatchEventToAdunit({"name": "video_complete"}, callbackFunctionAfterVideoComplete);//this callback will be invoked after video_complete
	                        }


	                    });

	                    videojsPlayer.on("durationchange", function () {
	                        html5PlayerSelf.dispatchEventToAdunit({"name": "durationchange"});
	                    });

	                    videojsPlayer.on("error", function (e) {
	                        debug("error in video js");

	                        var ignore_error_which_are_not_fatal = (e && e.target && e.target !== undefined && html5PlayerSelf.options && html5PlayerSelf.options.vpaid);
	                        if (ignore_error_which_are_not_fatal &&
	                            (
	                                (e.target.toString().indexOf("poster=\"null\"") > 0) ||
	                                (e.target.nodeName.toLowerCase() === "video" && e.target.networkState <= 2) ||
	                                (e.target.nodeName.toLowerCase() === "div")
	                            )
	                        ) {
	                            //do nothing here, this issue caused by js-vpaid player (mail online's)
	                            //do nothing, when video js's video element throws errors but which are not fatal
	                        } else {
	                            verbose("destroying due to error in video js");
	                            playerManager.destroyWithoutSkip(true, html5PlayerSelf.CONST_MESSAGE_GENERAL_ERROR, null, 900);
	                        }
	                    });

	                    videojsPlayer.on("firstplay", function () {
	                        html5PlayerSelf.dispatchEventToAdunit({"name": "firstplay"});
	                        // VIDLA-126
	                        // we have to update the volume controls ui
	                        // since videojs doesn't seem to register above mute/unmute on the ui
	                        // VIDLA-307 If mute visual is updated before the Ad Playback then this causes Safari issues for diagonally sliding button.
	                        if (videojsPlayer.controlBar.muteToggle) {
	                            videojsPlayer.controlBar.muteToggle.update();
	                        }
	                        if (videojsPlayer.controlBar.volumeControl && videojsPlayer.controlBar.volumeControl.volumeBar) {
	                            videojsPlayer.controlBar.volumeControl.volumeBar.update();
	                        }
	                    });


	                    //for VID-2558 VID-2554 Desktop Safari, Firefox response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation. and it is used by Outstream AdUnit
	                    if (html5PlayerSelf.isMobile() === false) {
	                        videojsPlayer.controlBar.fullscreenToggle.on("click", function () {
	                            //isFullscreenToggled flag will use for sideStream to have more accurate fullscreen status on desktop safari and firefox
	                            if (playerManager.isFullscreenToggled) {
	                                //do nothing because a part to handle "fullscreenchange" will set false
	                            } else {
	                                playerManager.isFullscreenToggled = true;
	                            }

	                        });
	                    }


	                    videojsPlayer.on("fullscreenchange", function () {
	                        verbose("fullscreenchange");

	                        if (html5PlayerSelf.isIos() && playerManager.isFullscreen) {
	                            playerManager.play();
	                        }

	                        if (playerManager.isFullscreen) {
	                            html5PlayerSelf.pendingFullscreenExit = true;
	                            videojsPlayer.controlBar.el().style['bottom'] = '';
	                            if (!html5PlayerSelf.options.disableTopBar) {
	                                floatingAdIndicator.style.display = "none";
	                                if (floatingSkipButton) {
	                                    floatingSkipButton.style.display = "none";
	                                    floatingAdSkipText.style.display = "none";
	                                }
	                            }


	                            var delayForSuppressingMouseoutEvent;
	                            if (html5PlayerSelf.isMobile() === false) {
	                                delayForSuppressingMouseoutEvent = 1000;
	                            } else {
	                                delayForSuppressingMouseoutEvent = 0;//mobile (Android) doesn't need to delay to set isFullscreen flag for the mouseout event - it doesn't have a mouse
	                            }

	                            setTimeout(function () {
	                                html5PlayerSelf.pendingFullscreenExit = false;
	                                playerManager.isFullscreen = false;
	                                playerManager.isFullscreenToggled = false;//for sideStream activation


	                                html5PlayerSelf.dispatchEventToAdunit({
	                                    name: "fullscreenchange",
	                                    fullscreenStatus: "exit"
	                                });
	                            }, delayForSuppressingMouseoutEvent);//this delay must be required for supressing mouseout event when exit fullscreen


	                        } else {
	                            playerManager.isFullscreen = !playerManager.isFullscreen;
	                            videojsPlayer.controlBar.el().style['bottom'] = "0.0em";


	                            if (!html5PlayerSelf.options.disableTopBar) {
	                                floatingAdIndicator.style.display = "block";
	                                if (floatingSkipButton) {
	                                    if (readyForSkip) {
	                                        floatingSkipButton.style.display = "block";
	                                        floatingAdSkipText.style.display = "none";
	                                    } else {
	                                        floatingSkipButton.style.display = "none";
	                                        floatingAdSkipText.style.display = "block";
	                                    }
	                                }
	                            }
	                            html5PlayerSelf.dispatchEventToAdunit({
	                                name: "fullscreenchange",
	                                fullscreenStatus: "enter"
	                            });
	                        }


	                    });

	                    videojsPlayer.on("loadstart", function () {
	                        html5PlayerSelf.dispatchEventToAdunit({"name": "loadstart"});
	                    });

	                    videojsPlayer.on("pause", function () {
	                        //html5PlayerSelf.dispatchEventToAdunit({"name": "video_pause"});

	                        verbose("hiding big play button");
	                        videojsPlayer.player().bigPlayButton.el().style.display = "block";
	                        playerManager.isPlayingVideo = false;
	                    });

	                    videojsPlayer.on("play", function () {
	                        videojsPlayer.player().bigPlayButton.el().style.display = "";

	                        //html5PlayerSelf.dispatchEventToAdunit({"name": "video_resume"});
	                        //html5PlayerSelf.dispatchEventToAdunit({"name": "impression"});
	                        //html5PlayerSelf.dispatchEventToAdunit({"name": "video_start"});


	                        playerManager.isPlayingVideo = true;
	                    });

	                    //handle click toggle manually
	                    videojsPlayer.controlBar.playToggle.on("click", function () {
	                        verbose("play button click");
	                        if (playerManager.isPlayingVideo === true) {
	                            playerManager.explicitPause();
	                        } else {
	                            playerManager.explicitPlay();
	                            playerManager.unmute();
	                        }
	                    });

	                    videojsPlayer.controlBar.playToggle.on("touchend", function () {
	                        verbose("play button touchend");
	                        if (playerManager.isPlayingVideo === true) {
	                            playerManager.explicitPause();
	                        } else {
	                            playerManager.explicitPlay();
	                            playerManager.unmute();
	                        }
	                    });

	                    videojsPlayer.player().bigPlayButton.on("click", function () {
	                        verbose("big play button click");
	                        playerManager.explicitPlay();
	                        //this timeout is due to a limitation in videojs
	                        setTimeout(function () {
	                            playerManager.unmute();
	                        }, html5PlayerSelf.bigbuttonUnmuteTimeout);
	                    });

	                    videojsPlayer.player().bigPlayButton.on("touchend", function () {
	                        verbose("big play button touchend");
	                        playerManager.explicitPlay();
	                        //this timeout is due to a limitation in videojs
	                        setTimeout(function () {
	                            playerManager.unmute();
	                        }, html5PlayerSelf.bigbuttonUnmuteTimeout);
	                    });

	                    var waterfallStepId = html5PlayerSelf.options.isWaterfall ? html5PlayerSelf.options.waterfallStepId : null;
	                    // Handle orientation change on Device to resize the player
	                    window.addEventListener("orientationchange", function () {
	                        if (playerManager.isReadyToExpandForMobile) {//for VID-1515
	                            if (waterfallStepId && waterfallStepId !== html5PlayerSelf.options.waterfallStepId) {
	                                // Ignore the events as these are from previous ad attempts;
	                                return;
	                            }
	                            var shouldNotResizeWhenSideStreamActivated = html5PlayerSelf.options.sideStreamObject && typeof(html5PlayerSelf.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? html5PlayerSelf.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	                            if (shouldNotResizeWhenSideStreamActivated) {
	                                return;
	                            }

	                            html5PlayerSelf.refreshVideoLookAndFeel(html5PlayerSelf.options, playerManager);
	                        }
	                    });
	                })();


	                var el_wholeArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_id);
	                var el_videoArea = document.getElementById(html5PlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(html5PlayerSelf.an_video_ad_player_html5_api_id);


	                cbInjectEventToPlayer(el_wholeArea, el_videoArea);

	                /**
	                 * invoke "callbackForAdUnit.cbWhenReady" to continute a flow of video player this is asynchoronous action
	                 * and Outstream will wait this callback to start doing something (expanding...)
	                 */
	                if (html5PlayerSelf.options.vpaid === false) {//for regular html5 video player
	                    videojsPlayer.one("loadedmetadata", function (e) {
	                        var obj = e.currentTarget;
	                        playerManager.videoObjectId = obj.id;
	                        playerManager.isReadyToExpandForMobile = true;

	                        debug("loadedmetadata video.js is ready to play");
	                        //disable click to play
	                        videojsPlayer.tech.removeControlsListeners();

	                        //get real video size
	                        var realVideoWidth = obj.videoWidth;
	                        var realVideoHeight = obj.videoHeight;
	                        var aspectRatio = realVideoWidth / realVideoHeight;

	                        if (realVideoWidth > 0) {
	                            playerManager.resizeVideo(aspectRatio);

	                            if (typeof html5PlayerSelf.callbackForAdUnit.cbWhenReady === "function") {
	                                html5PlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                            }
	                        } else {
	                            //if the event doesn't return a videoWidth
	                            playerManager.resizeVideo(0);
	                            html5PlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                        }
	                    });
	                }
	            };

	            //fallback play for latest mobile browsers on iOS and Android both will auto-play by "autoplay" and "muted" attributes in video element. video.js will set the attributes by following codes.
	            if (html5PlayerSelf.options.initialPlayback === "autoWithFallbackPlay") {
	                html5PlayerSelf.options.autoplay = true;
	                html5PlayerSelf.options.muted = true;
	            }

	            //create player object
	            html5PlayerSelf.videojsOrigin(an_html5_video_object, html5PlayerSelf.options, function () {
	                customizeVideoJS(this);//do customize video.js after video.js initialized by calling back this method
	                if (html5PlayerSelf.options.vpaid === false) {
	                    this.src(html5PlayerSelf.options.videoUrl);
	                }

	            });

	            if (html5PlayerSelf.options.vpaid && playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.trigger) {
	                playerManager.adVideoPlayer.trigger("an.doneInitialize");
	            }


	        }
	    };


	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * JSVPAID Configure module this is used for AdVideoPlayerHtml5 and AdVideoPlayerHtml5Ios
	 * @type {*|exports|module.exports}
	 */

	var utils = __webpack_require__(9);
	var _logger = __webpack_require__(2);
	var CONST_MESSAGE_VAST_ADERROR = "VAST AdError reported from JS VPAID player";
	var CONST_MESSAGE_VPAID_ADERROR = "VPAID AdError reported from JS VPAID player";
	var error = function (message, category) {
	    _logger.error('[' + new Date().toISOString() + '] ' + message, category);
	};
	var warn = function (message) {
	    _logger.warn("JS VPAID" + message);
	};
	var info = function (message) {
	    _logger.info("JS VPAID" + message);
	};
	var log = function (message) {
	    _logger.log("JS VPAID" + message);
	};
	var debug = function (message) {
	    _logger.debug("JS VPAID" + message);
	};
	var verbose = function (message) {
	    _logger.verbose("JS VPAID" + message);
	};

	var JSVPAIDConfigure = function (playerManager) {

	    var dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
	    var options = playerManager.options;
	    var videojsOrigin = playerManager.videoPlayerObj;
	    var jsVpaidUrl = options.videoUrl;
	    var callbackForAdUnit = playerManager.callbackForAdUnit;
	    var iframeVideoWrapper = playerManager.iframeVideoWrapper;
	    var alreadyProcessedError = false;

	    // for Overlay player do not show any VPAID visual elements until AdStarted  is sent by creative.
	    if (!utils.isIos() && !utils.isAndroid() && iframeVideoWrapper && options.overlayPlayer && options.initialPlayback === "auto") {
	        iframeVideoWrapper.style.display = "none";
	    }

	    //add plugin to activate vpaid-js component
	    options.plugins = {"ads-setup": {}};
	    options.vpaidImpressionFired = false;

	    if(options.isWaterfall && options.firstAdAttempted){
	        if(options.delayExpandUntilVPAIDImpression){
	            options.delayExpandUntilVPAIDInit = false;
	        } else if(options.isExpanded) {
	            options.delayExpandUntilVPAIDInit = false;
	        }
	    }

	    //initalize JSVPAID plug-in
	    videojsOrigin.plugin('ads-setup', function (opts) {
	        debug(opts);
	        var vpaidTimeout = 5000;
	        if (options.vpaidTimeout !== undefined) {
	            vpaidTimeout = options.vpaidTimeout;
	        }
	        var loggerCallback = {
	            'error' : error,
	            'warn' : warn,
	            'info' : info,
	            'log' : log,
	            'debug' : debug,
	            'verbose' : verbose
	        };
	        var vpaidEventCallback = function (eventName, data) {
	            var event = {
	                'AdImpression': 'video_impression',
	                'AdVideoStart': 'video_start',
	                'AdVideoFirstQuartile': 'video-first-quartile',
	                'AdVideoMidpoint': 'video-mid',
	                'AdVideoThirdQuartile': 'video-third-quartile',
	                'AdVideoComplete': 'video_complete',
	                'AdSkipped': 'video_skip',
	                'AdClickThru': 'ad-click'
	            };
	            if(eventName === 'AdImpression'){
	                options.vpaidImpressionFired = true;
	            }

	            if (eventName === 'AdClickThru') {
	                //Do not track clickThru if landing url was not found.
	                if(data && data.playerHandles && !data.url){
	                    dispatchEventToAdunit({"name": event[eventName], "trackClick": false});
	                }else{
	                    dispatchEventToAdunit({"name": event[eventName], "trackClick": true});
	                }
	            }else if(event[eventName]){
	                dispatchEventToAdunit({"name": event[eventName]});
	            }
	            playerManager.notifyVpaidEvent(eventName);
	        };
	        var disableControlsOnMouseover = utils.isIos() || utils.isAndroid();
	        var videojsPlayer = this;

	        var vastAd = videojsPlayer.vastClient({
	            url: "",//url doesn't necessary in this vpaid plug-in
	            jsVpaidUrl: jsVpaidUrl,
	            playAdAlways: true,
	            adCancelTimeout: vpaidTimeout,
	            adsEnabled: true,
	            adParameters: options.adParameters,
	            clickUrl: options.clickUrls[0],
	            delayExpandUntilVPAIDInit: options.delayExpandUntilVPAIDInit,
	            terminateUnresponsiveVPAIDCreative: options.terminateUnresponsiveVPAIDCreative,
	            disableControlsOnMouseover: disableControlsOnMouseover,
	            initialAudio: options.initialAudio,
	            loggerCallback: loggerCallback,
	            vpaidEventCallback: vpaidEventCallback,
	            delayExpandUntilVPAIDImpression: options.delayExpandUntilVPAIDImpression,
	            vpaidEnvironmentVars: options.vpaidEnvironmentVars,
	            overlayPlayer: options.overlayPlayer,
	            initialPlayback: options.initialPlayback,
	            controlBarPosition: options.controlBarPosition
	        });


	        videojsPlayer.on('reset', function () {
	            if (videojsPlayer.options().plugins['ads-setup'].adsEnabled) {
	                vastAd.enable();
	            } else {
	                vastAd.disable();
	            }
	        });


	        videojsPlayer.on('vast.adError', function (evt) {

	            if (alreadyProcessedError === true) {
	                return;
	            } else {
	                alreadyProcessedError = true;
	            }

	            // clean visual element
	            videojsPlayer.loadingSpinner.hide();
	            //on a vast error, end the ad
	            playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VAST_ADERROR, false, 901);

	            var error = evt.error;
	            if (error && error.message) {
	                debug("JS-VPAID Error (vast.adError)" + error.message);
	            }
	        });

	        videojsPlayer.on("vpaid.AdVideoStart",function() {

	            var videoDuration = (playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.player) ? playerManager.adVideoPlayer.player().duration() : 0;
	            playerManager.test("VIDLA509",videoDuration);//test duration of metadata

	            //test duraion
	            if (videoDuration && videoDuration > 0) {
	                //set VAST3 attributes to options
	                playerManager.setVastAttribute();//use video metadata for duration
	            } else {
	                var _isInvokedLoadedMetaData = false;
	                //wait loadedmetadata again to give additional opportunity to get duration of video
	                videojsPlayer.one("loadedmetadata",function() {
	                    _isInvokedLoadedMetaData = true;
	                    videoDuration = (playerManager && playerManager.adVideoPlayer && playerManager.adVideoPlayer.player) ? playerManager.adVideoPlayer.player().duration() : 0;
	                    playerManager.test("VIDLA509",videoDuration);//test duration of metadata
	                    if (videoDuration && videoDuration > 0) {
	                        //use video metadata for duration
	                        playerManager.setVastAttribute();
	                    } else {
	                        //use vast data for duration
	                        var vastDurationMsec = playerManager.options.data.vastDurationMsec;
	                        vastDurationMsec = (vastDurationMsec && vastDurationMsec > 0) ? Math.round(vastDurationMsec / 1000) : 0;
	                        playerManager.test("VIDLA509-2", vastDurationMsec);
	                        playerManager.setVastAttribute(vastDurationMsec);
	                    }
	                });
	                //timeout to cover if loadMetaData isn't delivered - it will use VAST duration instead of video meta data
	                setTimeout(function() {
	                    if (_isInvokedLoadedMetaData === false) {
	                        var vastDurationMsec = playerManager.options.data.vastDurationMsec;//use vast data for duration
	                        vastDurationMsec = (vastDurationMsec && vastDurationMsec > 0) ? Math.round(vastDurationMsec / 1000) : 0;
	                        playerManager.test("VIDLA509-2", vastDurationMsec);
	                        playerManager.setVastAttribute(vastDurationMsec);
	                    }
	                },3000);
	            }
	        });

	        //this can be returned from js-vpaid 0.1.24
	        videojsPlayer.on('vast.adTimeout', function () {
	            // clean visual element
	            videojsPlayer.loadingSpinner.hide();
	            playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VPAID_ADERROR, true, 901);
	        });

	        //this can be returned from js-vpaid 0.1.24
	        videojsPlayer.on('vpaid.AdError', function (evt) {

	            if (alreadyProcessedError === true) {
	                return;
	            } else {
	                alreadyProcessedError = true;
	            }

	            // clean visual element
	            videojsPlayer.loadingSpinner.hide();
	            //on a vast error, end the ad
	            playerManager.destroyWithoutSkip(true, CONST_MESSAGE_VPAID_ADERROR, false, 901);

	            var error = evt.error;
	            if (error && error.message) {
	                debug("JS-VPAID Error (vpaid.AdError) " + error.message);
	            }
	        });

	        videojsPlayer.on('vast.adSkip', function () {
	            //on a vast skip, end the ad
	            playerManager.destroy();
	            debug("vast.adSkip");
	        });

	        videojsPlayer.on('vpaid.AdSkipped', function () {
	            //on a vast skip, end the ad
	            playerManager.destroy();
	            debug("vpaid.AdSkipped");
	        });

	        videojsPlayer.on('vast.adsCancel', function () {
	            //on a vast ad cancel, end the ad
	            playerManager.destroyWithoutSkip();
	            debug("adsCancel");
	        });

	        videojsPlayer.on('vpaid.AdStopped', function () {
	            debug("vpaid.AdStopped");
	            videojsPlayer.loadingSpinner.hide();
	            videojsPlayer.controlBar.hide();
	            videojsPlayer.bigPlayButton.hide();
	            if (playerManager.isCompleted) {
	                return;
	            }
	            if (!options.disableCollapse) {
	                playerManager.destroyWithoutSkip();
	            }
	            playerManager.isCompleted = true;
	        });

	        videojsPlayer.one('vpaid.AdStarted', function () {
	            // For overlay player show visual elements
	            if (iframeVideoWrapper && options.overlayPlayer) {
	                iframeVideoWrapper.style.display = "block";
	            }
	            // VID-1879 forcefully hiding spinner when creative send back AdStarted to avoid spinning issues due to slow buffering etc.
	            videojsPlayer.loadingSpinner.hide();

	            //minthe : comment out following lines because it looks unnecessary code since we changed iframe's height by resizeVideo and it will notify 'change' to vpaid creative
	            //minthe : and this code might be useful when we had static bottom-bar for JSVPAID, but now we have overlayed style bottom-bar, so this change will work as well
	            /*
	             //TODO change this to beautiful way in order to notify 'change' event into vpaid container which has height as "100%"
	             //some jsvpaid creative detect whole size of outstream, but the creative try to get a value when it has been changing
	             setTimeout(function () {
	             var iframeElement = document.getElementById(options.iframeVideoWrapperId);
	             var tmp = Number(iframeElement.style.height.replace("px", ""));
	             iframeElement.style.height = tmp + 1 + "px";
	             setTimeout(function () {
	             iframeElement.style.height = tmp + "px";
	             }, 500);
	             }, 500);
	             */
	        });

	        videojsPlayer.one("vpaid.AdImpression", function() {
	            videojsPlayer.controlBar.show();
	            videojsPlayer.bigPlayButton.show();
	        });

	        if (callbackForAdUnit.cbWhenReady) {//for JS-VPAID

	            /**
	             * final process to send signal to Adunit to let them know ready to go
	             */
	            var callcbWhenReady = function () {
	                playerManager.test("VIDLA509-1","");
	                debug("callcbWhenReady (Impression, AdStarted are delivered");
	                playerManager.isReadyToExpandForMobile = true;
	                videojsPlayer.tech.removeControlsListeners();
	                var aspectRatioFromVAST = playerManager.options.width / playerManager.options.height;
	                playerManager.resizeVideo(aspectRatioFromVAST, utils.isMobile());
	                // VIDLA-245 for waterfall show play button for non autoplay placements, if needed based on delayExpandUntilVPAID configurations.
	                if(options.isWaterfall && options.firstAdAttempted && options.delayExpandUntilVPAIDInit && !options.isExpanded && options.initialPlayback !== "auto"){
	                    videojsPlayer.bigPlayButton.show();
	                }
	                if (typeof callbackForAdUnit.cbWhenReady === "function") {
	                    callbackForAdUnit.cbWhenReady(playerManager);
	                }
	            };

	            var handleDelayExpand = function () {//VID-1505
	                var doneHandleDelayExpand = false;
	                var currentVolume = videojsPlayer.volume();
	                var adStartedTriggered = false;
	                var adImpressionTriggered = false;
	                var adVideoStartTriggered = false;
	                var isVideoPaused = false;
	                var intervalTimeForPause = 100;

	                var handleEvent = function () {
	                    if (adStartedTriggered && adImpressionTriggered && adVideoStartTriggered && doneHandleDelayExpand === false) {
	                        doneHandleDelayExpand = true;
	                        setTimeout(callcbWhenReady, 500);
	                    }
	                };

	                if (utils.isIos()) {//VID-1742
	                    videojsPlayer.on("timeupdate", function () {
	                        var currentPosition = videojsPlayer.player().currentTime();
	                        if (currentPosition > 0 && isVideoPaused === false && playerManager.isAlreadyPlaingForVPAID === false) {
	                            isVideoPaused = true;
	                            adVideoStartTriggered = true;
	                            videojsPlayer.pause();
	                            handleEvent();
	                            debug("pause by timeupdate when delayExpandUntilVPAIDImpression is true");
	                        }
	                    });
	                    var checkTimingToPause = function () {
	                        var currentPosition = videojsPlayer.player().currentTime();
	                        if (currentPosition > 0 && isVideoPaused === false && playerManager.isAlreadyPlaingForVPAID === false) {
	                            isVideoPaused = true;
	                            adVideoStartTriggered = true;
	                            videojsPlayer.pause();
	                            handleEvent();
	                            debug("pause by timer when delayExpandUntilVPAIDImpression is true");
	                        }
	                        if (!doneHandleDelayExpand) {
	                            setTimeout(checkTimingToPause,intervalTimeForPause);
	                        }
	                    };
	                    setTimeout(checkTimingToPause,intervalTimeForPause);
	                } else {
	                    videojsPlayer.one("vpaid.AdVideoStart", function () {
	                        if (playerManager.isAlreadyPlaingForVPAID === false) {
	                            videojsPlayer.pause();//early pause will cause issue not to dispatch timeupdate
	                        }
	                        videojsPlayer.volume(currentVolume);
	                        adVideoStartTriggered = true;
	                        handleEvent();
	                    });
	                }

	                videojsPlayer.one("vpaid.AdStarted", function () {
	                    adStartedTriggered = true;
	                    handleEvent();
	                });

	                videojsPlayer.one("vpaid.AdImpression", function () {
	                    adImpressionTriggered = true;
	                    handleEvent();
	                });

	                videojsPlayer.volume(0);//set mute
	                playerManager.delayEventHandler.ignoreNextQueue();//for VID-1505

	                if (utils.isIos()) {
	                    playerManager.adVideoPlayer.trigger('play');//jsvpaid in iOS inline should have special call instead of .play() in order to get "AdStarted" event for JSVPAID after that, framework will have proper video url which is set by JSVPAID creative
	                    playerManager.isDoneInitialPlay = true;//mark flag to notify JSVPAID-iOS player resolved initial playback
	                } else {
	                    videojsPlayer.play();
	                }
	            };

	            var decideHowToPlayByDelayStartUntilAdImpression = function () {
	                if (options.delayExpandUntilVPAIDImpression) {
	                    handleDelayExpand(); //case of delayExpandUntilVPAIDImpression
	                } else {
	                    callcbWhenReady();//case of others
	                }
	            };

	            if(options.isWaterfall && options.firstAdAttempted){
	                // For waterfall from second ad onwards trigger ready once the player is ready.
	                videojsPlayer.one("an.doneInitialize", decideHowToPlayByDelayStartUntilAdImpression);

	            } else {
	                if (options.delayExpandUntilVPAIDInit) {
	                    //suppress a call of cbWhenReady until player got custom event in order to notify Outstream to start expanding
	                    videojsPlayer.one("an.readytogovpaid", decideHowToPlayByDelayStartUntilAdImpression);//readytogovpaid will be triggerd when VPAID returns AdLoaded
	                } else {
	                    videojsPlayer.one("an.doneInitialize", decideHowToPlayByDelayStartUntilAdImpression);//doneInitialize will be triggered when ios/html5 player is initialized
	                }
	            }
	        }


	    });


	};
	module.exports = JSVPAIDConfigure;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var APN_InlineVideoPlayerForiOS = __webpack_require__(14);//new inline video player which is rendering a video signal into canvas and generating audio and sync with video
	var utils = __webpack_require__(9);
	var _logger = __webpack_require__(2);
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer: " + message);
	};

	var error = function (message) {
	    _logger.error("iOSInlineVideoPlayer: " + message);
	};

	/**
	 * This module adopts new inline video player for iOS version 8 and 9 for iphone and ipad, no gurranted to be used in other OS and other version.
	 *
	 * the player will be genrated by using "new" keyword to support multiple instance,
	 * the player will be injected into a div which is inside video.js area in the screen
	 * this module generates html5 video as usual as our framework did in AdVideoPlayerHtml5.js,
	 * but the video object will be passed to the inline player to be used as a source of video frame capturing
	 *
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 */
	var iOSInlineVideoPlayer = function (playerManager, cbInjectEventToPlayer) {

	    var iOSInlinePlayerSelf = this;

	    this.options = playerManager.options;//getting required object from adVideoPlayerManager
	    this.topChromeHeight = 24;
	    this.iOSVideoPlayer = new APN_InlineVideoPlayerForiOS();
	    this.videojsOrigin = playerManager.videoPlayerObj;
	    this.dispatchEventToAdunit = playerManager.dispatchEventToAdunit.bind(playerManager);
	    this.callbackForAdUnit = playerManager.callbackForAdUnit;
	    this.UUID = new Date().getTime() + Math.floor(Math.random() * 10000);
	    this.an_video_ad_player_id = "an_video_ad_player_" + iOSInlinePlayerSelf.UUID;
	    this.an_video_ad_player_html5_api_id = "an_video_ad_player_" + iOSInlinePlayerSelf.UUID + "_html5_api";
	    this.refreshVideoLookAndFeel = utils.refreshVideoLookAndFeel;
	    this.shouldConsiderHeightOfDevice = true;
	    this.isDoneiOSInitialPlay = false;
	    this.isTogglePaused = false;
	    this.enabledAudio = false;//flag to enable audio (one time action)
	    this.isFullscreen = false;
	    this.enableFullscreen = true;//add custom fullscreeen icon
	    this.fromFullscreen = false;
	    this.isAlreadyDoneVideoComplete = false;
	    this.customPlayToggle = {};
	    this.customFullscreenBtn = {};
	    this.eventSizeChange = {};//event id for size change when addressbar appears
	    this.eventOrientationChange = {};//event id for orientation change
	    this.floatingAdIndicator = null;
	    this.floatingSkipButton = null;
	    this.floatingAdSkipText = null;
	    this.readyForSkip = false;
	    this.videojsPlayer = null;

	    //loading module with injecting a dependancy
	    var EmulateHtml5Video = __webpack_require__(15)(iOSInlinePlayerSelf,playerManager);
	    var Events = __webpack_require__(16)(iOSInlinePlayerSelf,playerManager, cbInjectEventToPlayer);
	    var InitializeElements = __webpack_require__(18)(iOSInlinePlayerSelf,playerManager);

	    //interfaces
	    this.createIframeAndRequiredObject = InitializeElements.createIframeAndRequiredObject;
	    this.fnMainProcess = Events.fnMainProcess;
	    this.handleFullScreen = EmulateHtml5Video.handleFullScreen;
	    this.handleNormalScreen = EmulateHtml5Video.handleNormalScreen;
	    this.resizeIosCanvas = EmulateHtml5Video.resizeIosCanvas;
	    this.cbWhenVideoComplete = EmulateHtml5Video.cbWhenVideoComplete;

	    this.start = function() {
	        debug("start");

	        //test interface
	        if (iOSInlinePlayerSelf.test() === false) {
	            error("initialize error");
	            return;
	        }

	        var UID = new Date().getTime() + Math.floor(Math.random() * 10000);//define iframe's uniqueu id
	        iOSInlinePlayerSelf.options.iframeVideoWrapperId = "iframeVideoWrapper_" + UID;
	        iOSInlinePlayerSelf.options.techOrder = ["html5"];//force to use html5 for video.js because flash will be handled by diffrent swf owned by us
	        iOSInlinePlayerSelf.createIframeAndRequiredObject(iOSInlinePlayerSelf.fnMainProcess);//invoke method with a parameter defined next execution.
	    };

	    this.test = function() {
	        if (this.createIframeAndRequiredObject && this.fnMainProcess && this.handleFullScreen && this.handleNormalScreen && this.resizeIosCanvas && this.cbWhenVideoComplete) {
	            return true;
	        } else {
	            return false;
	        }
	    };




	};
	module.exports = iOSInlineVideoPlayer;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	//Inline video player module for iOS by kyungsuk (ksong@appnexus.com)
	/*
	 This player code includes following items.

	 0. Inline video in iPhone instead of native fullscreen
	 1. No AJAX call for audio and video
	 2. Using javascript only
	 3. Sync with audio
	 4. Multiple instance
	 5. Adjustable fullscreen instead of native one
	 6. Support Safari mobile browser of iOS8, iOS9 (phone / tablet)
	 */
	var _logger = __webpack_require__(2);
	var log = function (message) {
	    _logger.log("iOSInlineVideoPlayer: " + message);
	};
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: iOSInlineCore: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("iOSInlineVideoPlayer :: iOSInlineCore: " + message);
	};



	/**
	 * Javascript class for Inline Video Player for iOS (this class should be instiantiated by using new keyword)
	 * @constructor
	 */
	var APN_InlineVideoPlayerForiOS = function () {

	    //major required html5 object
	    var canvas;//html5 canvas object to render video signal
	    var video;//html5 video object to capture video signal
	    var videoSource;//source object to be injected into video object
	    var audio;//html5 audio object to sound
	    var audioSource;//source object to be injected into audio object
	    var mediaUrl;//media url to be used by video
	    var canvasContext;//2d context(surface) to render video


	    //major flags
	    var lastTime;//time to get lasttime
	    var animationFrame;//reference of loop
	    var framesPerSecond;//define frame rate
	    var isAudioStarted;
	    var canvasPause;//flag to pause video/audio
	    var isAudioMute;//if it's false player start sync with audio and video
	    var initialSyncValue;//const variable to define initial sync gap. if gap of time between audio and video exceed this value, player resync video to have same position with audio (audio's always playing without changing position)
	    var initialSyncValueAfter;//same with initialSyncValue, but initialSyncValue value will use only one time at the first synchronization
	    var videoAspectRatio;//variable to keep video aspect ratio this will have real width & height of video after got metadata from video asset
	    var isAudioCreated;//flag to block to generate audio tag over twice
	    var isFullscreen;
	    var limitSyncValue;
	    var cbWhenVideoComplete;
	    var isTerminated = false;
	    var isRunningForCanvas = false;


	    //areas
	    var divArea;//div element to render this player
	    var targetElement;//div element of Outstream
	    var cssTextOf_targetElement;//keep css of targetElement
	    var iframeVideoWrapper;//reference for iframe that video.js generates
	    var cssTextOf_iframeVideoWrapper;//css text to keep orignal value of iframeVideoWrapper
	    var el_wholeArea;//first div in iframe
	    var cssTextOf_el_wholeArea;//css text to keep orignal value of el_wholeArea
	    var cssTextOf_canvas;//css text to keep orignal value of canvas
	    var cbTimeUpdate;

	    var pubOptions;

	    //const
	    var heightOfToolbar = 30;//height of toolbar which will be added to video area. this is required to show whole area of video with controlbar

	    /**
	     * status object to keep original value
	     * @type {{keepWidth: null, keepHeight: null}}
	     */
	    var status = {
	        keepWidth: null, keepHeight: null
	    };

	    this.setPubOptions = function (options) {
	        pubOptions = options;
	    };

	    /**
	     * check if it's mobile
	     * @returns {boolean}
	     */
	    var isWorkableDeviceForInlineVideo = function () {
	        var index = navigator.appVersion.indexOf("Mobile");
	        return (index > -1);
	    };


	    /**
	     * external interface : render & prepare a video,canvas,audio reference. audio will be set when user click "unmute"
	     * @param options
	     * @param callback
	     */
	    this.renderVideo = function (options, callback) {

	        log("renderVideo");

	        if (!isWorkableDeviceForInlineVideo()) {
	            callback(false);
	            return;
	        }

	        cbTimeUpdate = options.cbTimeUpdate;
	        mediaUrl = options.mediaUrl;
	        divArea = options.divArea;
	        cbWhenVideoComplete = options.cbWhenVideoComplete;

	        //binding reference of elements
	        targetElement = options.targetElement;
	        iframeVideoWrapper = options.iframeVideoWrapper;
	        el_wholeArea = options.el_wholeArea;


	        //generate intial object
	        verbose("generating initial canvas object");
	        canvas = document.createElement("canvas");
	        divArea.appendChild(canvas);
	        divArea.style.width = "100%";//to fix alignment issue in normall screen if it's vpaid
	        divArea.style.height = "100%";


	        status.keepWidth = canvas.style.width;
	        status.keepHeight = canvas.style.height;


	        if (typeof options.videoElement !== "undefined") {
	            video = options.videoElement;
	        } else {
	            //create and inject video tag
	            verbose("creating video tag");
	            video = document.createElement("video");
	            videoSource = document.createElement("source");
	            video.style.display = "none";
	            video.autoplay = false;
	            video.preload = "auto";
	            video.controls = true;
	            videoSource.src = mediaUrl;//it will be replace if it's JSVPAID and when VPAID returns adStarted
	            video.appendChild(videoSource);

	            //inject video to divArea
	            divArea.appendChild(video);
	        }


	        //preparing audio tag but not render it
	        verbose("preparing audio tag");
	        audio = document.createElement("audio");
	        audioSource = document.createElement("source");

	        if (pubOptions.preloadInlineAudioForIos && !pubOptions.vpaid) {//vpaid will invoke this at playerHtml5Ios.js
	            this.activateAudio();
	        }


	        //getting context from canvas
	        canvasContext = canvas.getContext('2d');

	        lastTime = Date.now();//time to get lasttime
	        framesPerSecond = 35;//define frame rate
	        isAudioStarted = false;
	        canvasPause = false;
	        isAudioMute = true;
	        initialSyncValue = 0.3;
	        initialSyncValueAfter = 0.3;
	        videoAspectRatio = 0.1;
	        isAudioCreated = false;//flag to verfiy audio is already generated
	        isFullscreen = false;
	        limitSyncValue = 99999999;//if gap has bigger value than this, it won't be synchroinized

	        verbose("renderVideo callback");
	        callback(true);


	    };

	    //new logic for storing css this will store only required value
	    var saveCSS = function (targetElement) {
	        verbose("saveCSS");
	        var result = {};
	        var cssStorage = {position: "", width: "", height: "", top: "", left: "", marginRight: "", transform: "", background: ""};//only this attributes will be handled by save/load css method
	        for (var el in cssStorage) {
	            result[el] = targetElement.style[el];
	        }
	        return result;
	    };

	    //new logic for load CSS this will load only required value
	    var loadCSS = function (targetElement, storedCSSObject) {
	        verbose("loadCSS");
	        for (var el in storedCSSObject) {
	            targetElement.style[el] = storedCSSObject[el];
	        }
	    };

	    var getCalculatedWidthHeight = function (isFullscreen) {
	        //this is in a constant loop so I am commenting it out
	        //verbose("getCalculatedWidthHeight");
	        var aspectRatio = video.videoWidth / video.videoHeight;
	        var calculatedWidth = 0;
	        var calculatedHeight = 0;


	        if (!isFullscreen) {
	            var isSideStreamActivated = pubOptions.sideStream && pubOptions.sideStream.enabled && pubOptions.sideStreamObject && pubOptions.sideStreamObject.isActivated;
	            if (isSideStreamActivated) {

	                //for VID-2144
	                var frameWidth = pubOptions.sideStream.width;
	                var frameHeight = pubOptions.sideStream.height;
	                var width;
	                var height;
	                var topOffset = 0;
	                var bottomOffset = 30; //iOS alwasys need topBar

	                if (!pubOptions.disableTopBar) {
	                    topOffset = 24; //default height for topBar
	                }
	                frameHeight = frameHeight - (bottomOffset + topOffset);//consider topbar and controlBar size

	                if (!frameWidth && !frameHeight) {//using default value if sideStream doesn't have width,height
	                    frameWidth = pubOptions.width;
	                    frameHeight = pubOptions.mediaHeight;
	                }

	                if (frameWidth && frameHeight) {
	                    width = frameWidth;
	                    height = frameHeight;
	                } else {
	                    width = frameWidth ? frameWidth : frameHeight / aspectRatio;
	                    height = frameHeight ? frameHeight : frameWidth / aspectRatio;
	                }
	                calculatedWidth = Math.round(Math.min((height) * aspectRatio, width));
	                calculatedHeight = Math.round(Math.min(width / aspectRatio, height));
	            } else {
	                calculatedWidth = Math.round(Math.min((pubOptions.mediaHeight) * aspectRatio, pubOptions.width));
	                calculatedHeight = Math.round(Math.min(pubOptions.width / aspectRatio, pubOptions.mediaHeight));
	            }

	        } else {
	            //fullscreen case
	            calculatedWidth = window.innerWidth;
	            calculatedHeight = Math.round(window.innerWidth / aspectRatio);
	        }

	        //this is in a constant loop so I'm commenting it out
	        //verbose("calculated width: " + calculatedWidth + ", calculated height: " + calculatedHeight);
	        return {"width": calculatedWidth, "height": calculatedHeight};
	    };

	    var getStartXY = function (isFullscreen) {
	        //this is in a constant loop so I'm commenting it out
	        //verbose("getStartXY");

	        var startX = 0;
	        var startY = 0;

	        if (!isFullscreen) {
	            startX = 0;
	            startY = Math.abs(pubOptions.mediaHeight - getCalculatedWidthHeight(isFullscreen).height) / 2;
	        }

	        return {"x": startX, "y": startY};
	    };

	    var resizeCanvas = function (isFullscreen) {
	        //this is in a constant loop so I'm commenting it out
	        //verbose("resizeCanvas");

	        var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
	        var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;

	        if (!isFullscreen) {
	            canvas.width = calculatedWidth;
	            canvas.height = pubOptions.mediaHeight;
	        } else {
	            canvas.width = calculatedWidth;
	            canvas.height = calculatedHeight;
	        }


	    };

	    var redrawCanvas = function (isFullscreen) {

	        var startX = getStartXY(isFullscreen).x;
	        var startY = getStartXY(isFullscreen).y;
	        var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
	        var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;

	        if (!isFullscreen) {
	            canvasContext.drawImage(video, startX, startY, calculatedWidth, calculatedHeight);
	        } else {
	            canvasContext.drawImage(video, 0, 0, calculatedWidth, calculatedHeight);
	        }
	    };


	    /**
	     * render video and sync with audio, this method forcely advance key-frame by time-based, and render video signal into canvas
	     * time gap between audio and video calculates everytime, and if the gap will exceed over specific value, video will have new key-frame of audio's current playing.
	     * @param lasttime_
	     */
	    function renderingLoop(lasttime_) {


	        isRunningForCanvas = true;

	        var time = Date.now();//set current time
	        var elapsed = (time - lasttime_) / 1000;
	        var frameCondition = 1 / framesPerSecond;//calculate time of 1 frame consumens
	        var gap = 0;
	        var isSynched = false;
	        var syncValue = initialSyncValue;


	        //render 1 key frame of video
	        var renderVideoIntoCanvas = function () {




	            //forcely advanced key-frame of video by manual tick
	            video.currentTime = video.currentTime + elapsed;

	            var calculatedWidth = getCalculatedWidthHeight(isFullscreen).width;
	            var calculatedHeight = getCalculatedWidthHeight(isFullscreen).height;
	            var startX = getStartXY(isFullscreen).x;
	            var startY = getStartXY(isFullscreen).y;

	            resizeCanvas(isFullscreen);

	            //time gap between audio and video's key-frame(currentTime)
	            gap = Math.abs(audio.currentTime - video.currentTime);


	            //this will be start after user click un-mute to generate audio tag in the background
	            if (isAudioMute === false) {

	                //resync if exceed over x seconds
	                if (gap >= syncValue && gap <= limitSyncValue) {

	                    //synchorinize key-frame of video to match with audio's key-frame
	                    video.currentTime = audio.currentTime + elapsed;
	                    isSynched = true;
	                    syncValue = initialSyncValueAfter;
	                } else {
	                    isSynched = false;
	                }
	            }
	            //render video signal to canvas
	            if (!isFullscreen) {
	                canvasContext.drawImage(video, startX, startY, calculatedWidth, calculatedHeight);
	            } else {
	                canvasContext.drawImage(video, 0, 0, calculatedWidth, calculatedHeight);
	            }

	            cbTimeUpdate();


	            lasttime_ = time;
	        };

	        // render by frameCondition (this will help to reduce cpu/gpu consume) and also this will be effected by frameCondition
	        if (elapsed >= frameCondition) {
	            renderVideoIntoCanvas();
	        }

	        var currentTime = video.currentTime;//allow to have decimals to precisely calculate
	        var duration = video.duration;//allow to have decimals to precisely calculate
	        //verbose(currentTime + "/" + duration);

	        //complete when audio and video both finished
	        if (currentTime >= duration) {
	            verbose("close checking by iOSInlinePlayer");
	            if (isAudioMute === false) {//when unmute a logic should check audio completion even if the video completed
	                var currentTimeOfAudio = audio.currentTime;
	                var durationOfAudio = audio.duration;
	                if (currentTimeOfAudio >= durationOfAudio) {
	                    verbose("closed with audio by iOSInlinePlayer");
	                    cbWhenVideoComplete();
	                    isRunningForCanvas = false;//not allowing to re-enter this loop
	                    return;
	                }
	            } else {
	                verbose("closed by iOSInlinePlayer");
	                cbWhenVideoComplete();
	                isRunningForCanvas = false;//not allowing to re-enter this loop
	                return;
	            }

	        }

	        //if canvasPause is false, cavas animation will start until it set to true, pause/resume will work like that
	        if (canvasPause === false) {
	            animationFrame = requestAnimationFrame(function () {
	                renderingLoop(lasttime_);
	            });
	        } else {
	            isRunningForCanvas = false;
	        }

	    }

	    /**
	     * check screen is under portrait mode.
	     * @returns {boolean}
	     */
	    var isPortrait = function () {
	        return window.innerHeight > window.innerWidth;//check viewport is portrait state
	    };


	    /**
	     * check exit fullscreen in iPhone
	     */
	    var onVideoEndsFullScreen = function () {
	        this.resumeVideo();
	    };
	    /**
	     * calculate height to remain aspect ratio of video's
	     * @returns {{width: number, height: number}}
	     */
	    var getSizeOfVideoArea = function (isPortrait) {

	        //var windowWidth = window.document.body.clientWidth;
	        var windowWidth = window.innerWidth;
	        var windowHeight = 0;

	        windowHeight = window.innerHeight;//height considering iOS's addressbar
	        windowHeight = window.innerHeight;


	        var height;
	        var width;
	        var top;
	        var left;

	        //comment out some video having specfic aspectratio like 4:3 it will be broken in the fullscreen
	        if (!isPortrait) {

	            if (!isFullscreen) {
	                //for normal screen

	                //TODO hava a diffrent size matched with aspec ration of video
	                //height = windowHeight - heightOfToolbar;
	                //width = Math.round(height * videoAspectRatio);
	                //top = 0;
	                //left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position

	                //TODO to have a same size of window in landscape mode
	                //width = windowWidth;
	                //height = windowHeight - heightOfToolbar;
	                //top = 0;
	                //left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position


	                //TODO supporting iPAD
	                width = windowWidth;
	                height = pubOptions.height;

	                if (height >= windowHeight) {
	                    height = windowHeight - heightOfToolbar;
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = 0;
	                } else {
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = 0;
	                }
	            } else {
	                //for fullscreen
	                //TODO supporting iPAD
	                width = windowWidth;
	                height = Math.round(width / videoAspectRatio);

	                if (height >= windowHeight) {
	                    height = windowHeight - heightOfToolbar;
	                    width = Math.round(height * videoAspectRatio);
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = Math.round((windowWidth / 2) - (width / 2));//calculate middle position
	                } else {
	                    height = height - heightOfToolbar;
	                    top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                    left = 0;
	                }


	            }


	        } else {

	            //portrait mode
	            if (!isFullscreen) {
	                //normal screen
	                width = windowWidth;
	                //height = pubOptions.height - heightOfToolbar;
	                height = pubOptions.mediaHeight;
	                top = Math.round((windowHeight / 2)) + 100;//calculate middle position
	                left = 0;
	            } else {
	                //fullscreen
	                width = windowWidth;
	                height = Math.round(windowWidth / videoAspectRatio);
	                top = Math.round((windowHeight / 2) - (height / 2) - (heightOfToolbar / 2));//calculate middle position
	                left = 0;
	            }


	        }


	        //debug("*** : " + width + "," + height + "," + top + "," + left);


	        return {
	            "width": width,
	            "height": height,
	            "top": top,
	            "left": left
	        };
	    };

	    /**
	     * make fulll screen background. html5 fullscreen api doesn't work since iOS8 also has some problem inside of iframe, so it needs to be improved
	     */
	    var makeBackgroundScreen = function () {


	        targetElement.style.backgroundColor = "black";
	        targetElement.style.width = "100%";
	        targetElement.style.height = "100%";
	        targetElement.style.position = "fixed";
	        //targetElement.style.position = "absolute";
	        targetElement.style.top = "0px";
	        targetElement.style.left = "0px";
	        targetElement.style.zIndex = "999999";
	        targetElement.style.background = "rgba(0,0,0,1)";

	        targetElement.style.transition = "height 0s ease";

	        //make background transparent
	        el_wholeArea.style.background = "rgba(0,0,0,1)";
	        canvas.style.background = "rgba(0,0,0,1)";
	        iframeVideoWrapper.style.background = "rgba(0,0,0,1)";


	    };

	    /**
	     * hide background and rolling back css kept
	     */
	    var hideBackgroundScreen = function () {
	        //targetElement.style.cssText = cssTextOf_targetElement;
	        loadCSS(targetElement, cssTextOf_targetElement);

	        targetElement.style.height = getSizeOfVideoArea().height + "px";
	    };


	    /**
	     * start video for initial play
	     * @param e
	     */
	    var handleMetadata = function (e) {
	        videoAspectRatio = e.target.videoWidth / e.target.videoHeight;
	    };


	    var resizeFullscreenConsideringRotation = function () {

	        var isPortrait_ = isPortrait();
	        var sizeObject = getSizeOfVideoArea(isPortrait_);

	        var width = sizeObject.width;
	        var height = sizeObject.height;
	        var top = sizeObject.top;
	        var left = sizeObject.left;

	        //video in canvas can't have automatic flexible size becuase it's painted as a pixel(x,y) so need to recalculate size of video whenever rotation changed
	        iframeVideoWrapper.style.position = "absolute";
	        iframeVideoWrapper.style.width = width;
	        iframeVideoWrapper.style.height = height;
	        iframeVideoWrapper.style.top = top + "px";
	        iframeVideoWrapper.style.left = left + "px";

	        iframeVideoWrapper.style.marginRight = "";
	        iframeVideoWrapper.style.transform = "";

	        //change size for div under iframe
	        el_wholeArea.style.width = width + "px";
	        el_wholeArea.style.height = height + heightOfToolbar + "px";


	        //change size for canvase
	        canvas.style.width = width + "px";
	        canvas.style.height = height + "px";

	        //for VID-1903
	        el_wholeArea.style.marginLeft = "";
	        el_wholeArea.style.marginRight = "";


	    };


	    var _exitFullscreeenAsCanvas = function () {
	        //set full screen flag to avoid to enter resize for fullscreen when rotation change
	        isFullscreen = false;

	        //to release scroll in fullscreen
	        targetElement.ontouchmove = function () {
	            return true;
	        };
	        canvas.ontouchmove = function () {
	            return true;
	        };
	        el_wholeArea.ontouchmove = function () {
	            return true;
	        };


	        hideBackgroundScreen();

	        //rolback css attribute to original one
	        loadCSS(targetElement, cssTextOf_targetElement);
	        loadCSS(iframeVideoWrapper, cssTextOf_iframeVideoWrapper);
	        loadCSS(el_wholeArea, cssTextOf_el_wholeArea);
	        loadCSS(canvas, cssTextOf_canvas);
	    };


	    /**
	     * external interface : exit out of fullscreen
	     */
	    this.exitFullscreeenAsCanvas = function () {
	        _exitFullscreeenAsCanvas();
	    };


	    /**
	     * external interface : enter full screen (actually draw div layer to have 100% width and height) //TODO need to have
	     */
	    this.enterFullscreenAsCanvas = function () {

	        //to avoid scroll in fullscreen
	        targetElement.ontouchmove = function () {
	            return false;
	        };
	        canvas.ontouchmove = function () {
	            return false;
	        };
	        el_wholeArea.ontouchmove = function () {
	            return false;
	        };


	        //store original css attributes
	        cssTextOf_targetElement = saveCSS(targetElement);
	        cssTextOf_iframeVideoWrapper = saveCSS(iframeVideoWrapper);
	        cssTextOf_el_wholeArea = saveCSS(el_wholeArea);
	        cssTextOf_canvas = saveCSS(canvas);

	        //fix VID-2240
	        targetElement.style.marginLeft = "0px";
	        targetElement.style.marginRight = "0px";
	        targetElement.style.marginTop = "0px";
	        targetElement.style.marginBottom = "0px";


	        isFullscreen = true;
	        makeBackgroundScreen();


	        resizeFullscreenConsideringRotation();


	    };

	    /**
	     * external interface to playce intial play
	     */
	    this.initialPlay = function (enabledAudio) {

	        if (!isRunningForCanvas) {
	            canvasPause = false;

	            if (enabledAudio && audio && audio.play) {
	                audio.play();
	            }
	            renderingLoop(Date.now());//start rendering loop to forcely advance key-frame of html5 video object
	        }


	    };

	    /**
	     * external interface to resume video
	     */
	    this.resumeVideo = function () {

	        canvasPause = false;
	        if (audio && audio.play) {
	            audio.play();
	        }

	    };

	    /**
	     * external interface to pause video
	     */
	    this.pauseVideo = function () {

	        canvasPause = true;
	        audio.pause();
	    };


	    this.activateAudio = function () {
	        debug("activateAudio : " + video.src);

	        //activate audio
	        audio.style.display = "none";
	        audio.autoplay = false;
	        audio.preload = "auto";
	        audio.controls = true;
	        audioSource.src = video.src;//this should be required for vpaid

	        audio.appendChild(audioSource);
	        divArea.appendChild(audio);//this should be required for preload audio

	        audio.load();
	    };

	    /**
	     * external inrerface to activate audio
	     */
	    this.hearAudio = function () {//play audio should be started by human activity

	        //don't need to re-create audio tag if it's already there.
	        if (isAudioCreated) {
	            debug("resume audio");
	            isAudioMute = false;
	            audio.currentTime = video.currentTime;//first sync between audio and video
	            audio.play();
	            return;
	        }

	        audio.addEventListener("playing", function () {
	            debug("first playing audio");
	            audio.currentTime = video.currentTime + initialSyncValue;
	            isAudioMute = false;
	            isAudioCreated = true;
	        });

	        if (pubOptions.preloadInlineAudioForIos === false) {//if it's already loaded doesn't need to load again
	            this.activateAudio();
	        }
	        audio.currentTime = video.currentTime;//first sync between audio and video
	        audio.play();

	    };

	    /**
	     * kill the audio instance
	     */
	    this.stopAudio = function () {
	        debug("pausing audio");
	        audio.pause();
	        isAudioMute = true;
	    };

	    /**
	     * external interface to resize when orientation changed
	     */
	    this.checkOrientation = function () {

	        if (isTerminated && !pubOptions.disableCollapse) {
	            return;
	        }

	        if (!isFullscreen) {
	            //normal screen
	            resizeCanvas(isFullscreen);
	            redrawCanvas(isFullscreen);


	        } else {
	            //fullscreen
	            //_exitFullscreeenAsCanvas();
	            hideBackgroundScreen();
	            makeBackgroundScreen();
	            resizeFullscreenConsideringRotation();
	        }
	    };


	    /**
	     * external interface to intialize and initiate rendering
	     */
	    this.initiate = function () {
	        video.addEventListener("canplaythrough", handleMetadata.bind(this));//handle metadata to set aspectratio
	        video.addEventListener('webkitendfullscreen', onVideoEndsFullScreen, false);

	        //preload
	        video.load();
	        video.pause();
	    };


	    /**
	     * external interface to return canvas object to define click-to-browseout event
	     * @returns {object}
	     */
	    this.getCanvas = function () {
	        return canvas;
	    };


	    this.destroy = function () {

	        if (isFullscreen) {
	            _exitFullscreeenAsCanvas();
	        }

	        isTerminated = true;


	    };

	    this.resizeCanvas = resizeCanvas;

	    this.redrawCanvas = redrawCanvas;


	};
	module.exports = APN_InlineVideoPlayerForiOS;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(9);
	var _logger = __webpack_require__(2);
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: EmulateHtml5Video: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("iOSInlineVideoPlayer :: EmulateHtml5Video: " + message);
	};


	/**
	 * EmulateHtml5Video
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @returns {{handleFullScreen: "handleFullScreen", handleNormalScreen: "handleNormalScreen", resizeIosCanvas: "resizeIosCanvas", cbWhenVideoComplete: "cbWhenVideoComplete"}}
	 */
	module.exports = function (iOSInlinePlayerSelf, playerManager) {
	    return {
	        "handleFullScreen": function (iframeVideoWrapper) {
	            playerManager.isFullscreen = true;
	            debug("handleFullScreen");
	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");
	            iOSInlinePlayerSelf.dispatchEventToAdunit({
	                name: "fullscreenchange",
	                fullscreenStatus: "enter"
	            });
	            iOSInlinePlayerSelf.iOSVideoPlayer.enterFullscreenAsCanvas();
	            iOSInlinePlayerSelf.isFullscreen = true;
	            if (topChrome) {
	                topChrome.style.display = "none";
	            }
	            if (!iOSInlinePlayerSelf.options.disableTopBar) {
	                verbose("Hiding ad text for fullscreen");
	                iOSInlinePlayerSelf.floatingAdIndicator.style.display = "block";
	                if (iOSInlinePlayerSelf.floatingSkipButton) {
	                    if (iOSInlinePlayerSelf.readyForSkip) {
	                        iOSInlinePlayerSelf.floatingSkipButton.style.display = "block";
	                        iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
	                    } else {
	                        iOSInlinePlayerSelf.floatingSkipButton.style.display = "none";
	                        iOSInlinePlayerSelf.floatingAdSkipText.style.display = "block";
	                    }
	                }
	            }
	        },
	        "handleNormalScreen": function (iframeVideoWrapper) {

	            playerManager.isFullscreen = false;
	            debug("handleNormalScreen");
	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

	            iOSInlinePlayerSelf.dispatchEventToAdunit({
	                name: "fullscreenchange",
	                fullscreenStatus: "exit"
	            });

	            //iOSInlinePlayerSelf.options.targetElement.style.transition = "height 0s ease";
	            if (topChrome) {
	                topChrome.style.display = "block";
	            }
	            if (!iOSInlinePlayerSelf.options.disableTopBar) {
	                verbose("Showing ad text for fullscreen");
	                iOSInlinePlayerSelf.floatingAdIndicator.style.display = "none";
	                if (iOSInlinePlayerSelf.floatingSkipButton) {
	                    iOSInlinePlayerSelf.floatingSkipButton.style.display = "none";
	                    iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
	                }
	            }
	            iOSInlinePlayerSelf.iOSVideoPlayer.exitFullscreeenAsCanvas();


	            iOSInlinePlayerSelf.isFullscreen = false;


	            var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStream && playerManager.options.sideStream.enabled && playerManager.options.sideStreamObject && playerManager.options.sideStreamObject.isActivated;
	            if (shouldNotResizeWhenSideStreamActivated === false) {
	                iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);//resizePlayer and change height of targetElement to have same value with video
	            }
	            iOSInlinePlayerSelf.resizeIosCanvas(iOSInlinePlayerSelf.isFullscreen);//resize canvase size and redraw 1 frame of the video which is cuurently playing or paused, this should be performed after video.js UI has changed


	            var videoObject = document.getElementById(playerManager.videoObjectId);
	            if (videoObject && typeof(videoObject) !== "undefined") {
	                videoObject.style.width = iOSInlinePlayerSelf.options.width;
	                videoObject.style.height = iOSInlinePlayerSelf.options.height;
	            }

	            //VID-2143
	            var isSideStreamEnabled = playerManager.options.sideStream && playerManager.options.sideStream.enabled;
	            var isSideStreamStarted = playerManager.options.sideStreamObject && typeof(playerManager.options.sideStreamObject.moveAdUnitBack) === "function";
	            if (isSideStreamEnabled && isSideStreamStarted) {
	                playerManager.options.sideStreamObject.moveAdUnitBack();
	            }

	        },
	        "resizeIosCanvas": function (isFullscreen_) {
	            /**
	             * resizeIosCanvas : this will resize canvas and redraw last position of the iOS inline video
	             * @param isFullscreen_
	             */
	            iOSInlinePlayerSelf.iOSVideoPlayer.resizeCanvas(isFullscreen_);
	            iOSInlinePlayerSelf.iOSVideoPlayer.redrawCanvas(isFullscreen_);
	        },
	        "cbWhenVideoComplete": function (iframeVideoWrapper, el_videoArea) {

	            debug("cbWhenVideoComplete");

	            if (iOSInlinePlayerSelf.isAlreadyDoneVideoComplete) {//VID-1510
	                return;
	            }

	            iOSInlinePlayerSelf.isAlreadyDoneVideoComplete = true;
	            if (iOSInlinePlayerSelf.isFullscreen) {
	                iOSInlinePlayerSelf.fromFullscreen = true;
	                iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
	            }

	            // remove control bar items
	            verbose("removing control bar items");
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.currentTimeDisplay.hide();
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.durationDisplay.hide();
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.timeDivider.hide();
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.hide();
	            // VID-1892 The buttons may not be present if iOSInlinePlayerSelf.options(Ex:allowFullscreen) are false.
	            if (iOSInlinePlayerSelf.customPlayToggle) {
	                iOSInlinePlayerSelf.customPlayToggle.style.display = 'none';
	            }
	            if (iOSInlinePlayerSelf.customFullscreenBtn) {
	                iOSInlinePlayerSelf.customFullscreenBtn.style.display = 'none';
	            }

	            verbose("destroying iOSVideoPlayer");
	            iOSInlinePlayerSelf.iOSVideoPlayer.destroy();
	            iOSInlinePlayerSelf.resizeIosCanvas(iOSInlinePlayerSelf.isFullscreen);


	            if (!iOSInlinePlayerSelf.options.disableCollapse) {
	                window.removeEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);
	                window.removeEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
	            }

	            var callbackFunctionAfterVideoComplete = function () {
	                //following all flags should set after "video_complete" tracking triggered. if it's earlier triggered video_complete will be ignored.
	                if (!iOSInlinePlayerSelf.options.disableCollapse) {
	                    playerManager.isFullscreen = true;//Outstream will check this flag to select way of termination
	                    playerManager.destroyWithoutSkip();//this actual termination logic should be invoked after video_complete triggered. so this callbackFunctionAfterVideoComplete is being passed into eventHandling logic
	                }
	                playerManager.isCompleted = true;
	                if (iOSInlinePlayerSelf.options.vpaid) {
	                    utils.fireEvent(el_videoArea, "ended");// Fire ended event on video for VID-1367
	                }
	            };
	            iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_complete"}, callbackFunctionAfterVideoComplete);//this callback will be invoked after video_complete
	        }
	    };
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {



	var utils = __webpack_require__(9);
	var JSVPAIDConfigure = __webpack_require__(12);
	var _logger = __webpack_require__(2);
	var log = function (message) {
	    _logger.log("iOSInlineVideoPlayer: " + message);
	};
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: Events: " + message);
	};
	var error = function (message) {
	    _logger.error("iOSInlineVideoPlayer :: Events: " + message);
	};

	/**
	 * Events
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 * @returns {{fnMainProcess: "fnMainProcess"}}
	 */
	module.exports = function (iOSInlinePlayerSelf, playerManager, cbInjectEventToPlayer) {
	    return {
	        "fnMainProcess": function (iframeVideoWrapper) {

	            /**
	             * seconds step excutes after createIframe
	             * @param iframeVideoWrapper
	             */
	            log("fnMainProcess");

	            //expose video object in iframe
	            var an_video_ad_player = iframeVideoWrapper.contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_id);
	            playerManager.iframeVideoWrapper = iframeVideoWrapper;

	            //activate JSVPAID plug-in this should be actiavated before video.js intialized
	            if (iOSInlinePlayerSelf.options.vpaid) {
	                try {
	                    JSVPAIDConfigure(playerManager);
	                } catch (ex) {
	                    error(ex);
	                }
	            } else {
	                //Cleanup previous plugin reference.
	                if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.plugins){
	                    iOSInlinePlayerSelf.options.plugins = null;
	                }
	            }

	            iOSInlinePlayerSelf.options.nativeControlsForTouch = false;
	            iOSInlinePlayerSelf.options.customControlsOnMobile = false;
	            //create player object from video.js. this is required to have same code with regular one which is not iOS inline video
	            iOSInlinePlayerSelf.videojsPlayer = iOSInlinePlayerSelf.videojsOrigin(an_video_ad_player, iOSInlinePlayerSelf.options, function () {
	            });


	            __webpack_require__(17)(iOSInlinePlayerSelf, playerManager, cbInjectEventToPlayer, iOSInlinePlayerSelf.videojsPlayer, iframeVideoWrapper).run();

	            playerManager.adVideoPlayer = iOSInlinePlayerSelf.videojsPlayer;//inject video.js API reference to outside. this object includes all methods supported by video.js and html objects generated by video.js for example) controlbar, volume controls etc..

	            var el_wholeArea = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_id);//whole video area inside iframe
	            var el_videoArea = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_html5_api_id);//html5 video object inside iframe

	            if (iOSInlinePlayerSelf.options.enableInlineVideoForIos === true) {
	                //el_videoArea.style.visibility = "hidden";//html5 video should be hidden when ios-inline-player activated and it should be set before video.load() because of iOS limitation see this ticket https://jira.corp.appnexus.com/browse/VID-2096
	                el_videoArea.style.width = "0.1px";
	                el_videoArea.style.height = "0.1px";
	            }

	            var tmp = document.createElement("div");
	            tmp.style.position = "absolute";
	            tmp.style.top = "0px";
	            tmp.style.left = "0px";
	            if (!iOSInlinePlayerSelf.options.vpaid) {
	                tmp.className = "vjs-tech";//if some div uses 'vjs-tech' as a CSS className, JSVPAID will regard that must be video object
	            }
	            tmp.style.textAlign = "center";
	            el_wholeArea.insertBefore(tmp, el_videoArea);//inject target div defore video tag






	            //register this resize function to be invked by sideStream
	            iOSInlinePlayerSelf.options.targetElement.addEventListener("IOS_INLINE_RESIZE", function () {
	                iOSInlinePlayerSelf.resizeIosCanvas(false);
	            });

	            iOSInlinePlayerSelf.options.targetElement.addEventListener("IOS_INLINE_REFERESH", function () {
	                iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);
	                iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                iOSInlinePlayerSelf.customFullscreenBtn.style.visibility = "hidden";//hide fullscreen because iOS custom fullscreen feature doesn't work over unfriendly iframe - it only expands on the iframe area and that's not what we expect.
	            });

	            //iOSInlinePlayerSelf.options to render ios inline video
	            /**
	             * mediaURl : url of video
	             * divArea : div element to render canvas
	             * width : width of video player
	             * videoElement : video object to be used as source of video capturing
	             * cbWhenVideoComplete : callback when video completes
	             * targetElement : div element of publisher's site
	             * cbClickToBrowse : callback when click the video areas
	             * @type {{mediaUrl: (string|*), divArea: Element, width: *, videoElement: Element, cbWhenVideoComplete: Function, targetElement: (*|string), cbClickToBrowse: (*|adVideoPlayerManager.click|Function|x.event.special.click|{trigger, _default}|SCOPE.reportAnalytics.click)}}
	             */

	            var optionForInlineVideo = {
	                "mediaUrl": iOSInlinePlayerSelf.options.videoUrl,
	                "divArea": tmp,
	                "width": iOSInlinePlayerSelf.options.width,
	                "height": iOSInlinePlayerSelf.options.height,
	                "videoElement": el_videoArea,
	                "cbWhenVideoComplete": function() {iOSInlinePlayerSelf.cbWhenVideoComplete(iframeVideoWrapper,el_videoArea);},
	                "targetElement": iOSInlinePlayerSelf.options.targetElement,
	                "iframeVideoWrapper": iframeVideoWrapper,
	                "el_wholeArea": el_wholeArea,
	                "cbTimeUpdate": function () {
	                    iOSInlinePlayerSelf.videojsPlayer.trigger("timeupdate");
	                }
	            };

	            var waterfallStepId = iOSInlinePlayerSelf.options.isWaterfall ? iOSInlinePlayerSelf.options.waterfallStepId : null;

	            iOSInlinePlayerSelf.iOSVideoPlayer.setPubOptions(iOSInlinePlayerSelf.options);

	            /**
	             * render inline video with options callback will invoke with flag(isAcceptable) after it preapred to start
	             */
	            iOSInlinePlayerSelf.iOSVideoPlayer.renderVideo(optionForInlineVideo, function (isAcceptable) {
	                if (!isAcceptable) {
	                    debug("only works in iOS");
	                    return;
	                } else {

	                    iOSInlinePlayerSelf.eventOrientationChange = function () {//event handler whenever change rotation completed

	                        if(waterfallStepId && waterfallStepId !== iOSInlinePlayerSelf.options.waterfallStepId){
	                            // Ignore the events as these are from previous ad attempts;
	                            return;
	                        }
	                        if (playerManager.isReadyToExpandForMobile) {//for VID-1515

	                            var shouldNotResizeWhenSideStreamActivated = playerManager.options.sideStreamObject  && typeof(playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	                            if (shouldNotResizeWhenSideStreamActivated) {
	                                return;
	                            }
	                            iOSInlinePlayerSelf.refreshVideoLookAndFeel(iOSInlinePlayerSelf.options, playerManager);
	                            iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                        }
	                    };

	                    iOSInlinePlayerSelf.eventSizeChange = function () {//event handler to catch a moment when ios addressbar appears
	                        if(waterfallStepId && waterfallStepId !== iOSInlinePlayerSelf.options.waterfallStepId){
	                            // Ignore the events as these are from previous ad attempts;
	                            return;
	                        }
	                        if (iOSInlinePlayerSelf.isFullscreen) {//resize all when iOS h/w addressbar appears
	                            playerManager.resizeVideo(-1, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);
	                            iOSInlinePlayerSelf.iOSVideoPlayer.checkOrientation();
	                        }
	                    };

	                    window.addEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
	                    window.addEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);

	                    el_videoArea.onseeked = function () {
	                        return false;
	                    };
	                    if(iOSInlinePlayerSelf.options.initialPlayback === "auto"){
	                        iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.show();
	                    }else{
	                        iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.hide();
	                    }
	                    iOSInlinePlayerSelf.videojsPlayer.player().off('seeked');//stop seeking because we don't use html5 video tag playing

	                    iOSInlinePlayerSelf.iOSVideoPlayer.initiate();//generate required tag and initiate
	                }
	            });


	            iOSInlinePlayerSelf.videojsPlayer.controlBar.fullscreenToggle.dispose();//dispose exisitng fullscreen icon which has lots of issue causing by event bubbleing from video.js in its Component block

	            if (iOSInlinePlayerSelf.options.allowFullscreen === true && iOSInlinePlayerSelf.enableFullscreen) {

	                iOSInlinePlayerSelf.customFullscreenBtn = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    'id': 'customFullscreenToggle',
	                    'role': 'button',
	                    //'innerHTML': 'FullScreen',
	                    'innerHTML': '<div class="vjs-control-content"><span class="vjs-control-text">Fullscreen</span></div>'
	                });
	                iOSInlinePlayerSelf.customFullscreenBtn.style.cssText = "text-align:right;float:right;margin-right:0em;font-size:1em;line-height:3em;outline:0;position:relative;padding:0;height:3em";

	                iOSInlinePlayerSelf.customFullscreenBtn.className = "vjs-fullscreen-control vjs-control";

	                iOSInlinePlayerSelf.videojsPlayer.controlBar.addChild('button', {
	                    'el': iOSInlinePlayerSelf.customFullscreenBtn
	                });

	                /**
	                 * handle fullscreen on inline inveo
	                 */
	                iOSInlinePlayerSelf.customFullscreenBtn.addEventListener("touchend", function (e) {

	                    if (!iOSInlinePlayerSelf.isFullscreen) {
	                        iOSInlinePlayerSelf.handleFullScreen(iframeVideoWrapper);
	                    } else {
	                            var videoElement = document.getElementById(iOSInlinePlayerSelf.options.iframeVideoWrapperId).contentWindow.document.getElementById(iOSInlinePlayerSelf.an_video_ad_player_html5_api_id);//html5 video object inside iframe
	                            var originalVisibilityOfVideo = videoElement.style.visibility;
	                            videoElement.style.visibility = "hidden";//for VID-2793, some of jsvpaid creative can have unexpected event from windows during this switching if video deosn't have hidden attribute at this short moment in iOS10 with inline module, but it will be restored immediately
	                            setTimeout(function() {
	                                iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);
	                                videoElement.style.visibility = originalVisibilityOfVideo;//restore previous visilibity state
	                            },0);//block async execution
	                    }
	                    e.preventDefault();
	                });

	                iOSInlinePlayerSelf.customFullscreenBtn.addEventListener("click", function () {
	                    if (!iOSInlinePlayerSelf.isFullscreen) {
	                        iOSInlinePlayerSelf.handleFullScreen(iframeVideoWrapper);

	                    } else {
	                        iOSInlinePlayerSelf.handleNormalScreen(iframeVideoWrapper);

	                    }

	                });
	            }


	            /**
	             * click to browse, this will get canvas object through getCanvas() interface of ios inline video player and dispatch signal to API
	             */
	            iOSInlinePlayerSelf.iOSVideoPlayer.getCanvas().onclick = function () {
	                if (iOSInlinePlayerSelf.options.learnMore.enabled === false) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();//this pause should be called because of internal issue on iOSInlineCore. but this pause doesn't belong pause event.
	                    playerManager.click();
	                } else if (iOSInlinePlayerSelf.options.learnMore.clickToPause === true) {
	                    if (iOSInlinePlayerSelf.isTogglePaused === false) {
	                        playerManager.explicitPause();
	                    } else {
	                        playerManager.explicitPlay();
	                    }
	                }
	            };

	            //function to switch an playtoggle icon
	            var havePauseStatusIcon = function (isPaused) {
	                if (isPaused) {
	                    iOSInlinePlayerSelf.customPlayToggle.innerHTML = '<div><span>&#xe001;</span></div>';//icon to pause video
	                } else {
	                    iOSInlinePlayerSelf.customPlayToggle.innerHTML = '<div><span>&#xe002;</span></div>';//icon to play video
	                }
	            };


	            var simulateHtml5VideoPlay = function () {
	                /**
	                 * this is for overriding play method in html5 video
	                 * it support intial play and resume video by "isPlayingVideo" flag
	                 * if it's true it will resume a video, if else it will do initial play a video
	                 */
	                //hide play button
	                iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.hide();
	                iOSInlinePlayerSelf.videojsPlayer.player().loadingSpinner.hide();//hide loading spinner

	                iOSInlinePlayerSelf.videojsPlayer.player().addClass("vjs-has-started");
	                iOSInlinePlayerSelf.videojsPlayer.player().removeClass('vjs-paused');
	                iOSInlinePlayerSelf.videojsPlayer.player().addClass('vjs-playing');

	                //play video when its fist play
	                try {
	                    havePauseStatusIcon(false);

	                    var enabledAudio = iOSInlinePlayerSelf.enabledAudio;
	                    iOSInlinePlayerSelf.iOSVideoPlayer.initialPlay(enabledAudio);//invoke initialPlay in iOSVideoPlayer, this initialPlay will set a required value for initial playing
	                    debug("override play method");

	                    if (!iOSInlinePlayerSelf.isDoneiOSInitialPlay) {
	                        utils.fireEvent(el_videoArea, "play");//for VID-1331
	                        iOSInlinePlayerSelf.isDoneiOSInitialPlay = true;
	                    } else {
	                        utils.fireEvent(el_videoArea, "playing");//for VID-1331
	                    }

	                    playerManager.isPlayingVideo = true;
	                    iOSInlinePlayerSelf.isTogglePaused = false;
	                } catch (ex) {
	                    error(ex);
	                }
	            };

	            /**
	             * pause
	             */
	            var simulateHtml5VideoPause = function () {

	                if (iOSInlinePlayerSelf.isTogglePaused) {

	                    return;//don't need to do again when it's already paused.
	                }

	                if (playerManager.isCompleted) {
	                    return;
	                }

	                //show big play button
	                iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.show();
	                iOSInlinePlayerSelf.videojsPlayer.player().bigPlayButton.el().style.display = "block";

	                iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
	                debug("override pause method");

	                havePauseStatusIcon(true);
	                iOSInlinePlayerSelf.isTogglePaused = true;

	                utils.fireEvent(el_videoArea, "pause");//for VID-1331,VID-1510

	            };


	            //override play & pause method which is under html5 object to intercept flow in html5
	            var overrideNativeMethodForVideo = function () {
	                var checkAndLoadVideo = function (el) {
	                    if (el && el.readyState === 0) {
	                        el.load();//this is required for start inline video player
	                    }
	                };

	                el_videoArea.play = function () {
	                    checkAndLoadVideo(el_videoArea);
	                    simulateHtml5VideoPlay();
	                };
	                el_videoArea.pause = function () {
	                    simulateHtml5VideoPause();
	                };

	                iOSInlinePlayerSelf.videojsPlayer.one("vpaid.AdStarted", function () {//after vpaid returns "AdStarted" the video object would have a src attribute to be able to load immediately
	                    checkAndLoadVideo(el_videoArea);
	                });

	                iOSInlinePlayerSelf.videojsPlayer.one("an.readytogovpaid", function () {//after vpaid returns "AdStarted" the video object would have a src attribute to be able to load immediately
	                    iOSInlinePlayerSelf.iOSVideoPlayer.activateAudio();
	                    checkAndLoadVideo(el_videoArea);
	                });


	            };


	            if (iOSInlinePlayerSelf.options.vpaid) {
	                overrideNativeMethodForVideo();
	            } else {
	                el_videoArea.play = simulateHtml5VideoPlay;
	                el_videoArea.pause = simulateHtml5VideoPause;
	            }

	            /**
	             * //TODO for ios limiation we can't use html5 standard full screen api, so for several reason related human's behavoir we will need to igonre gesture in the full screen of ios video player
	             */
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.el().ontouchend = function () {
	            };


	            /**
	             * handle pause / resume
	             */
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.playToggle.dispose();//dispose to disconnect video.js event
	            iOSInlinePlayerSelf.customPlayToggle = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                'id': 'customPlayToggle',
	                'role': 'button',
	                'aria-live': 'polite',
	                'tabindex': '0',
	                'innerHTML': '<div><span>&#xe002;</span></div>',
	                'width': '5em'
	            });
	            iOSInlinePlayerSelf.customPlayToggle.style.cssText = "float:left;font-family:VideoJS;font-size:1.5em;line-height:2;width:3em;height:100%;text-align:center";
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.addChild('button', {
	                'el': iOSInlinePlayerSelf.customPlayToggle
	            });
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.el().insertBefore(iOSInlinePlayerSelf.customPlayToggle, iOSInlinePlayerSelf.videojsPlayer.controlBar.currentTimeDisplay.el());

	            iOSInlinePlayerSelf.customPlayToggle.ontouchend = function (e) {

	                if (iOSInlinePlayerSelf.isTogglePaused === false) {
	                    playerManager.explicitPause();
	                } else {
	                    playerManager.explicitPlay();
	                }

	                e.preventDefault();
	            };
	            iOSInlinePlayerSelf.customPlayToggle.onclick = function () {

	                if (iOSInlinePlayerSelf.isTogglePaused === false) {
	                    playerManager.explicitPause();
	                } else {
	                    playerManager.explicitPlay();
	                }
	            };

	            /**
	             * handle unmute to initiaite audio
	             */
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el().ontouchend = function () {


	                if (!iOSInlinePlayerSelf.enabledAudio) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.hearAudio();
	                    iOSInlinePlayerSelf.enabledAudio = true;
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "1";
	                    playerManager.dispatchEventToAdunit({"name": "video_unmute"});

	                    if (iOSInlinePlayerSelf.isTogglePaused === true) {//if paused, not playing audio
	                        iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
	                    }
	                } else {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.stopAudio();
	                    iOSInlinePlayerSelf.enabledAudio = false;
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
	                    playerManager.dispatchEventToAdunit({"name": "video_mute"});
	                }
	            };
	            iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el().onclick = function () {


	                if (!iOSInlinePlayerSelf.enabledAudio) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.hearAudio();
	                    iOSInlinePlayerSelf.enabledAudio = true;
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "1";

	                    if (iOSInlinePlayerSelf.isTogglePaused === true) {//if paused, not playing audio
	                        iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
	                    }
	                } else {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.stopAudio();
	                    iOSInlinePlayerSelf.enabledAudio = false;

	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
	                }
	            };

	            //invoke cbWhenReady immediately for jspaid
	            iOSInlinePlayerSelf.videojsPlayer.one("loadedmetadata", function (e) {//one time handlers because iOS core also invoke .load so we have to supress seconds event
	                if (iOSInlinePlayerSelf.options.showPlayToggle === false) {
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.playToggle.hide();
	                }

	                if (iOSInlinePlayerSelf.options.showBigPlayButton === false) {
	                    iOSInlinePlayerSelf.videojsPlayer.bigPlayButton.hide();
	                }


	            //set showMute
	                if (iOSInlinePlayerSelf.options.showMute === false) {
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.hide();
	                } else {
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.show();//always show unmute
	                    iOSInlinePlayerSelf.videojsPlayer.controlBar.muteToggle.el_.style.opacity = "0.3";
	                }


	                if (playerManager.options.vpaid) {
	                    return;//VID1707 - vapid creative shouldn't be handled by loadedmetata. it only works with vpaid event
	                }

	                playerManager.isReadyToExpandForMobile = true;

	                playerManager.videoObjectId = e.currentTarget.id;

	                debug("loadedmetadata");
	                debug("video.js is ready to play");

	                //disable click to play
	                iOSInlinePlayerSelf.videojsPlayer.tech.removeControlsListeners();

	                //get real video size
	                var realVideoWidth = e.currentTarget.videoWidth;
	                var realVideoHeight = e.currentTarget.videoHeight;
	                var aspectRatio = realVideoWidth / realVideoHeight;


	                if (realVideoWidth > 0) {
	                    playerManager.resizeVideo(aspectRatio, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);

	                    if (typeof iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady === "function") {
	                        iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                    }
	                } else {
	                    //if the event doesn't return a videoWidth
	                    playerManager.resizeVideo(0, iOSInlinePlayerSelf.shouldConsiderHeightOfDevice);
	                    iOSInlinePlayerSelf.callbackForAdUnit.cbWhenReady(playerManager);
	                }

	            });

	            //custom skinning
	            playerManager.customSkinning.render(iOSInlinePlayerSelf,iOSInlinePlayerSelf.videojsPlayer,iframeVideoWrapper.contentWindow.document,true);


	            cbInjectEventToPlayer(el_wholeArea, el_videoArea);//inject generate html object to next step of video player manager

	            if (iOSInlinePlayerSelf.options.vpaid) {
	                iOSInlinePlayerSelf.videojsPlayer.trigger("an.doneInitialize");
	            }

	        },
	    };

	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	//stop js-hint warning for dot notation
	/*jshint -W069 */

	var _logger = __webpack_require__(2);
	var debug = function (message) {
	    _logger.debug("iOSInlineVideoPlayer :: CustomizeVideoArea: " + message);
	};
	var verbose = function (message) {
	    _logger.verbose("Video Player: " + message);
	};

	var CONST_MESSAGE_GENERAL_ERROR = "General error reported from HTML5 video player (iOS inline)";


	/**
	 * CustomizeVideoArea
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 * @param videojsPlayer
	 * @param iframeVideoWrapper
	 * @returns {{run: "run"}}
	 */
	module.exports = function(iOSInlinePlayerSelf,playerManager, cbInjectEventToPlayer,videojsPlayer, iframeVideoWrapper) {
	    return {
	        "run": function () {

	            debug("run");

	            /**
	             * customize video.js UI by by options coming from impbus or publisher's site
	             */

	            if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.vpaid){
	                //For vpaid ads in waterfall hide controls until the impression occurs to avoid flicker during failed attempts.
	                videojsPlayer.controlBar.hide();
	                if(iOSInlinePlayerSelf.options.firstAdAttempted) {
	                    videojsPlayer.bigPlayButton.hide();
	                }
	            }

	            if (typeof iOSInlinePlayerSelf.options.customButton.enabled === "boolean" && iOSInlinePlayerSelf.options.customButton.enabled === true) {
	                var controlBarHeight = iOSInlinePlayerSelf.options.playerSkin.controlBarHeight || 30;
	                var imgWidth = Math.min(50,iOSInlinePlayerSelf.options.customButton.imgWidth);
	                var imgHeight = Math.min(controlBarHeight,iOSInlinePlayerSelf.options.customButton.imgHeight);
	                var topMargin = Math.floor((controlBarHeight-imgHeight)/2);

	                var customButton = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    'innerHTML': '<span ><img style="height:'+imgHeight+'px;width:'+imgWidth+'px;margin-top:'+topMargin+'px" class="home-button-image" src="'+iOSInlinePlayerSelf.options.customButton.imageSrc+'" alt="'+iOSInlinePlayerSelf.options.customButton.altText+'"></span>',
	                    'role': 'button',
	                    'aria-live': 'polite',
	                    'tabindex': '0'
	                });

	                customButton.style.cssText = "float:right;font-family:VideoJS;font-size:1.5em;line-height:2;width:50px;height:100%;text-align:center";
	                videojsPlayer.controlBar.addChild('button', {
	                    'el': customButton
	                });
	                videojsPlayer.controlBar.el().insertBefore(customButton, videojsPlayer.controlBar.fullscreenToggle.el());
	            }

	            //set showProgressBar
	            videojsPlayer.controlBar.progressControl.seekBar.seekHandle.hide();
	            videojsPlayer.controlBar.progressControl.seekBar.el_.style.pointerEvents = 'none';
	            if (typeof iOSInlinePlayerSelf.options.showProgressBar === "boolean") {
	                if (iOSInlinePlayerSelf.options.showProgressBar === false) {
	                    verbose("removing progress bar");
	                    videojsPlayer.controlBar.currentTimeDisplay.hide();
	                    videojsPlayer.controlBar.timeDivider.hide();
	                    videojsPlayer.controlBar.durationDisplay.hide();
	                }
	                videojsPlayer.controlBar.progressControl.seekBar.hide();
	            } else {
	                if (iOSInlinePlayerSelf.options.showProgressBar === "text") {
	                    verbose("removing progress text");
	                    videojsPlayer.controlBar.progressControl.seekBar.hide();
	                } else if (iOSInlinePlayerSelf.options.showProgressBar === "bar") {
	                    verbose("removing progress bar");
	                    videojsPlayer.controlBar.currentTimeDisplay.hide();
	                    videojsPlayer.controlBar.timeDivider.hide();
	                    videojsPlayer.controlBar.durationDisplay.hide();
	                }
	            }

	            //set showVolumee
	            if (iOSInlinePlayerSelf.options.showVolume === false) {
	                videojsPlayer.controlBar.volumeControl.dispose();
	            }

	            //options.bottomDividerColor and iOSInlinePlayerSelf.options.bottomDividerWidth is gurantted by ExtendDefaultOpions.js to have a some default value
	            //create custom divider
	            var customDivider = iOSInlinePlayerSelf.videojsOrigin.createEl('div');
	            customDivider.className = "vjs-control-bar-divider";
	            //minthe : comment out beacuse "customDividerColor" is defined but never used
	            /*
	             var customDividerColor = (function () {
	             return "#" + iOSInlinePlayerSelf.options.bottomDividerColor.toLowerCase().replace("0x", "");
	             })(iOSInlinePlayerSelf.options.customDividerColor);
	             */
	            //set css for divider
	            customDivider.style['position'] = "absolute";
	            customDivider.style['left'] = "0";
	            customDivider.style['right'] = "0";
	            //add divder to controlbar
	            videojsPlayer.controlBar.addChild('button', {
	                'el': customDivider
	            });

	            var topChrome = iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");

	            var adIndicatorText = iframeVideoWrapper.contentWindow.document.createElement("div");
	            adIndicatorText.id = "ad_indicator_text";

	            var adIndicatorTextContent = iOSInlinePlayerSelf.options.adText;
	            if (iOSInlinePlayerSelf.options.learnMore.enabled === true) {
	                if (iOSInlinePlayerSelf.options.skippable.skipLocation === "top-right") {
	                    adIndicatorTextContent = iOSInlinePlayerSelf.options.learnMore.text + " " + iOSInlinePlayerSelf.options.learnMore.separator + " " + adIndicatorTextContent;
	                } else {
	                    adIndicatorTextContent += " " + iOSInlinePlayerSelf.options.learnMore.separator + " " + iOSInlinePlayerSelf.options.learnMore.text;
	                }
	            }

	            adIndicatorText.innerHTML = adIndicatorTextContent;
	            adIndicatorText.className = 'top-bar-text';
	            adIndicatorText.role = 'button';

	            adIndicatorText.style['text-align'] = "right";
	            adIndicatorText.style['margin-right'] = "1em";
	            adIndicatorText.style['margin-left'] = "1em";
	            adIndicatorText.style['font-size'] = "1em";
	            adIndicatorText.style['right'] = "0px";
	            adIndicatorText.style['left'] = "";
	            adIndicatorText.style['line-height'] = "24px";
	            adIndicatorText.style['outline'] = "0";
	            adIndicatorText.style['position'] = "absolute";
	            adIndicatorText.style['padding'] = "0";
	            adIndicatorText.style['height'] = "auto";
	            adIndicatorText.style['width'] = "auto";
	            adIndicatorText.style['max-width'] = "35%";
	            adIndicatorText.style['white-space'] = "nowrap";
	            adIndicatorText.style['overflow'] = "hidden";
	            adIndicatorText.style['text-overflow'] = "ellipsis";

	            iOSInlinePlayerSelf.floatingAdIndicator = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                'role': 'button',
	                'innerHTML': adIndicatorTextContent,
	                'className': "top-bar-text"
	            });

	            iOSInlinePlayerSelf.floatingAdIndicator.style['text-align'] = "right";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['margin-right'] = "1em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['margin-left'] = "1em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['font-size'] = "1em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['right'] = "0px";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['left'] = "";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['line-height'] = "3em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['outline'] = "0";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['position'] = "absolute";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['padding'] = "0";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['height'] = "3em";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['max-width'] = "35%";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['width'] = "auto";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['text-overflow'] = "ellipsis";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['white-space'] = "nowrap";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['overflow'] = "hidden";
	            iOSInlinePlayerSelf.floatingAdIndicator.style['display'] = "none";
	            videojsPlayer.addChild('button', {
	                'el': iOSInlinePlayerSelf.floatingAdIndicator
	            });

	            if (iOSInlinePlayerSelf.options.learnMore.enabled === true) {
	                var learnMoreHandler = function(e) {
	                    iOSInlinePlayerSelf.iOSVideoPlayer.pauseVideo();
	                    playerManager.click();
	                    e.stopPropagation();
	                    e.preventDefault(); // prevents a touch event from also triggering a click event
	                };

	                adIndicatorText.addEventListener("click", learnMoreHandler);
	                iOSInlinePlayerSelf.floatingAdIndicator.addEventListener("click", learnMoreHandler);

	            }


	            var skipButton;
	            var adSkipText;

	            //set skip button
	            if (iOSInlinePlayerSelf.options.skippable.enabled === true) {

	                var videoThreshold = iOSInlinePlayerSelf.options.skippable.videoThreshold;
	                var skipText = iOSInlinePlayerSelf.options.skippable.skipText;
	                var skipButtonText = iOSInlinePlayerSelf.options.skippable.skipButtonText;

	                skipButton = iframeVideoWrapper.contentWindow.document.createElement("div");
	                skipButton.id = "skip_button";

	                skipButton.innerHTML = skipButtonText;
	                skipButton.className = 'top-bar-text';
	                skipButton.role = 'button';

	                skipButton.style['display'] = "none";
	                skipButton.style['cursor'] = "pointer";
	                skipButton.style['font-weight'] = "bold";
	                skipButton.style['margin-right'] = "1em";
	                skipButton.style['margin-left'] = "1em";
	                skipButton.style['font-size'] = "1em";
	                skipButton.style['right'] = "";
	                skipButton.style['left'] = "0px";
	                skipButton.style['line-height'] = "24px";
	                skipButton.style['outline'] = "0";
	                skipButton.style['position'] = "absolute";
	                skipButton.style['padding'] = "0";
	                skipButton.style['height'] = "5em";
	                skipButton.style['width'] = "auto";
	                skipButton.style['min-width'] = "5em";
	                skipButton.style['text-align'] = "left";

	                //skip button
	                iOSInlinePlayerSelf.floatingSkipButton = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    className: 'top-bar-text',
	                    'role': 'button',
	                    'innerHTML': skipButtonText
	                });

	                iOSInlinePlayerSelf.floatingSkipButton.style['display'] = "none";
	                iOSInlinePlayerSelf.floatingSkipButton.style['cursor'] = "pointer";
	                iOSInlinePlayerSelf.floatingSkipButton.style['font-weight'] = "bold";
	                iOSInlinePlayerSelf.floatingSkipButton.style['margin-right'] = "1em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['margin-left'] = "1em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['font-size'] = "1em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['right'] = "";
	                iOSInlinePlayerSelf.floatingSkipButton.style['left'] = "0px";
	                iOSInlinePlayerSelf.floatingSkipButton.style['line-height'] = "3em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['outline'] = "0";
	                iOSInlinePlayerSelf.floatingSkipButton.style['position'] = "absolute";
	                iOSInlinePlayerSelf.floatingSkipButton.style['padding'] = "0";
	                iOSInlinePlayerSelf.floatingSkipButton.style['height'] = "5em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['min-width'] = "5em";
	                iOSInlinePlayerSelf.floatingSkipButton.style['width'] = "auto";
	                iOSInlinePlayerSelf.floatingSkipButton.style['display'] = "none";
	                iOSInlinePlayerSelf.floatingSkipButton.style['text-align'] = "left";
	                videojsPlayer.addChild('button', {
	                    'el': iOSInlinePlayerSelf.floatingSkipButton
	                });

	                var handleSkip = function(e) {
	                    window.removeEventListener("orientationchange", iOSInlinePlayerSelf.eventOrientationChange);
	                    window.removeEventListener("resize", iOSInlinePlayerSelf.eventSizeChange);
	                    iOSInlinePlayerSelf.iOSVideoPlayer.destroy();
	                    playerManager.pause();
	                    playerManager.isFullscreen = iOSInlinePlayerSelf.isFullscreen;//to propogate iOS full screen state to VideoManager
	                    playerManager.forceToSkip = true;
	                    playerManager.destroy();
	                    playerManager.isCompleted = true;//added for VID-1035 moved for vid-1171
	                    e.stopPropagation();
	                    e.preventDefault();
	                    // videoObserver.disconnect();
	                };

	                skipButton.addEventListener("touchend", handleSkip);
	                skipButton.addEventListener("click", handleSkip);

	                iOSInlinePlayerSelf.floatingSkipButton.addEventListener("touchend", handleSkip);
	                iOSInlinePlayerSelf.floatingSkipButton.addEventListener("click", handleSkip);

	                adSkipText = iframeVideoWrapper.contentWindow.document.createElement("div");
	                adSkipText.id = "ad_skip_text";

	                adSkipText.innerHTML = skipButtonText;
	                adSkipText.className = 'top-bar-text';
	                adSkipText.role = 'button';

	                adSkipText.style['margin-left'] = "1em";
	                adSkipText.style['margin-right'] = "1em";
	                adSkipText.style['right'] = "";
	                adSkipText.style['left'] = "0px";
	                adSkipText.style['font-size'] = "1em";
	                adSkipText.style['line-height'] = "24px";
	                adSkipText.style['outline'] = "0";
	                adSkipText.style['position'] = "absolute";
	                adSkipText.style['text-align'] = "left";
	                adSkipText.style['padding'] = "0";
	                adSkipText.style['height'] = "3em";
	                adSkipText.style['width'] = "auto";
	                adSkipText.style['pointer-events'] = "none";
	                adSkipText.style['display'] = "none";



	                //skip text
	                iOSInlinePlayerSelf.floatingAdSkipText = iOSInlinePlayerSelf.videojsOrigin.createEl('div', {
	                    'role': 'button',
	                    'className': 'top-bar-text',
	                    'innerHTML': ""
	                });

	                iOSInlinePlayerSelf.floatingAdSkipText.style['margin-left'] = "1em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['margin-right'] = "1em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['right'] = "";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['left'] = "0px";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['font-size'] = "1em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['line-height'] = "3em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['outline'] = "0";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['position'] = "absolute";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['text-align'] = "left";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['padding'] = "0";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['height'] = "3em";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['width'] = "auto";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['pointer-events'] = "none";
	                iOSInlinePlayerSelf.floatingAdSkipText.style['display'] = "none";
	                videojsPlayer.addChild('button', {
	                    'el': iOSInlinePlayerSelf.floatingAdSkipText
	                });

	                //switch position by option
	                switch (iOSInlinePlayerSelf.options.skippable.skipLocation) {
	                    case "top-right":
	                        skipButton.style['right'] = "0px";
	                        skipButton.style['left'] = "";
	                        skipButton.style['text-align'] = "right";

	                        adSkipText.style['right'] = "0px";
	                        adSkipText.style['left'] = "";

	                        iOSInlinePlayerSelf.floatingSkipButton.style['right'] = "0px";
	                        iOSInlinePlayerSelf.floatingSkipButton.style['left'] = "";
	                        iOSInlinePlayerSelf.floatingSkipButton.style['text-align'] = "right";

	                        iOSInlinePlayerSelf.floatingAdSkipText.style['right'] = "0px";
	                        iOSInlinePlayerSelf.floatingAdSkipText.style['left'] = "";
	                        break;
	                    default :
	                        break;
	                }

	                //quartile status to invoke only once
	                var quartile1status = false;
	                var quartile2status = false;
	                var quartile3status = false;

	                var _trackedProgressOffsetSorted = {};

	                //handle tick event from video.js
	                videojsPlayer.on("timeupdate", function () {
	                    var _vastProgressEvent = playerManager.options.data.vastProgressEvent;

	                    if(iOSInlinePlayerSelf.options.isWaterfall && iOSInlinePlayerSelf.options.vpaid && !iOSInlinePlayerSelf.options.vpaidImpressionFired){
	                        return;
	                    }
	                    var currentTime = Math.round(videojsPlayer.player().currentTime());
	                    var _currentTimeMsec = currentTime * 1000;

	                    var offsetTime;
	                    if (playerManager.options.skippable.allowOverride) {
	                        offsetTime = Math.round(iOSInlinePlayerSelf.options.data.skipOffsetMsec / 1000);//trust vast3 setting
	                    } else {
	                        offsetTime = iOSInlinePlayerSelf.options.skippable.videoOffset;
	                    }


	                    var remainTime = offsetTime - currentTime;
	                    var videoDuration = Math.round(videojsPlayer.player().duration());

	                    //handle vast3 progress event
	                    if (_vastProgressEvent && typeof(_vastProgressEvent) === "object") {

	                        var _progressCallback = function () {
	                            playerManager.test("VIDLA163_Tracking", _trackedProgressOffsetSorted);
	                        };
	                        for (var _eventKey in _vastProgressEvent) {
	                            var _progressMsec = _vastProgressEvent[_eventKey];
	                            if (_progressMsec && _progressMsec >= 0 && _currentTimeMsec >= _progressMsec && Object.keys(_trackedProgressOffsetSorted).indexOf(_eventKey) === -1) {
	                                _trackedProgressOffsetSorted[_eventKey] = _progressMsec;
	                                var obj = {};
	                                obj.name = _eventKey;
	                                if (obj.name) {
	                                    playerManager.dispatchEventToAdunit(obj, _progressCallback);
	                                }
	                            }
	                        }
	                    }

	                    var needToShowSkip = (iOSInlinePlayerSelf.options.skippable.allowOverride) ? iOSInlinePlayerSelf.options.data.isVastVideoSkippable : true;
	                    needToShowSkip = (offsetTime > videoDuration) ? false :  needToShowSkip;
	                    playerManager.test("VIDLA163_needToShowSkip",needToShowSkip);
	                    if (videoThreshold <= videoDuration && !iOSInlinePlayerSelf.options.disableTopBar && needToShowSkip) {
	                        if (remainTime > 0) {
	                            iOSInlinePlayerSelf.floatingAdSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);
	                            adSkipText.innerHTML = skipText.replace("%%TIME%%", remainTime);

	                            adSkipText.style.display = "block";
	                            skipButton.style.display = "none";
	                        } else {
	                            if (!iOSInlinePlayerSelf.readyForSkip) {
	                                playerManager.test("log", currentTime);
	                                playerManager.test("VIDLA163_skip", currentTime);
	                            }
	                            iOSInlinePlayerSelf.readyForSkip = true;

	                            if (iOSInlinePlayerSelf.isFullscreen) {
	                                iOSInlinePlayerSelf.floatingAdSkipText.style.display = "none";
	                                iOSInlinePlayerSelf.floatingSkipButton.style.display = "block";
	                            }

	                            adSkipText.style.display = "none";
	                            skipButton.style.display = "block";
	                        }
	                    }
	                });
	            }

	            //switch position by option
	            if (iOSInlinePlayerSelf.options.skippable && iOSInlinePlayerSelf.options.skippable.skipLocation) {
	                switch (iOSInlinePlayerSelf.options.skippable.skipLocation) {
	                    case "top-right":
	                        adIndicatorText.style['right'] = "";
	                        adIndicatorText.style['left'] = "0px";

	                        iOSInlinePlayerSelf.floatingAdIndicator.style['right'] = "";
	                        iOSInlinePlayerSelf.floatingAdIndicator.style['left'] = "0px";
	                        break;
	                    default :
	                        break;
	                }
	            }

	            if (!iOSInlinePlayerSelf.options.disableTopBar && topChrome) {
	                if (iOSInlinePlayerSelf.options.skippable.enabled === true) {
	                    topChrome.appendChild(skipButton);
	                    topChrome.appendChild(adSkipText);
	                }
	                topChrome.appendChild(adIndicatorText);
	            }


	            //set quartile event
	            videojsPlayer.on("timeupdate", function () {
	                if (iOSInlinePlayerSelf.options.vpaid) {
	                    return;
	                }
	                var currentTime = Math.round(videojsPlayer.player().currentTime());
	                var videoDuration = videojsPlayer.player().duration();

	                var quartile1 = videoDuration / 4;
	                var quartile2 = videoDuration / 4 * 2;
	                var quartile3 = videoDuration / 4 * 3;


	                if (!quartile1status && currentTime >= quartile1 && currentTime < quartile2) {
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-first-quartile"});
	                    quartile1status = true;
	                }

	                if (!quartile2status && currentTime >= quartile2 && currentTime < quartile3) {
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-mid"});
	                    quartile2status = true;
	                }

	                if (!quartile3status && currentTime >= quartile3) {
	                    iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video-third-quartile"});
	                    quartile3status = true;
	                }
	            });

	            var handleBigPlayButton = function() {
	                if (playerManager.isDoneInitialPlay) {
	                    playerManager.isPlayingVideo = false;
	                }
	                playerManager.explicitPlay();
	            };

	            //for mobile
	            videojsPlayer.player().bigPlayButton.on("touchend", function (e) {
	                handleBigPlayButton();
	                e.preventDefault();
	            });
	            videojsPlayer.player().bigPlayButton.on("click", function() {
	                handleBigPlayButton();
	            });

	            videojsPlayer.on("error", function () {
	                playerManager.destroyWithoutSkip(true, CONST_MESSAGE_GENERAL_ERROR,null, 900);
	            });


	            //change event handling part here for VID-1820, the issue is caused by that "firstplay" gets invoked earlier than "play" and that interferes with flags which will decide to invoke events
	            //and we were waiting this "firstplay" to fire VAST "start" but it's unnecessary because iOS inline fakes "play" method of video element and modules will invoke "video_start" explicitly.
	            //so it will be okay not to handle firstplay for iOS
	            // videojsPlayer.on("firstplay", function () {
	            //     iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "firstplay"});
	            // });

	            videojsPlayer.on("loadstart", function () {
	                iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "loadstart"});
	            });

	            videojsPlayer.on("pause", function () {
	                //iOSInlinePlayerSelf.dispatchEventToAdunit({"name": "video_pause"});

	                //show big resume
	                if (!playerManager.isFullscreen) {
	                    videojsPlayer.player().bigPlayButton.el().style.display = "block";
	                }


	            });


	        },
	    };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var _logger = __webpack_require__(2);
	var log = function (message) {
	    _logger.log("Video Player: " + message);
	};
	var debug = function (message) {
	    _logger.debug("Video Player: " + message);
	};

	/**
	 * InitializeElements
	 * @param iOSInlinePlayerSelf
	 * @param playerManager
	 * @returns {{acreateIframeAndRequiredObject: acreateIframeAndRequiredObject}}
	 */
	module.exports = function (iOSInlinePlayerSelf, playerManager) {


	    return {

	        createIframeAndRequiredObject: function (cbNextStep) {
	            /**
	             * first step to generate iframe and preapr all requried html objects
	             * @param cbNextStep
	             */

	            log("createIframeAndRequiredObject");

	            var options = iOSInlinePlayerSelf.options;

	            var iframeVideoWrapper = document.createElement("iframe");//generate iframe
	            iframeVideoWrapper.src = "about:blank";
	            options.targetElement.appendChild(iframeVideoWrapper);
	            iframeVideoWrapper.style.width = options.width + "px";
	            iframeVideoWrapper.style.height = options.height + "px";
	            iframeVideoWrapper.id = options.iframeVideoWrapperId;
	            iframeVideoWrapper.setAttribute("allowfullscreen", "true");//allow fullscreen in iframe
	            iframeVideoWrapper.setAttribute("webkitallowfullscreen", "true");
	            iframeVideoWrapper.setAttribute("mozallowfullscreen", "true");

	            //VIDLA-90 fix IAS viewability tracking issue to have proper Iframe.location.origin
	            //var defaultTemplate = "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body style=\"margin:0px;overflow:hidden;\">\n</body>\n</html>\n";
	            var defaultTemplate = "<html></html>";//fix VIDLA-320 to have null doctype like we did before - it means this is the same with not invoking .write("") like we did at the begining of this project

	            iframeVideoWrapper.contentWindow.document.open();
	            iframeVideoWrapper.contentWindow.document.write(defaultTemplate);
	            iframeVideoWrapper.contentWindow.document.close();

	            //temporary allowing setting of fullscreen video button to be enabled for QA and off for production
	            if (typeof options.enableInlineVideoFullscreenButton !== 'undefined') {
	                iOSInlinePlayerSelf.enableFullscreen = options.enableInlineVideoFullscreenButton;
	            }

	            var IframeDocument = iframeVideoWrapper.contentWindow.document;
	            var IframeWindow = iframeVideoWrapper.contentWindow.window;

	            //create top chrome bar
	            debug("Creating and styling top chrome bar");
	            var topChrome = IframeDocument.createElement("div");
	            topChrome.id = "top_chrome";
	            topChrome.style.height = (function () {
	                if (options.playerSkin && typeof options.playerSkin.dividerHeight === "number") {
	                    return iOSInlinePlayerSelf.topChromeHeight - options.playerSkin.dividerHeight + "px";
	                }
	                return iOSInlinePlayerSelf.topChromeHeight - 1 + "px";
	            })();
	            topChrome.style.width = options.width + "px";
	            topChrome.style.marginRight = "auto";
	            topChrome.style.marginLeft = "auto";
	            topChrome.className = "video-js vjs-default-skin";

	            //generate video object
	            debug("Generating and styling video object");
	            var videoEl = IframeDocument.createElement("video");
	            videoEl.id = iOSInlinePlayerSelf.an_video_ad_player_id;
	            videoEl.className = "video-js vjs-default-skin";//set default skin
	            videoEl.style.marginRight = "auto";
	            videoEl.style.marginLeft = "auto";
	            topChrome.style["z-index"] = videoEl.style["z-index"] + 1;

	            if (!options.vpaid) {
	                //generate source object
	                debug("Generating source object");
	                var mp4Source = IframeDocument.createElement("source");
	                mp4Source.type = "video/mp4";
	                mp4Source.src = options.videoUrl;
	                videoEl.appendChild(mp4Source);
	            }

	            //inject required object into iframe
	            debug("Injecting required elements into iframe");
	            if (!options.disableTopBar) {
	                IframeDocument.body.appendChild(topChrome);
	            }
	            IframeDocument.body.appendChild(videoEl);
	            IframeWindow.videojs = iOSInlinePlayerSelf.videojsOrigin;


	            IframeDocument.body.style.margin = "0px";
	            IframeDocument.body.style.overflow = "hidden";

	            if (options.vpaid) {
	                //inject javascript vpaid module to iframe
	                var videojsVpaidScript = IframeDocument.createElement("script");
	                videojsVpaidScript.innerHTML = playerManager.videojs_vpaid;
	                IframeDocument.head.appendChild(videojsVpaidScript);
	            }

	            cbNextStep(iframeVideoWrapper);//pass prepared iframe object


	        }

	    };
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * flashVideoPlayer
	 * @param playerManager
	 * @param cbInjectEventToPlayer
	 */
	var flashVideoPlayer = function (playerManager, cbInjectEventToPlayer) {


	    //getting required object from adVideoPlayerManager
	    var options = playerManager.options;
	    var targetElement = options.targetElement;
	    var vpaidData = playerManager.vpaidData;


	    //handle VAST3
	    var vastSkipOffset = options.data.skipOffset;//skipOffset like 00:00:2.999999
	    var vastProgressEvents = options.data.vastProgressEvent;//comma separated progress event names like progress_00:00:01,progress_00:00:02.500
	    if (vastProgressEvents && typeof(vastProgressEvents) === "object") {
	        vastProgressEvents = Object.keys(vastProgressEvents).toString();
	        playerManager.test("VIDLA163_flash", vastProgressEvents);
	        // VIDLA-513. Remove '%' chars because for '%' in flash vars we need encoding.
	        // Flash player will added '%' by itself if needed.
	        vastProgressEvents = vastProgressEvents.replace(/%/g, '');
	    }
	    playerManager.test("VIDLA163_skipoffset", vastSkipOffset);


	    //getting required object from adVideoPlayerManager (module using internal value)
	    var log = playerManager.log.bind(playerManager);


	    // preapare vpaid data
	    if (options.vpaid) {
	        vpaidData = {};
	        vpaidData.adParameters = options.adParameters ? options.adParameters : null;
	        vpaidData.extensions = options.extensions ? options.extensions : null;
	    }


	    log("WE ARE USING FLASH PLAYER");

	    //generate iframe
	    /*var iframeVideoWrapper = document.createElement("iframe");
	     iframeVideoWrapper.style.width = options.width + "px";
	     iframeVideoWrapper.style.height = options.height + "px";
	     iframeVideoWrapper.id = "iframeVideoWrapper";

	     targetElement.appendChild(iframeVideoWrapper);
	     iframeVideoWrapper.contentWindow.document.body.style.margin = "0px";*/



	    var uid = new Date().getTime() + Math.floor(Math.random() * 10000);

	    var flashObj = document.createElement("object");
	    flashObj.type = 'application/x-shockwave-flash';
	    flashObj.data = options.flash.swf;
	    flashObj.width = (playerManager.isChrome ? "0" : options.width) + "px";
	    flashObj.height = (playerManager.isChrome ? "0" : options.height) + "px";
	    flashObj.id = 'apn_flash_player_' + uid;

	    //flashObj.style.display = 'block';


	    //flashObj.style.position = 'absolute';
	    flashObj.style.top = '0';
	    flashObj.style.left = '0';
	    if (options.hasOwnProperty('overlayPlayer')) {
	        flashObj.style.width = options.width + "px";
	        flashObj.style.height = options.height + "px";

	    }
	    else {
	        flashObj.style.width = (playerManager.isChrome ? "0" : options.width) + "px";
	        flashObj.style.height = (playerManager.isChrome ? "0" : options.height) + "px";
	    }
	    /*var par1 = document.createElement('param');
	     par1.name = 'movie';
	     par1.value = options.flash.swf;
	     flashObj.appendChild(par1);*/
	    var par2 = document.createElement('param');
	    par2.name = 'flashvars';

	    // set options to flashvars
	    par2.value = 'video=' + encodeURIComponent(options.videoUrl) +
	        '&autoplay=' + options.autoplay +
	        '&initialPlayback=' + options.initialPlayback +
	        '&canScale=' + options.canScale +
	        '&maintainAspectRatio=' + options.maintainAspectRatio +
	        '&muted=' + options.muted +
	        '&showMute=' + options.showMute +
	        '&showVolume=' + options.showVolume +
	        '&showProgressBar=' + options.showProgressBar +
	        '&allowFullscreen=' + options.allowFullscreen +
	        '&playOnMouseover=false' +
	        '&audioOnMouseover=false' +
	        '&initialAudio=' + options.initialAudio +
	        '&adText=' + options.adText +
	        '&vpaid=' + options.vpaid + '&external=' + options.communicator;

	    par2.value += ('&containerWidth=' + options.width + '&containerHeight=' + options.height);

	    if (options.hasOwnProperty('overlayPlayer')) {
		par2.value += '&overlayPlayer=true';
	    }

	    if (options.hasOwnProperty('fullscreenMode')) {
		par2.value += ('&fullscreenMode=' + options.fullscreenMode);
	    }

	    if (options.vpaid && options.vpaidDuration) {
	        par2.value += ('&vpaidDuration=' + options.vpaidDuration);
	    }
	    if (options.terminateUnresponsiveVPAIDCreative) {
	        par2.value += ('&terminateUnresponsiveVPAIDCreative=' + options.terminateUnresponsiveVPAIDCreative);
	    }
	    if (options.vpaid && options.vpaidTimeout) {
	        par2.value += ('&vpaidTimeout=' + options.vpaidTimeout);
	    }
	    if (options.cbNotification) {
		par2.value += '&needFeedback=true';
	    }
	    if (options.disableCollapse) {
		par2.value += ("&disableCollapse=" + options.disableCollapse);
	    }
	    if (options.topDividerColor) {
		par2.value += ("&dividerColor=" + options.topDividerColor);
	    }
	    if (options.topDividerWidth) {
		par2.value += ("&dividerWidth=" + options.topDividerWidth);
	    }
	    if (options.disableTopBar) {
		par2.value += ("&supressTopBar=" + options.disableTopBar);
	    }
	    if (options.hasOwnProperty('delayExpandUntilVPAIDImpression')) {
		par2.value += ("&delayExpandUntilVPAIDImpression=" + options.delayExpandUntilVPAIDImpression);
	    }
	    if (options.skippable && options.skippable.enabled === true) {
	        par2.value += ('&videoThreshhold=' + options.skippable.videoThreshold +
	        '&videoOffset=' + options.skippable.videoOffset +
	        '&skipLocation=' + options.skippable.skipLocation +
	        '&skipText=' + encodeURIComponent(options.skippable.skipText) +
	        '&skipButtonText=' + encodeURIComponent(options.skippable.skipButtonText) +
	        '&allowOverride=' + encodeURIComponent(options.skippable.allowOverride));
	    }
	    if (vastProgressEvents) {
	        par2.value += '&vastProgressEvents=' + vastProgressEvents;
	    }
	    if (vastSkipOffset) {
	        par2.value += '&vastSkipOffset=' + vastSkipOffset;
	    }
	    flashObj.appendChild(par2);
	    var par3 = document.createElement('param');
	    par3.name = 'allowScriptAccess';
	    par3.value = 'always';
	    flashObj.appendChild(par3);
	    var par4 = document.createElement('param');
	    par4.name = 'allowNetworking';
	    par4.value = 'all';
	    flashObj.appendChild(par4);
	    var par5 = document.createElement('param');
	    par5.name = 'allowNetworking';
	    par5.value = 'all';
	    flashObj.appendChild(par5);
	    var par6 = document.createElement('param');
	    par6.name = 'wmode';
	    par6.value = 'opaque';
	    flashObj.appendChild(par6);
	    if (options.allowFullscreen) {
	        var par7 = document.createElement('param');
	        par7.name = 'allowFullScreen';
	        par7.value = 'true';
	        flashObj.appendChild(par7);
	    }

	    if (options.overlayPlayer) {
		// protection against freezing by flash blockers
		var tm = options.hasOwnProperty('vpaidTimeout') && options.vpaidTimeout ? options.vpaidTimeout : 5000;
		playerManager.flashBlockerTimeout = setTimeout ( function() {
			clearTimeout(playerManager.flashBlockerTimeout);
			playerManager.flashBlockerTimeout = null;

			playerManager.isPlayingVideo = false;
	            var code = 405;		//VAST Error code - problem displaying MediaFile
	            playerManager.callbackForAdUnit.cbWhenDestroy({type: 1, code: code, message: 'Flash player blocked by browser'}, true);
		}, tm);
	    }

	    targetElement.appendChild(flashObj);

	    playerManager.adVideoPlayer = flashObj;
	    window[options.communicator] = playerManager;//re assign lastest object
	    cbInjectEventToPlayer(flashObj, null);


	};

	module.exports = flashVideoPlayer;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var Utils = __webpack_require__(9);

	var prefixOfLog = "PlayerManager_VideoSizeHandler";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	var warn = function (message) {
	    APN_Logger.warn(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };



	/**
	 * resizeVideo
	 * @param aspectRatio
	 * @param shouldConsiderHeightOfDevice
	 * @param playerManager
	 */
	var resizeVideo = function(aspectRatio, shouldConsiderHeightOfDevice, playerManager, callback) {
	    debug("resizeVideo");
	    //handle playerManager's refernece
	    var options = playerManager.options;
	    var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);
	    var decidePlayer = playerManager.decidePlayer.bind(playerManager);
	    var iframeVideoWrapper = playerManager.iframeVideoWrapper;
	    var adVideoPlayer = playerManager.adVideoPlayer;

	    //set internal variables
	    var calculatedWidth = options.width;
	    var mediaHeight;
	    var topOffset = 0;
	    var bottomOffset = 0;
	    var mediaAspectRatio;
	    var aspectRatioOption;
	    var wrapperHeight; //it was playerHeight but iframeHeight will be more clear
	    var hasStaticHeight = false;
	    var fixedSizePlayer = options.fixedSizePlayer;
	    var vastWidth = options.video.width; //VAST width came from rendition manager
	    var vastHeight = options.video.height; //VAST width came from rendition manager

	    var useStaticControlBar = function() {
	        return (Utils.isAndroid() || isIosInlineRequired() || options.controlBarPosition === "below");
	    };


	    //first step - resolve width
	    if (options.autoInitialSize) {

	        //VID-1788,1789
	        if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if side stream is activated, resize will work with div of empty space injected by SideStream module
	            calculatedWidth = options.emptyDiv.offsetWidth;
	        } else {
	            calculatedWidth = options.targetElement.offsetWidth;
	            if( calculatedWidth === 0 ){
	                calculatedWidth = options.width;
	                warn("AutoInitialSize could not find parent element width, using tag width");
	            }
	        }

	    }


	    aspectRatioOption = options.aspectRatio || options.playerAspectRatio; // removed support for playerHeight and player_height here [deprecated]

	    debug("options.height : " + options.height);
	    if (Utils.isEmpty(aspectRatioOption)) {
	        if (Utils.isEmpty(options.height)) {
	            aspectRatioOption = "16:9";
	        } else {
	            aspectRatioOption = "none";
	        }
	    }

	    debug("aspectRatioOption : " + aspectRatioOption);

	    //set media aspect ratio by VAST value
	    //TODO: do we ever look at actual selected video metadata?
	    if (typeof vastWidth === "undefined" || typeof vastHeight === "undefined" || vastWidth === 0 || vastHeight === 0) {
	        mediaAspectRatio = (16 / 9); //aspect ratio for 16:9
	    } else {
	        mediaAspectRatio = vastWidth / vastHeight;
	    }

	    if (!options.disableTopBar) {
	        topOffset = 24; //default height for topBar
	    }

	    if (useStaticControlBar()) {
	        bottomOffset += options.playerSkin.controlBarHeight;
	        if (playerManager.adVideoPlayer.controlBar.progressControl) {
	            bottomOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
	        }
	    }

	    debug("initial VAST width : " + vastWidth);
	    debug("initial VAST height : " + vastHeight);
	    debug("initial topOffset : " + topOffset);
	    debug("initial bottomOffset : " + bottomOffset);
	    debug("initial mediaAspectRatio : " + mediaAspectRatio);

	    //if fixedSizePlayer is true, only use the width and height of the options for the player
	    //player will never be bigger than width and height in this case
	    if (fixedSizePlayer) {
	        wrapperHeight = options.height;
	        calculatedWidth = options.width;
	        mediaHeight = options.height - topOffset - bottomOffset;
	    } else {
	        //if not fixed size player (we calculate size)

	        //split aspect ratio option
	        var ratioArray = aspectRatioOption.split(":");
	        //if we have the right format aspect ratio, for example x:y
	        //calculatedWidth is either options width or autoInitialSize width
	        if (ratioArray.length === 2) {
	            try {
	                //For aspect ratio x:y
	                mediaAspectRatio = (ratioArray[0] / ratioArray[1]);
	            } catch (e) {
	                debug(e);
	            } //if we can't set media aspect ratio, use default value
	        }
	        //set media height
	        mediaHeight = Math.round(calculatedWidth / mediaAspectRatio);
	        wrapperHeight = mediaHeight + topOffset + bottomOffset;
	    }

	    options.height = wrapperHeight;
	    options.mediaHeight = mediaHeight;

	    if (decidePlayer(options.requiredPlayer) === "html5") {

	        if (iframeVideoWrapper && typeof iframeVideoWrapper === "object" && iframeVideoWrapper.style) {

	            //Browser user agent might add an iframe border
	            //This will overwrite it
	            iframeVideoWrapper.style.border = "none";
	            iframeVideoWrapper.style.width = calculatedWidth + "px";
	            iframeVideoWrapper.style.height = wrapperHeight + "px";

	            if(iframeVideoWrapper.contentWindow){
	                var topChrome = iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
	                if (topChrome) {
	                    topChrome.style.width = calculatedWidth +"px";

	                    //VID 1837 - restore original margin setting due to SideStream changed the margin, but it's important to restore it to original because of options.alignment feature on outstream, that alignement is only meaningful only on Outstream
	                    topChrome.style.marginLeft = "auto";
	                    topChrome.style.marginRight = "auto";
	                }
	            }

	            playerManager.adVideoPlayer.el_.style.marginLeft = "auto";
	            playerManager.adVideoPlayer.el_.style.marginRight = "auto";


	            debug("final wrapper width for html5 : " + calculatedWidth);
	            debug("final wrapper height for html5 : " + wrapperHeight);

	        }

	        //resize video
	        adVideoPlayer.width(calculatedWidth);

	        //VID-1790
	        if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if SideStream is activated, targetElement should be changed to work properly at the corder of video
	            options.targetElement.style.width = calculatedWidth + "px";//VID-1808
	        } else {
	            options.targetElement.style.width = "";//VID-1808
	        }

	        debug("resize video.js width to : " + calculatedWidth);


	        debug("shouldConsiderHeightOfDevice : " + shouldConsiderHeightOfDevice);
	        debug("hasStaticHeight : " + hasStaticHeight);
	        debug("mediaHeight + bottomOffset + topOffset : " + (mediaHeight + bottomOffset + topOffset));
	        debug("window.innerHeight : " + window.innerHeight);

	        //VID-1020 if it's mobile(shouldConsiderHeightOfDevice = true)
	        if (shouldConsiderHeightOfDevice && (mediaHeight + bottomOffset + topOffset) > window.innerHeight) {
	            //resize height with considering viewport height

	            var mobileVideoJSHeight = window.innerHeight - topOffset;
	            var mobileOptionsHeight = window.innerHeight;
	            var mobileMedieHeight = window.innerHeight - bottomOffset - topOffset;

	            adVideoPlayer.height(mobileVideoJSHeight);
	            options.height = mobileOptionsHeight;
	            options.mediaHeight = mobileMedieHeight;

	            debug("mobile set video.js height to : " + mobileVideoJSHeight);
	            debug("mobile options.height to : " + mobileOptionsHeight);
	            debug("mobile options.mediaHeight to : " + mobileMedieHeight);


	        } else {
	            //resize video as usual
	            var desktopVideoJSHeight = mediaHeight;
	            if (!useStaticControlBar() || isIosInlineRequired()) {//iOS inline has to have bottomOffset
	                desktopVideoJSHeight += bottomOffset;
	            }

	            adVideoPlayer.height(desktopVideoJSHeight);
	            debug("desktop set video.js height to : " + desktopVideoJSHeight);
	        }


	    } else {
	        //flash
	        adVideoPlayer.width = calculatedWidth + "px";
	        adVideoPlayer.height = wrapperHeight + "px";
	        adVideoPlayer.style.width = calculatedWidth + "px";
	        adVideoPlayer.style.height = wrapperHeight + "px";

	        debug("flash width : " + calculatedWidth);
	        debug("flash height : " + wrapperHeight);


	    }

	    options.targetElement.style.visibility = "visible";
	    if (typeof(callback) === "function") {
	        callback();
	    }

	};

	/**
	 * resizeVideoForSideStream
	 * @param playerManager
	 * @param width
	 * @param height
	 */
	var resizeVideoForSideStream = function(playerManager, width, height,cb) {


	    var shouldConsiderHeightOfDevice = false;

	    debug("resizeVideo-sidestream");
	    //handle playerManager's refernece
	    var options = playerManager.options;
	    var isIosInlineRequired = playerManager.isIosInlineRequired.bind(playerManager);
	    var decidePlayer = playerManager.decidePlayer.bind(playerManager);
	    var iframeVideoWrapper = playerManager.iframeVideoWrapper;
	    var adVideoPlayer = playerManager.adVideoPlayer;


	    //set internal variables
	    var calculatedWidth = width;
	    var mediaHeight;
	    var topOffset = 0;
	    var bottomOffset = 0;
	    var mediaAspectRatio;
	    var aspectRatioOption;
	    var wrapperHeight; //it was playerHeight but iframeHeight will be more clear
	    var fixedSizePlayer = true;//this is for sideStream and sideStream only has fixedSizePlayer
	    var vastWidth = options.video.width; //VAST width came from rendition manager
	    var vastHeight = options.video.height; //VAST width came from rendition manager

	    var useStaticControlBar = function() {
	        return (Utils.isAndroid() || isIosInlineRequired() || options.controlBarPosition === "below");
	    };



	    aspectRatioOption = options.aspectRatio || options.playerAspectRatio; // removed support for playerHeight and player_height here [deprecated]

	    debug("options.height : " + height);
	    if (Utils.isEmpty(aspectRatioOption)) {
	        if (Utils.isEmpty(height)) {
	            aspectRatioOption = "16:9";
	        } else {
	            aspectRatioOption = "none";
	        }
	    }

	    debug("aspectRatioOption : " + aspectRatioOption);

	    //set media aspect ratio by VAST value
	    //TODO: do we ever look at actual selected video metadata?
	    if (typeof vastWidth === "undefined" || typeof vastHeight === "undefined" || vastWidth === 0 || vastHeight === 0) {
	        mediaAspectRatio = (16 / 9); //aspect ratio for 16:9
	    } else {
	        mediaAspectRatio = vastWidth / vastHeight;
	    }

	    if (!options.disableTopBar) {
	        topOffset = 24; //default height for topBar
	    }

	    if (useStaticControlBar()) {
	        bottomOffset += options.playerSkin.controlBarHeight;
	        if (playerManager.adVideoPlayer.controlBar.progressControl) {
	            bottomOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
	        }
	    }

	    debug("initial VAST width : " + vastWidth);
	    debug("initial VAST height : " + vastHeight);
	    debug("initial topOffset : " + topOffset);
	    debug("initial bottomOffset : " + bottomOffset);
	    debug("initial mediaAspectRatio : " + mediaAspectRatio);

	    //if fixedSizePlayer is true, only use the width and height of the options for the player
	    //player will never be bigger than width and height in this case
	    if (fixedSizePlayer) {
	        wrapperHeight = height;
	        calculatedWidth = width;
	        mediaHeight = height - topOffset - bottomOffset;
	    } else {
	        //if not fixed size player (we calculate size)

	        //split aspect ratio option
	        var ratioArray = aspectRatioOption.split(":");
	        //if we have the right format aspect ratio, for example x:y
	        //calculatedWidth is either options width or autoInitialSize width
	        if (ratioArray.length === 2) {
	            try {
	                //For aspect ratio x:y
	                mediaAspectRatio = (ratioArray[0] / ratioArray[1]);
	            } catch (e) {
	                debug(e);
	            } //if we can't set media aspect ratio, use default value
	        }
	        //set media height
	        mediaHeight = Math.round(calculatedWidth / mediaAspectRatio);
	        wrapperHeight = mediaHeight + topOffset + bottomOffset;
	    }

	    //for having a size defined by side stream options
	    if (height && width) {
	        options.mediaHeight = mediaHeight;
	    }

	    if (decidePlayer(options.requiredPlayer) === "html5") {

	        if (iframeVideoWrapper && typeof iframeVideoWrapper === "object" && iframeVideoWrapper.style) {

	            //Browser user agent might add an iframe border
	            //This will overwrite it
	            iframeVideoWrapper.style.border = "none";
	            iframeVideoWrapper.style.width = calculatedWidth + "px";
	            iframeVideoWrapper.style.height = wrapperHeight + "px";

	            if(iframeVideoWrapper.contentWindow){
	                var topChrome = iframeVideoWrapper.contentWindow.document && iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
	                if (topChrome) {
	                    topChrome.style.width = calculatedWidth;
	                    //VID 1837 - remove margin attribute here that it's unnecessary for sidestream and the auto value can make problem to position. but it will be restored when moveback to Oustream by resizeVideo()
	                    topChrome.style.marginLeft = "";
	                    topChrome.style.marginRight = "";
	                }
	            }

	            playerManager.adVideoPlayer.el_.style.marginLeft = "";
	            playerManager.adVideoPlayer.el_.style.marginRight = "";


	            debug("final wrapper width for html5 : " + calculatedWidth);
	            debug("final wrapper height for html5 : " + wrapperHeight);

	        }

	        //resize video
	        adVideoPlayer.width(calculatedWidth);

	        //VID-1790
	        if (options.sideStream && options.sideStream.enabled === true && options.emptyDiv) {//if SideStream is activated, targetElement should be changed to work properly at the corder of video
	            options.targetElement.style.width = calculatedWidth + "px";//VID-1808
	        } else {
	            options.targetElement.style.width = "";//VID-1808
	        }

	        debug("resize video.js width to : " + calculatedWidth);


	        debug("shouldConsiderHeightOfDevice : " + shouldConsiderHeightOfDevice);
	        debug("mediaHeight + bottomOffset + topOffset : " + (mediaHeight + bottomOffset + topOffset));
	        debug("window.innerHeight : " + window.innerHeight);

	        //VID-1020 if it's mobile(shouldConsiderHeightOfDevice = true)
	        if (shouldConsiderHeightOfDevice && (mediaHeight + bottomOffset + topOffset) > window.innerHeight) {
	            //resize height with considering viewport height

	            var mobileVideoJSHeight = window.innerHeight - topOffset;
	            var mobileOptionsHeight = window.innerHeight;
	            var mobileMedieHeight = window.innerHeight - bottomOffset - topOffset;

	            adVideoPlayer.height(mobileVideoJSHeight);
	            // options.height = mobileOptionsHeight;
	            // options.mediaHeight = mobileMedieHeight;

	            debug("mobile set video.js height to : " + mobileVideoJSHeight);
	            debug("mobile options.height to : " + mobileOptionsHeight);
	            debug("mobile options.mediaHeight to : " + mobileMedieHeight);


	        } else {
	            //resize video as usual
	            var desktopVideoJSHeight = mediaHeight;
	            if (!useStaticControlBar() || isIosInlineRequired()) {//iOS inline has to have bottomOffset
	                desktopVideoJSHeight += bottomOffset;
	            }
	            adVideoPlayer.height(desktopVideoJSHeight);
	            debug("desktop set video.js height to : " + desktopVideoJSHeight);
	        }


	    } else {
	        //flash
	        adVideoPlayer.width = calculatedWidth + "px";
	        adVideoPlayer.height = wrapperHeight + "px";
	        adVideoPlayer.style.width = calculatedWidth + "px";
	        adVideoPlayer.style.height = wrapperHeight + "px";



	        debug("flash width : " + calculatedWidth);
	        debug("flash height : " + wrapperHeight);


	    }

	    // adVideoPlayer.style.marginLeft = "";
	    // adVideoPlayer.style.marginRight = "";

	    //options.targetElement.style.visibility = "visible";

	    if (typeof(cb) === "function") {
	        cb();
	    }

	};

	/**
	 * setSizeForInitialRender
	 * @param _options
	 */
	var setSizeForInitialRender = function(_options) {

	    debug("setSizeForInitialRender");
	    var calculatedWidth = _options.width;

	    //if auto initial size is set to true, and offsetWidth of the target element is non-zero,
	    //set the width of the contianer (if not, leave width as width in options)
	    if (_options.autoInitialSize) {
	            calculatedWidth = _options.targetElement.offsetWidth;

	            if( calculatedWidth <= 0){
	                calculatedWidth = _options.width;
	                warn("Width of target element was not set or zero, using tag width for player instead");
	            }
	    }

	     debug("setSizeForInitialRender using width: " + calculatedWidth);
	    _options.width = calculatedWidth;
	};

	/**
	 * getFinalSize including topbar and bottombar
	 * @param playerManager
	 * @returns {{width: number, height: number}}
	 */
	var getFinalSize = function(playerManager) {
	    var result = { width: 0, height: 0 };

	    //TODO this should return width x height including top and bottom bar
	    if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash") {
	        result = { width: playerManager.adVideoPlayer.offsetWidth, height: playerManager.adVideoPlayer.offsetHeight };
	    } else {
	        //html5
	        var _tmp = document.getElementById(playerManager.options.iframeVideoWrapperId);
	        result = { width: _tmp.offsetWidth, height: _tmp.offsetHeight };
	    }
	    return result;
	};

	/**
	 * resizePlayer
	 * @param width
	 * @param height
	 * @param playerManager
	 */
	var resizePlayer = function(width, height, playerManager) {
	    debug("resizePlayer");
	    //TODO who use this function? at least html5 player doesn't use this method

	    if (playerManager.overlayPlayer && playerManager.adVideoPlayer) {
	        if (playerManager.decidePlayer(playerManager.options.requiredPlayer) === "flash") {
	            playerManager.adVideoPlayer.width = width + "px";
	            playerManager.adVideoPlayer.height = height + "px";
	            playerManager.adVideoPlayer.style.width = width + "px";
	            playerManager.adVideoPlayer.style.height = height + "px";
	        } else {
	            if (playerManager.iframeVideoWrapper && typeof playerManager.iframeVideoWrapper === "object") {
	                //Browser user agent might add an iframe border
	                //This will overwrite it
	                playerManager.iframeVideoWrapper.style.border = "none";
	                playerManager.iframeVideoWrapper.style.width = width + "px";
	                playerManager.iframeVideoWrapper.style.height = height + "px";

	                var topChrome = playerManager && playerManager.iframeVideoWrapper && playerManager.iframeVideoWrapper.contentWindow && playerManager.iframeVideoWrapper.contentWindow.document && playerManager.iframeVideoWrapper.contentWindow.document.getElementById("top_chrome");//more safe way to access element which might not exists for VID-1923
	                if (topChrome) {
	                    topChrome.style.width = width + "px";
	                }
	            }

	            //resize video
	            playerManager.adVideoPlayer.width(width);
	            var topOffset = 0;
	            if (!playerManager.options.disableTopBar) {
	                topOffset = 24;
	            }
	            if (Utils.isAndroid() || playerManager.isIosInlineRequired() || playerManager.options.controlBarPosition === "below") {
	                topOffset += playerManager.options.playerSkin.controlBarHeight;
	                if (playerManager.adVideoPlayer.controlBar.progressControl) {
	                    topOffset += playerManager.adVideoPlayer.controlBar.progressControl.el_.offsetHeight;
	                }
	            }
	            playerManager.adVideoPlayer.height(height - topOffset);
	        }
	    }
	};


	module.exports = {
	    resizeVideo: resizeVideo,
	    setSizeForInitialRender: setSizeForInitialRender,
	    getFinalSize: getFinalSize,
	    resizePlayer: resizePlayer,
	    resizeVideoForSideStream: resizeVideoForSideStream
	};


/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = "/* jshint ignore:start */\n(function(window, document, vjs, undefined) {\n    (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f }\n                var l = n[o] = { exports: {} };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e) }, l, l.exports, e, t, n, r) }\n            return n[o].exports }\n        var i = typeof require == \"function\" && require;\n        for (var o = 0; o < r.length; o++) s(r[o]);\n        return s })({\n        1: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            //simple representation of the API\n\n            var IVPAIDAdUnit = (function() {\n                function IVPAIDAdUnit() {\n                    _classCallCheck(this, IVPAIDAdUnit);\n                }\n\n                _createClass(IVPAIDAdUnit, [{\n                    key: 'handshakeVersion',\n\n                    //all methods below\n                    //are async methods\n                    value: function handshakeVersion() {\n                        var playerVPAIDVersion = arguments[0] === undefined ? '2.0' : arguments[0];\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n                    }\n                }, {\n                    key: 'initAd',\n\n                    //creativeData is an object to be consistent with VPAIDHTML\n                    value: function initAd(width, height, viewMode, desiredBitrate) {\n                        var creativeData = arguments[4] === undefined ? { AdParameters: '' } : arguments[4];\n                        var environmentVars = arguments[5] === undefined ? { flashVars: '' } : arguments[5];\n                        var callback = arguments[6] === undefined ? undefined : arguments[6];\n                    }\n                }, {\n                    key: 'resizeAd',\n                    value: function resizeAd(width, height, viewMode) {\n                        var callback = arguments[3] === undefined ? undefined : arguments[3];\n                    }\n                }, {\n                    key: 'startAd',\n                    value: function startAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'stopAd',\n                    value: function stopAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'pauseAd',\n                    value: function pauseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'resumeAd',\n                    value: function resumeAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'expandAd',\n                    value: function expandAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'collapseAd',\n                    value: function collapseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'skipAd',\n                    value: function skipAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n                    }\n                }, {\n                    key: 'getAdLinear',\n\n                    //properties that will be treat as async methods\n                    value: function getAdLinear(callback) {}\n                }, {\n                    key: 'getAdWidth',\n                    value: function getAdWidth(callback) {}\n                }, {\n                    key: 'getAdHeight',\n                    value: function getAdHeight(callback) {}\n                }, {\n                    key: 'getAdExpanded',\n                    value: function getAdExpanded(callback) {}\n                }, {\n                    key: 'getAdSkippableState',\n                    value: function getAdSkippableState(callback) {}\n                }, {\n                    key: 'getAdRemainingTime',\n                    value: function getAdRemainingTime(callback) {}\n                }, {\n                    key: 'getAdDuration',\n                    value: function getAdDuration(callback) {}\n                }, {\n                    key: 'setAdVolume',\n                    value: function setAdVolume(soundVolume) {\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n                    }\n                }, {\n                    key: 'getAdVolume',\n                    value: function getAdVolume(callback) {}\n                }, {\n                    key: 'getAdCompanions',\n                    value: function getAdCompanions(callback) {}\n                }, {\n                    key: 'getAdIcons',\n                    value: function getAdIcons(callback) {}\n                }]);\n\n                return IVPAIDAdUnit;\n            })();\n\n            exports.IVPAIDAdUnit = IVPAIDAdUnit;\n\n            Object.defineProperty(IVPAIDAdUnit, 'EVENTS', {\n                writable: false,\n                configurable: false,\n                value: ['AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange', // VPAID 2.0 new event\n                    'AdSizeChange', // VPAID 2.0 new event\n                    'AdLinearChange', 'AdDurationChange', // VPAID 2.0 new event\n                    'AdExpandedChange', 'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility\n                    'AdVolumeChange', 'AdImpression', 'AdVideoStart', 'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile', 'AdVideoComplete', 'AdClickThru', 'AdInteraction', // VPAID 2.0 new event\n                    'AdUserAcceptInvitation', 'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError'\n                ]\n            });\n\n        }, {}],\n        2: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            var _get = function get(_x15, _x16, _x17) {\n                var _again = true;\n                _function: while (_again) {\n                    var object = _x15,\n                        property = _x16,\n                        receiver = _x17;\n                    desc = parent = getter = undefined;\n                    _again = false;\n                    if (object === null) object = Function.prototype;\n                    var desc = Object.getOwnPropertyDescriptor(object, property);\n                    if (desc === undefined) {\n                        var parent = Object.getPrototypeOf(object);\n                        if (parent === null) {\n                            return undefined; } else { _x15 = parent;\n                            _x16 = property;\n                            _x17 = receiver;\n                            _again = true;\n                            continue _function; } } else if ('value' in desc) {\n                        return desc.value; } else {\n                        var getter = desc.get;\n                        if (getter === undefined) {\n                            return undefined; }\n                        return getter.call(receiver); } } };\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== 'function' && superClass !== null) {\n                    throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); }\n                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n                if (superClass) subClass.__proto__ = superClass; }\n\n            var IVPAIDAdUnit = require('./IVPAIDAdUnit').IVPAIDAdUnit;\n            var ALL_VPAID_METHODS = Object.getOwnPropertyNames(IVPAIDAdUnit.prototype).filter(function(property) {\n                return ['constructor'].indexOf(property) === -1;\n            });\n\n            var VPAIDAdUnit = (function(_IVPAIDAdUnit) {\n                function VPAIDAdUnit(flash) {\n                    _classCallCheck(this, VPAIDAdUnit);\n\n                    _get(Object.getPrototypeOf(VPAIDAdUnit.prototype), 'constructor', this).call(this);\n                    this._destroyed = false;\n                    this._flash = flash;\n                }\n\n                _inherits(VPAIDAdUnit, _IVPAIDAdUnit);\n\n                _createClass(VPAIDAdUnit, [{\n                    key: '_destroy',\n                    value: function _destroy() {\n                        var _this = this;\n\n                        this._destroyed = true;\n                        ALL_VPAID_METHODS.forEach(function(methodName) {\n                            _this._flash.removeCallbackByMethodName(methodName);\n                        });\n                        IVPAIDAdUnit.EVENTS.forEach(function(event) {\n                            _this._flash.offEvent(event);\n                        });\n\n                        this._flash = null;\n                    }\n                }, {\n                    key: 'isDestroyed',\n                    value: function isDestroyed() {\n                        return this._destroyed;\n                    }\n                }, {\n                    key: 'on',\n                    value: function on(eventName, callback) {\n                        this._flash.on(eventName, callback);\n                    }\n                }, {\n                    key: 'off',\n                    value: function off(eventName, callback) {\n                        this._flash.off(eventName, callback);\n                    }\n                }, {\n                    key: 'handshakeVersion',\n\n                    //VPAID interface\n                    value: function handshakeVersion() {\n                        var playerVPAIDVersion = arguments[0] === undefined ? '2.0' : arguments[0];\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n\n                        this._flash.callFlashMethod('handshakeVersion', [playerVPAIDVersion], callback);\n                    }\n                }, {\n                    key: 'initAd',\n                    value: function initAd(width, height, viewMode, desiredBitrate) {\n                        var creativeData = arguments[4] === undefined ? { AdParameters: '' } : arguments[4];\n                        var environmentVars = arguments[5] === undefined ? { flashVars: '' } : arguments[5];\n                        var callback = arguments[6] === undefined ? undefined : arguments[6];\n\n                        //resize element that has the flash object\n                        this._flash.setSize(width, height);\n                        creativeData = creativeData || { AdParameters: '' };\n                        environmentVars = environmentVars || { flashVars: '' };\n\n                        this._flash.callFlashMethod('initAd', [this._flash.getWidth(), this._flash.getHeight(), viewMode, desiredBitrate, creativeData.AdParameters || '', environmentVars.flashVars || ''], callback);\n                    }\n                }, {\n                    key: 'resizeAd',\n                    value: function resizeAd(width, height, viewMode) {\n                        var callback = arguments[3] === undefined ? undefined : arguments[3];\n\n                        //resize element that has the flash object\n                        this._flash.setSize(width, height);\n\n                        //resize ad inside the flash\n                        this._flash.callFlashMethod('resizeAd', [this._flash.getWidth(), this._flash.getHeight(), viewMode], callback);\n                    }\n                }, {\n                    key: 'startAd',\n                    value: function startAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('startAd', [], callback);\n                    }\n                }, {\n                    key: 'stopAd',\n                    value: function stopAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('stopAd', [], callback);\n                    }\n                }, {\n                    key: 'pauseAd',\n                    value: function pauseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('pauseAd', [], callback);\n                    }\n                }, {\n                    key: 'resumeAd',\n                    value: function resumeAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('resumeAd', [], callback);\n                    }\n                }, {\n                    key: 'expandAd',\n                    value: function expandAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('expandAd', [], callback);\n                    }\n                }, {\n                    key: 'collapseAd',\n                    value: function collapseAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('collapseAd', [], callback);\n                    }\n                }, {\n                    key: 'skipAd',\n                    value: function skipAd() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        this._flash.callFlashMethod('skipAd', [], callback);\n                    }\n                }, {\n                    key: 'getAdLinear',\n\n                    //properties that will be treat as async methods\n                    value: function getAdLinear(callback) {\n                        this._flash.callFlashMethod('getAdLinear', [], callback);\n                    }\n                }, {\n                    key: 'getAdWidth',\n                    value: function getAdWidth(callback) {\n                        this._flash.callFlashMethod('getAdWidth', [], callback);\n                    }\n                }, {\n                    key: 'getAdHeight',\n                    value: function getAdHeight(callback) {\n                        this._flash.callFlashMethod('getAdHeight', [], callback);\n                    }\n                }, {\n                    key: 'getAdExpanded',\n                    value: function getAdExpanded(callback) {\n                        this._flash.callFlashMethod('getAdExpanded', [], callback);\n                    }\n                }, {\n                    key: 'getAdSkippableState',\n                    value: function getAdSkippableState(callback) {\n                        this._flash.callFlashMethod('getAdSkippableState', [], callback);\n                    }\n                }, {\n                    key: 'getAdRemainingTime',\n                    value: function getAdRemainingTime(callback) {\n                        this._flash.callFlashMethod('getAdRemainingTime', [], callback);\n                    }\n                }, {\n                    key: 'getAdDuration',\n                    value: function getAdDuration(callback) {\n                        this._flash.callFlashMethod('getAdDuration', [], callback);\n                    }\n                }, {\n                    key: 'setAdVolume',\n                    value: function setAdVolume(volume) {\n                        var callback = arguments[1] === undefined ? undefined : arguments[1];\n\n                        this._flash.callFlashMethod('setAdVolume', [volume], callback);\n                    }\n                }, {\n                    key: 'getAdVolume',\n                    value: function getAdVolume(callback) {\n                        this._flash.callFlashMethod('getAdVolume', [], callback);\n                    }\n                }, {\n                    key: 'getAdCompanions',\n                    value: function getAdCompanions(callback) {\n                        this._flash.callFlashMethod('getAdCompanions', [], callback);\n                    }\n                }, {\n                    key: 'getAdIcons',\n                    value: function getAdIcons(callback) {\n                        this._flash.callFlashMethod('getAdIcons', [], callback);\n                    }\n                }]);\n\n                return VPAIDAdUnit;\n            })(IVPAIDAdUnit);\n\n            exports.VPAIDAdUnit = VPAIDAdUnit;\n\n        }, { \"./IVPAIDAdUnit\": 1 }],\n        3: [function(require, module, exports) {\n            'use strict';\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            var JSFlashBridge = require('./jsFlashBridge').JSFlashBridge;\n            var VPAIDAdUnit = require('./VPAIDAdUnit').VPAIDAdUnit;\n\n            var noop = require('./utils').noop;\n            var callbackTimeout = require('./utils').callbackTimeout;\n            var isPositiveInt = require('./utils').isPositiveInt;\n            var createElementWithID = require('./utils').createElementWithID;\n            var uniqueVPAID = require('./utils').unique('vpaid');\n\n            var ERROR = 'error';\n            var FLASH_VERSION = '10.1.0';\n\n            var VPAIDFLASHClient = (function() {\n                function VPAIDFLASHClient(vpaidParentEl, callback) {\n                    var swfConfig = arguments[2] === undefined ? { data: 'VPAIDFlash.swf', width: 800, height: 400 } : arguments[2];\n\n                    var _this = this;\n\n                    var params = arguments[3] === undefined ? { wmode: 'transparent', salign: 'tl', align: 'left', allowScriptAccess: 'always', scale: 'noScale', allowFullScreen: 'true', quality: 'high' } : arguments[3];\n                    var vpaidOptions = arguments[4] === undefined ? { debug: false, timeout: 10000 } : arguments[4];\n\n                    _classCallCheck(this, VPAIDFLASHClient);\n\n                    if (!VPAIDFLASHClient.hasExternalDependencies()) {\n                        return onError('no swfobject in global scope. check: https://github.com/swfobject/swfobject or https://code.google.com/p/swfobject/');\n                    }\n\n                    this._vpaidParentEl = vpaidParentEl;\n                    this._flashID = uniqueVPAID();\n                    this._destroyed = false;\n                    callback = callback || noop;\n\n                    swfConfig.width = isPositiveInt(swfConfig.width, 800);\n                    swfConfig.height = isPositiveInt(swfConfig.height, 400);\n\n                    createElementWithID(vpaidParentEl, this._flashID);\n\n                    params.movie = swfConfig.data;\n                    params.FlashVars = 'flashid=' + this._flashID + '&handler=' + JSFlashBridge.VPAID_FLASH_HANDLER + '&debug=' + vpaidOptions.debug + '&salign=' + params.salign;\n\n                    if (!VPAIDFLASHClient.isSupported()) {\n                        return onError('user don\\'t support flash or doesn\\'t have the minimum required version of flash ' + FLASH_VERSION);\n                    }\n\n                    this.el = swfobject.createSWF(swfConfig, params, this._flashID);\n\n                    if (!this.el) {\n                        return onError('swfobject failed to create object in element');\n                    }\n\n                    var handler = callbackTimeout(vpaidOptions.timeout, function(err, data) {\n                        $loadPendedAdUnit.call(_this);\n                        callback(err, data);\n                    }, function() {\n                        callback('vpaid flash load timeout ' + vpaidOptions.timeout);\n                    });\n\n                    this._flash = new JSFlashBridge(this.el, swfConfig.data, this._flashID, swfConfig.width, swfConfig.height, handler);\n\n                    function onError(error) {\n                        setTimeout(function() {\n                            callback(new Error(error));\n                        }, 0);\n                        return this;\n                    }\n                }\n\n                _createClass(VPAIDFLASHClient, [{\n                    key: 'destroy',\n                    value: function destroy() {\n                        this._destroyAdUnit();\n\n                        if (this._flash) {\n                            this._flash.destroy();\n                            this._flash = null;\n                        }\n                        this.el = null;\n                        this._destroyed = true;\n                    }\n                }, {\n                    key: 'isDestroyed',\n                    value: function isDestroyed() {\n                        return this._destroyed;\n                    }\n                }, {\n                    key: '_destroyAdUnit',\n                    value: function _destroyAdUnit() {\n                        delete this._loadLater;\n\n                        if (this._adUnitLoad) {\n                            this._adUnitLoad = null;\n                            this._flash.removeCallback(this._adUnitLoad);\n                        }\n\n                        if (this._adUnit) {\n                            this._adUnit._destroy();\n                            this._adUnit = null;\n                        }\n                    }\n                }, {\n                    key: 'loadAdUnit',\n                    value: function loadAdUnit(adURL, callback) {\n                        var _this2 = this;\n\n                        $throwIfDestroyed.call(this);\n\n                        if (this._adUnit) {\n                            this._destroyAdUnit();\n                        }\n\n                        if (this._flash.isReady()) {\n                            this._adUnitLoad = function(err, message) {\n                                if (!err) {\n                                    _this2._adUnit = new VPAIDAdUnit(_this2._flash);\n                                }\n                                _this2._adUnitLoad = null;\n                                callback(err, _this2._adUnit);\n                            };\n\n                            this._flash.callFlashMethod('loadAdUnit', [adURL], this._adUnitLoad);\n                        } else {\n                            this._loadLater = { url: adURL, callback: callback };\n                        }\n                    }\n                }, {\n                    key: 'unloadAdUnit',\n                    value: function unloadAdUnit() {\n                        var callback = arguments[0] === undefined ? undefined : arguments[0];\n\n                        $throwIfDestroyed.call(this);\n\n                        this._destroyAdUnit();\n                        this._flash.callFlashMethod('unloadAdUnit', [], callback);\n                    }\n                }, {\n                    key: 'getFlashID',\n                    value: function getFlashID() {\n                        $throwIfDestroyed.call(this);\n                        return this._flash.getFlashID();\n                    }\n                }, {\n                    key: 'getFlashURL',\n                    value: function getFlashURL() {\n                        $throwIfDestroyed.call(this);\n                        return this._flash.getFlashURL();\n                    }\n                }]);\n\n                return VPAIDFLASHClient;\n            })();\n\n            setStaticProperty('isSupported', function() {\n                return VPAIDFLASHClient.hasExternalDependencies() && swfobject.hasFlashPlayerVersion(FLASH_VERSION);\n            });\n\n            setStaticProperty('hasExternalDependencies', function() {\n                return !!window.swfobject;\n            });\n\n            function $throwIfDestroyed() {\n                if (this._destroyed) {\n                    throw new error('VPAIDFlashToJS is destroyed!');\n                }\n            }\n\n            function $loadPendedAdUnit() {\n                if (this._loadLater) {\n                    this.loadAdUnit(this._loadLater.url, this._loadLater.callback);\n                    delete this._loadLater;\n                }\n            }\n\n            function setStaticProperty(propertyName, value) {\n                Object.defineProperty(VPAIDFLASHClient, propertyName, {\n                    writable: false,\n                    configurable: false,\n                    value: value\n                });\n            }\n\n            window.VPAIDFLASHClient = VPAIDFLASHClient;\n            module.exports = VPAIDFLASHClient;\n\n        }, { \"./VPAIDAdUnit\": 2, \"./jsFlashBridge\": 4, \"./utils\": 7 }],\n        4: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            var unique = require('./utils').unique;\n            var isPositiveInt = require('./utils').isPositiveInt;\n            var stringEndsWith = require('./utils').stringEndsWith;\n            var SingleValueRegistry = require('./registry').SingleValueRegistry;\n            var MultipleValuesRegistry = require('./registry').MultipleValuesRegistry;\n            var registry = require('./jsFlashBridgeRegistry');\n            var VPAID_FLASH_HANDLER = 'vpaid_video_flash_handler';\n            var ERROR = 'AdError';\n\n            var JSFlashBridge = (function() {\n                function JSFlashBridge(el, flashURL, flashID, width, height, loadHandShake) {\n                    _classCallCheck(this, JSFlashBridge);\n\n                    this._el = el;\n                    this._flashID = flashID;\n                    this._flashURL = flashURL;\n                    this._width = width;\n                    this._height = height;\n                    this._handlers = new MultipleValuesRegistry();\n                    this._callbacks = new SingleValueRegistry();\n                    this._uniqueMethodIdentifier = unique(this._flashID);\n                    this._ready = false;\n                    this._handShakeHandler = loadHandShake;\n\n                    registry.addInstance(this._flashID, this);\n                }\n\n                _createClass(JSFlashBridge, [{\n                    key: 'on',\n                    value: function on(eventName, callback) {\n                        this._handlers.add(eventName, callback);\n                    }\n                }, {\n                    key: 'off',\n                    value: function off(eventName, callback) {\n                        return this._handlers.remove(eventName, callback);\n                    }\n                }, {\n                    key: 'offEvent',\n                    value: function offEvent(eventName) {\n                        return this._handlers.removeByKey(eventName);\n                    }\n                }, {\n                    key: 'offAll',\n                    value: function offAll() {\n                        return this._handlers.removeAll();\n                    }\n                }, {\n                    key: 'callFlashMethod',\n                    value: function callFlashMethod(methodName) {\n                        var args = arguments[1] === undefined ? [] : arguments[1];\n                        var callback = arguments[2] === undefined ? undefined : arguments[2];\n\n                        var callbackID = '';\n                        // if no callback, some methods the return is void so they don't need callback\n                        if (callback) {\n                            callbackID = this._uniqueMethodIdentifier() + '_' + methodName;\n                            this._callbacks.add(callbackID, callback);\n                        }\n\n                        try {\n                            //methods are created by ExternalInterface.addCallback in as3 code, if for some reason it failed\n                            //this code will throw an error\n                            this._el[methodName]([callbackID].concat(args));\n                        } catch (e) {\n                            if (callback) {\n                                $asyncCallback.call(this, callbackID, e);\n                            } else {\n\n                                //if there isn't any callback to return error use error event handler\n                                this._trigger(ERROR, e);\n                            }\n                        }\n                    }\n                }, {\n                    key: 'removeCallback',\n                    value: function removeCallback(callback) {\n                        return this._callbacks.removeByValue(callback);\n                    }\n                }, {\n                    key: 'removeCallbackByMethodName',\n                    value: function removeCallbackByMethodName(suffix) {\n                        var _this = this;\n\n                        this._callbacks.filterKeys(function(key) {\n                            return stringEndsWith(key, suffix);\n                        }).forEach(function(key) {\n                            _this._callbacks.remove(key);\n                        });\n                    }\n                }, {\n                    key: 'removeAllCallbacks',\n                    value: function removeAllCallbacks() {\n                        return this._callbacks.removeAll();\n                    }\n                }, {\n                    key: '_trigger',\n                    value: function _trigger(eventName, event) {\n                        var _this2 = this;\n\n                        this._handlers.get(eventName).forEach(function(callback) {\n                            //clickThru has to be sync, if not will be block by the popupblocker\n                            if (eventName === 'AdClickThru') {\n                                callback(event);\n                            } else {\n                                setTimeout(function() {\n                                    if (_this2._handlers.get(eventName).length > 0) {\n                                        callback(event);\n                                    }\n                                }, 0);\n                            }\n                        });\n                    }\n                }, {\n                    key: '_callCallback',\n                    value: function _callCallback(methodName, callbackID, err, result) {\n\n                        var callback = this._callbacks.get(callbackID);\n\n                        //not all methods callback's are mandatory\n                        //but if there exist an error, fire the error event\n                        if (!callback) {\n                            if (err && callbackID === '') {\n                                this.trigger(ERROR, err);\n                            }\n                            return;\n                        }\n\n                        $asyncCallback.call(this, callbackID, err, result);\n                    }\n                }, {\n                    key: '_handShake',\n                    value: function _handShake(err, data) {\n                        this._ready = true;\n                        if (this._handShakeHandler) {\n                            this._handShakeHandler(err, data);\n                            delete this._handShakeHandler;\n                        }\n                    }\n                }, {\n                    key: 'getSize',\n\n                    //methods like properties specific to this implementation of VPAID\n                    value: function getSize() {\n                        return { width: this._width, height: this._height };\n                    }\n                }, {\n                    key: 'setSize',\n                    value: function setSize(newWidth, newHeight) {\n                        this._width = isPositiveInt(newWidth, this._width);\n                        this._height = isPositiveInt(newHeight, this._height);\n                        this._el.setAttribute('width', this._width);\n                        this._el.setAttribute('height', this._height);\n                    }\n                }, {\n                    key: 'getWidth',\n                    value: function getWidth() {\n                        return this._width;\n                    }\n                }, {\n                    key: 'setWidth',\n                    value: function setWidth(newWidth) {\n                        this.setSize(newWidth, this._height);\n                    }\n                }, {\n                    key: 'getHeight',\n                    value: function getHeight() {\n                        return this._height;\n                    }\n                }, {\n                    key: 'setHeight',\n                    value: function setHeight(newHeight) {\n                        this.setSize(this._width, newHeight);\n                    }\n                }, {\n                    key: 'getFlashID',\n                    value: function getFlashID() {\n                        return this._flashID;\n                    }\n                }, {\n                    key: 'getFlashURL',\n                    value: function getFlashURL() {\n                        return this._flashURL;\n                    }\n                }, {\n                    key: 'isReady',\n                    value: function isReady() {\n                        return this._ready;\n                    }\n                }, {\n                    key: 'destroy',\n                    value: function destroy() {\n                        this.offAll();\n                        this.removeAllCallbacks();\n                        registry.removeInstanceByID(this._flashID);\n                        if (this._el.parentElement) {\n                            this._el.parentElement.removeChild(this._el);\n                        }\n                    }\n                }]);\n\n                return JSFlashBridge;\n            })();\n\n            exports.JSFlashBridge = JSFlashBridge;\n\n            function $asyncCallback(callbackID, err, result) {\n                var _this3 = this;\n\n                setTimeout(function() {\n                    var callback = _this3._callbacks.get(callbackID);\n                    if (callback) {\n                        _this3._callbacks.remove(callbackID);\n                        callback(err, result);\n                    }\n                }, 0);\n            }\n\n            Object.defineProperty(JSFlashBridge, 'VPAID_FLASH_HANDLER', {\n                writable: false,\n                configurable: false,\n                value: VPAID_FLASH_HANDLER\n            });\n\n            /**\n             * External interface handler\n             *\n             * @param {string} flashID identifier of the flash who call this\n             * @param {string} typeID what type of message is, can be 'event' or 'callback'\n             * @param {string} typeName if the typeID is a event the typeName will be the eventName, if is a callback the typeID is the methodName that is related this callback\n             * @param {string} callbackID only applies when the typeID is 'callback', identifier of the callback to call\n             * @param {object} error error object\n             * @param {object} data\n             */\n            window[VPAID_FLASH_HANDLER] = function(flashID, typeID, typeName, callbackID, error, data) {\n                var instance = registry.getInstanceByID(flashID);\n                if (!instance) return;\n                if (typeName === 'handShake') {\n                    instance._handShake(error, data);\n                } else {\n                    if (typeID !== 'event') {\n                        instance._callCallback(typeName, callbackID, error, data);\n                    } else {\n                        instance._trigger(typeName, data);\n                    }\n                }\n            };\n\n        }, { \"./jsFlashBridgeRegistry\": 5, \"./registry\": 6, \"./utils\": 7 }],\n        5: [function(require, module, exports) {\n            'use strict';\n\n            var SingleValueRegistry = require('./registry').SingleValueRegistry;\n            var instances = new SingleValueRegistry();\n\n            var JSFlashBridgeRegistry = {};\n            Object.defineProperty(JSFlashBridgeRegistry, 'addInstance', {\n                writable: false,\n                configurable: false,\n                value: function value(id, instance) {\n                    instances.add(id, instance);\n                }\n            });\n\n            Object.defineProperty(JSFlashBridgeRegistry, 'getInstanceByID', {\n                writable: false,\n                configurable: false,\n                value: function value(id) {\n                    return instances.get(id);\n                }\n            });\n\n            Object.defineProperty(JSFlashBridgeRegistry, 'removeInstanceByID', {\n                writable: false,\n                configurable: false,\n                value: function value(id) {\n                    return instances.remove(id);\n                }\n            });\n\n            module.exports = JSFlashBridgeRegistry;\n\n        }, { \"./registry\": 6 }],\n        6: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n\n            var _createClass = (function() {\n                function defineProperties(target, props) {\n                    for (var i = 0; i < props.length; i++) {\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if ('value' in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor); } }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor; }; })();\n\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError('Cannot call a class as a function'); } }\n\n            var MultipleValuesRegistry = (function() {\n                function MultipleValuesRegistry() {\n                    _classCallCheck(this, MultipleValuesRegistry);\n\n                    this._registries = {};\n                }\n\n                _createClass(MultipleValuesRegistry, [{\n                    key: 'add',\n                    value: function add(id, value) {\n                        if (!this._registries[id]) {\n                            this._registries[id] = [];\n                        }\n                        if (this._registries[id].indexOf(value) === -1) {\n                            this._registries[id].push(value);\n                        }\n                    }\n                }, {\n                    key: 'get',\n                    value: function get(id) {\n                        return this._registries[id] || [];\n                    }\n                }, {\n                    key: 'filterKeys',\n                    value: function filterKeys(handler) {\n                        return Object.keys(this._registries).filter(handler);\n                    }\n                }, {\n                    key: 'findByValue',\n                    value: function findByValue(value) {\n                        var _this = this;\n\n                        var keys = Object.keys(this._registries).filter(function(key) {\n                            return _this._registries[key].indexOf(value) !== -1;\n                        });\n\n                        return keys;\n                    }\n                }, {\n                    key: 'remove',\n                    value: function remove(key, value) {\n                        if (!this._registries[key]) {\n                            return;\n                        }\n\n                        var index = this._registries[key].indexOf(value);\n\n                        if (index < 0) {\n                            return;\n                        }\n                        return this._registries[key].splice(index, 1);\n                    }\n                }, {\n                    key: 'removeByKey',\n                    value: function removeByKey(id) {\n                        var old = this._registries[id];\n                        delete this._registries[id];\n                        return old;\n                    }\n                }, {\n                    key: 'removeByValue',\n                    value: function removeByValue(value) {\n                        var _this2 = this;\n\n                        var keys = this.findByValue(value);\n                        return keys.map(function(key) {\n                            return _this2.remove(key, value);\n                        });\n                    }\n                }, {\n                    key: 'removeAll',\n                    value: function removeAll() {\n                        var old = this._registries;\n                        this._registries = {};\n                        return old;\n                    }\n                }, {\n                    key: 'size',\n                    value: function size() {\n                        return Object.keys(this._registries).length;\n                    }\n                }]);\n\n                return MultipleValuesRegistry;\n            })();\n\n            exports.MultipleValuesRegistry = MultipleValuesRegistry;\n\n            var SingleValueRegistry = (function() {\n                function SingleValueRegistry() {\n                    _classCallCheck(this, SingleValueRegistry);\n\n                    this._registries = {};\n                }\n\n                _createClass(SingleValueRegistry, [{\n                    key: 'add',\n                    value: function add(id, value) {\n                        this._registries[id] = value;\n                    }\n                }, {\n                    key: 'get',\n                    value: function get(id) {\n                        return this._registries[id];\n                    }\n                }, {\n                    key: 'filterKeys',\n                    value: function filterKeys(handler) {\n                        return Object.keys(this._registries).filter(handler);\n                    }\n                }, {\n                    key: 'findByValue',\n                    value: function findByValue(value) {\n                        var _this3 = this;\n\n                        var keys = Object.keys(this._registries).filter(function(key) {\n                            return _this3._registries[key] === value;\n                        });\n\n                        return keys;\n                    }\n                }, {\n                    key: 'remove',\n                    value: function remove(id) {\n                        var old = this._registries[id];\n                        delete this._registries[id];\n                        return old;\n                    }\n                }, {\n                    key: 'removeByValue',\n                    value: function removeByValue(value) {\n                        var _this4 = this;\n\n                        var keys = this.findByValue(value);\n                        return keys.map(function(key) {\n                            return _this4.remove(key);\n                        });\n                    }\n                }, {\n                    key: 'removeAll',\n                    value: function removeAll() {\n                        var old = this._registries;\n                        this._registries = {};\n                        return old;\n                    }\n                }, {\n                    key: 'size',\n                    value: function size() {\n                        return Object.keys(this._registries).length;\n                    }\n                }]);\n\n                return SingleValueRegistry;\n            })();\n\n            exports.SingleValueRegistry = SingleValueRegistry;\n\n        }, {}],\n        7: [function(require, module, exports) {\n            'use strict';\n\n            Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n            exports.unique = unique;\n            exports.noop = noop;\n            exports.callbackTimeout = callbackTimeout;\n            exports.createElementWithID = createElementWithID;\n            exports.isPositiveInt = isPositiveInt;\n            exports.stringEndsWith = stringEndsWith;\n\n            function unique(prefix) {\n                var count = -1;\n                return function(f) {\n                    return prefix + '_' + ++count;\n                };\n            }\n\n            function noop() {}\n\n            function callbackTimeout(timer, onSuccess, onTimeout) {\n\n                var timeout = setTimeout(function() {\n\n                    onSuccess = noop;\n                    onTimeout();\n                }, timer);\n\n                return function() {\n                    clearTimeout(timeout);\n                    onSuccess.apply(this, arguments);\n                };\n            }\n\n            function createElementWithID(parent, id) {\n                var nEl = document.createElement('div');\n                nEl.id = id;\n                parent.innerHTML = '';\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            function isPositiveInt(newVal, oldVal) {\n                return !isNaN(parseFloat(newVal)) && isFinite(newVal) && newVal > 0 ? newVal : oldVal;\n            }\n\n            var endsWith = (function() {\n                if (String.prototype.endsWith) return String.prototype.endsWith;\n                return function endsWith(searchString, position) {\n                    var subjectString = this.toString();\n                    if (position === undefined || position > subjectString.length) {\n                        position = subjectString.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = subjectString.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                };\n            })();\n\n            function stringEndsWith(string, search) {\n                return endsWith.call(string, search);\n            }\n\n        }, {}]\n    }, {}, [3])\n\n\n    //# sourceMappingURL=VPAIDFLASHClient.js.map\n    ;\n    /*jshint unused:false */\n    \"use strict\";\n\n    var NODE_TYPE_ELEMENT = 1;\n\n    function noop() {}\n\n    function isNull(o) {\n        return o === null;\n    }\n\n    function isDefined(o) {\n        return o !== undefined;\n    }\n\n    function isUndefined(o) {\n        return o === undefined;\n    }\n\n    function isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    function isFunction(str) {\n        return typeof str === 'function';\n    }\n\n    function isNumber(num) {\n        return typeof num === 'number';\n    }\n\n    function isWindow(obj) {\n        return isObject(obj) && obj.window === obj;\n    }\n\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === '[object Array]';\n    }\n\n    function isArrayLike(obj) {\n        if (obj === null || isWindow(obj) || isFunction(obj) || isUndefined(obj)) {\n            return false;\n        }\n\n        var length = obj.length;\n\n        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {\n            return true;\n        }\n\n        return isString(obj) || isArray(obj) || length === 0 ||\n            typeof length === 'number' && length > 0 && (length - 1) in obj;\n    }\n\n    function isString(str) {\n        return typeof str === 'string';\n    }\n\n    function isEmptyString(str) {\n        return isString(str) && str.length === 0;\n    }\n\n    function isNotEmptyString(str) {\n        return isString(str) && str.length !== 0;\n    }\n\n    function arrayLikeObjToArray(args) {\n        return Array.prototype.slice.call(args);\n    }\n\n    function forEach(obj, iterator, context) {\n        var key, length;\n        if (obj) {\n            if (isFunction(obj)) {\n                for (key in obj) {\n                    // Need to check if hasOwnProperty exists,\n                    // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function\n                    if (key !== 'prototype' && key !== 'length' && key !== 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            } else if (isArray(obj)) {\n                var isPrimitive = typeof obj !== 'object';\n                for (key = 0, length = obj.length; key < length; key++) {\n                    if (isPrimitive || key in obj) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            } else if (obj.forEach && obj.forEach !== forEach) {\n                obj.forEach(iterator, context, obj);\n            } else {\n                for (key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        iterator.call(context, obj[key], key, obj);\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n\n    var SNAKE_CASE_REGEXP = /[A-Z]/g;\n\n    function snake_case(name, separator) {\n        separator = separator || '_';\n        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n            return (pos ? separator : '') + letter.toLowerCase();\n        });\n    }\n\n    function isValidEmail(email) {\n        if (!isString(email)) {\n            return false;\n        }\n        var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)+$/i;\n        return EMAIL_REGEXP.test(email.trim());\n    }\n\n    function extend(obj) {\n        var arg, i, k;\n        for (i = 1; i < arguments.length; i++) {\n            arg = arguments[i];\n            for (k in arg) {\n                if (arg.hasOwnProperty(k)) {\n                    if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {\n                        obj[k] = extend({}, obj[k], arg[k]);\n                    } else {\n                        obj[k] = arg[k];\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n\n    function capitalize(s) {\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    }\n\n    function decapitalize(s) {\n        return s.charAt(0).toLowerCase() + s.slice(1);\n    }\n\n    /**\n     * This method works the same way array.prototype.map works but if the transformer returns undefine, then\n     * it won't be added to the transformed Array.\n     */\n    function transformArray(array, transformer) {\n        var transformedArray = [];\n\n        array.forEach(function(item, index) {\n            var transformedItem = transformer(item, index);\n            if (isDefined(transformedItem)) {\n                transformedArray.push(transformedItem);\n            }\n        });\n\n        return transformedArray;\n    }\n\n    function toFixedDigits(num, digits) {\n        var formattedNum = num + '';\n        digits = isNumber(digits) ? digits : 0;\n        num = isNumber(num) ? num : parseInt(num, 10);\n        if (isNumber(num) && !isNaN(num)) {\n            formattedNum = num + '';\n            while (formattedNum.length < digits) {\n                formattedNum = '0' + formattedNum;\n            }\n            return formattedNum;\n        }\n        return NaN + '';\n    }\n\n    function debounce(callback, wait) {\n        var timeoutId;\n\n        return function() {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            timeoutId = setTimeout(function() {\n                callback.apply(this, arguments);\n                timeoutId = undefined;\n            }, wait);\n        };\n    }\n\n    // a function designed to blow up the stack in a naive way\n    // but it is ok for videoJs children components\n    function treeSearch(root, getChildren, found) {\n        var children = getChildren(root);\n        for (var i = 0; i < children.length; i++) {\n            if (found(children[i])) {\n                return children[i];\n            } else {\n                var el = treeSearch(children[i], getChildren, found);\n                if (el) {\n                    return el;\n                }\n            }\n        }\n    }\n\n    function echoFn(val) {\n        return function() {\n            return val;\n        };\n    }\n\n    //Note: Supported formats come from http://www.w3.org/TR/NOTE-datetime\n    // and the iso8601 regex comes from http://www.pelagodesign.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/\n    function isISO8601(value) {\n        if (isNumber(value)) {\n            value = value + ''; //we make sure that we are working with strings\n        }\n\n        if (!isString(value)) {\n            return false;\n        }\n\n        /*jslint maxlen: 500 */\n        var iso8086Regex = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24\\:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n        return iso8086Regex.test(value.trim());\n    }\n\n    /**\n     * Checks if the Browser is IE9 and below\n     * @returns {boolean}\n     */\n    function isOldIE() {\n        var version = getInternetExplorerVersion(navigator);\n        if (version === -1) {\n            return false;\n        }\n\n        return version < 10;\n    }\n\n    /**\n     * Returns the version of Internet Explorer or a -1 (indicating the use of another browser).\n     * Source: https://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx\n     * @returns {number} the version of Internet Explorer or a -1 (indicating the use of another browser).\n     */\n    function getInternetExplorerVersion(navigator) {\n        var rv = -1;\n\n        if (navigator.appName == 'Microsoft Internet Explorer') {\n            var ua = navigator.userAgent;\n            var re = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\n            var res = re.exec(ua);\n            if (res !== null) {\n                rv = parseFloat(res[1]);\n            }\n        }\n\n        return rv;\n    }\n\n    /*** Mobile Utility functions ***/\n    var _UA = navigator.userAgent;\n\n    function isIDevice() {\n        return /iP(hone|ad)/.test(_UA);\n    }\n\n    function isMobile() {\n        return /iP(hone|ad|od)|Android|Windows Phone/.test(_UA);\n    }\n\n    function isIPhone() {\n        return /iP(hone|od)/.test(_UA);\n    }\n\n    function isAndroid() {\n        return /Android/.test(_UA);\n    }\n\n    ;\n    (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof require == \"function\" && require;\n                    if (!u && a) return a(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f }\n                var l = n[o] = { exports: {} };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e) }, l, l.exports, e, t, n, r) }\n            return n[o].exports }\n        var i = typeof require == \"function\" && require;\n        for (var o = 0; o < r.length; o++) s(r[o]);\n        return s })({\n        1: [function(require, module, exports) {\n            'use strict';\n\n            var METHODS = [\n                'handshakeVersion',\n                'initAd',\n                'startAd',\n                'stopAd',\n                'skipAd', // VPAID 2.0 new method\n                'resizeAd',\n                'pauseAd',\n                'resumeAd',\n                'expandAd',\n                'collapseAd',\n                'subscribe',\n                'unsubscribe'\n            ];\n\n            var EVENTS = [\n                'AdLoaded',\n                'AdStarted',\n                'AdStopped',\n                'AdSkipped',\n                'AdSkippableStateChange', // VPAID 2.0 new event\n                'AdSizeChange', // VPAID 2.0 new event\n                'AdLinearChange',\n                'AdDurationChange', // VPAID 2.0 new event\n                'AdExpandedChange',\n                'AdRemainingTimeChange', // [Deprecated in 2.0] but will be still fired for backwards compatibility\n                'AdVolumeChange',\n                'AdImpression',\n                'AdVideoStart',\n                'AdVideoFirstQuartile',\n                'AdVideoMidpoint',\n                'AdVideoThirdQuartile',\n                'AdVideoComplete',\n                'AdClickThru',\n                'AdInteraction', // VPAID 2.0 new event\n                'AdUserAcceptInvitation',\n                'AdUserMinimize',\n                'AdUserClose',\n                'AdPaused',\n                'AdPlaying',\n                'AdLog',\n                'AdError'\n            ];\n\n            var GETTERS = [\n                'getAdLinear',\n                'getAdWidth', // VPAID 2.0 new getter\n                'getAdHeight', // VPAID 2.0 new getter\n                'getAdExpanded',\n                'getAdSkippableState', // VPAID 2.0 new getter\n                'getAdRemainingTime',\n                'getAdDuration', // VPAID 2.0 new getter\n                'getAdVolume',\n                'getAdCompanions', // VPAID 2.0 new getter\n                'getAdIcons' // VPAID 2.0 new getter\n            ];\n\n            var SETTERS = [\n                'setAdVolume'\n            ];\n\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n\n            /**\n             * IVPAIDAdUnit\n             *\n             * @class\n             *\n             * @param {object} creative\n             * @param {HTMLElement} el\n             * @param {HTMLVideoElement} video\n             */\n            function IVPAIDAdUnit(creative, el, video) {}\n\n\n            /**\n             * handshakeVersion\n             *\n             * @param {string} VPAIDVersion\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.handshakeVersion = function(VPAIDVersion, callback) {};\n\n            /**\n             * initAd\n             *\n             * @param {number} width\n             * @param {number} height\n             * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'\n             * @param {number} desiredBitrate indicates the desired bitrate in kbps\n             * @param {object} [creativeData] used for additional initialization data\n             * @param {object} [environmentVars] used for passing implementation-specific of js version\n             * @param {NodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.initAd = function(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {};\n\n            /**\n             * startAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.startAd = function(callback) {};\n\n            /**\n             * stopAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.stopAd = function(callback) {};\n\n            /**\n             * skipAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.skipAd = function(callback) {};\n\n            /**\n             * resizeAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.resizeAd = function(width, height, viewMode, callback) {};\n\n            /**\n             * pauseAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.pauseAd = function(callback) {};\n\n            /**\n             * resumeAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.resumeAd = function(callback) {};\n\n            /**\n             * expandAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.expandAd = function(callback) {};\n\n            /**\n             * collapseAd\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.collapseAd = function(callback) {};\n\n            /**\n             * subscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             * @param {object} context\n             */\n            IVPAIDAdUnit.prototype.subscribe = function(event, handler, context) {};\n\n            /**\n             * startAd\n             *\n             * @param {string} event\n             * @param {function} handler\n             */\n            IVPAIDAdUnit.prototype.unsubscribe = function(event, handler) {};\n\n\n\n            /**\n             * getAdLinear\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdLinear = function(callback) {};\n\n            /**\n             * getAdWidth\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdWidth = function(callback) {};\n\n            /**\n             * getAdHeight\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdHeight = function(callback) {};\n\n            /**\n             * getAdExpanded\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdExpanded = function(callback) {};\n\n            /**\n             * getAdSkippableState\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdSkippableState = function(callback) {};\n\n            /**\n             * getAdRemainingTime\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdRemainingTime = function(callback) {};\n\n            /**\n             * getAdDuration\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdDuration = function(callback) {};\n\n            /**\n             * getAdVolume\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdVolume = function(callback) {};\n\n            /**\n             * getAdCompanions\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdCompanions = function(callback) {};\n\n            /**\n             * getAdIcons\n             *\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.getAdIcons = function(callback) {};\n\n            /**\n             * setAdVolume\n             *\n             * @param {number} volume\n             * @param {nodeStyleCallback} callback\n             */\n            IVPAIDAdUnit.prototype.setAdVolume = function(volume, callback) {};\n\n            addStaticToInterface(IVPAIDAdUnit, 'METHODS', METHODS);\n            addStaticToInterface(IVPAIDAdUnit, 'GETTERS', GETTERS);\n            addStaticToInterface(IVPAIDAdUnit, 'SETTERS', SETTERS);\n            addStaticToInterface(IVPAIDAdUnit, 'EVENTS', EVENTS);\n\n\n            var VPAID1_METHODS = METHODS.filter(function(method) {\n                return ['skipAd'].indexOf(method) === -1;\n            });\n\n            addStaticToInterface(IVPAIDAdUnit, 'checkVPAIDInterface', function checkVPAIDInterface(creative) {\n                var result = VPAID1_METHODS.every(function(key) {\n                    return typeof creative[key] === 'function';\n                });\n                return result;\n            });\n\n            module.exports = IVPAIDAdUnit;\n\n            function addStaticToInterface(Interface, name, value) {\n                Object.defineProperty(Interface, name, {\n                    writable: false,\n                    configurable: false,\n                    value: value\n                });\n            }\n\n\n        }, {}],\n        2: [function(require, module, exports) {\n            'use strict';\n\n            var IVPAIDAdUnit = require('./IVPAIDAdUnit');\n            var Subscriber = require('./subscriber');\n            var checkVPAIDInterface = IVPAIDAdUnit.checkVPAIDInterface;\n            var utils = require('./utils');\n            var METHODS = IVPAIDAdUnit.METHODS;\n            var ERROR = 'AdError';\n            var AD_CLICK = 'AdClickThru';\n            var FILTERED_EVENTS = IVPAIDAdUnit.EVENTS.filter(function(event) {\n                return event != AD_CLICK;\n            });\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n\n            /**\n             * VPAIDAdUnit\n             * @class\n             *\n             * @param VPAIDCreative\n             * @param {HTMLElement} [el] this will be used in initAd environmentVars.slot if defined\n             * @param {HTMLVideoElement} [video] this will be used in initAd environmentVars.videoSlot if defined\n             */\n            function VPAIDAdUnit(VPAIDCreative, el, video, iframe) {\n                this._isValid = checkVPAIDInterface(VPAIDCreative);\n                if (this._isValid) {\n                    this._creative = VPAIDCreative;\n                    this._el = el;\n                    this._videoEl = video;\n                    this._iframe = iframe;\n                    this._subscribers = new Subscriber();\n                    $addEventsSubscribers.call(this);\n                }\n            }\n\n            VPAIDAdUnit.prototype = Object.create(IVPAIDAdUnit.prototype);\n\n            /**\n             * isValidVPAIDAd will return if the VPAIDCreative passed in constructor is valid or not\n             *\n             * @return {boolean}\n             */\n            VPAIDAdUnit.prototype.isValidVPAIDAd = function isValidVPAIDAd() {\n                return this._isValid;\n            };\n\n            IVPAIDAdUnit.METHODS.forEach(function(method) {\n                //NOTE: this methods arguments order are implemented differently from the spec\n                var ignores = [\n                    'subscribe',\n                    'unsubscribe',\n                    'initAd'\n                ];\n\n                if (ignores.indexOf(method) !== -1) return;\n\n                VPAIDAdUnit.prototype[method] = function() {\n                    var ariaty = IVPAIDAdUnit.prototype[method].length;\n                    // TODO avoid leaking arguments\n                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                    var args = Array.prototype.slice.call(arguments);\n                    var callback = (ariaty === args.length) ? args.pop() : undefined;\n\n                    setTimeout(function() {\n                        var result, error = null;\n                        try {\n                            result = this._creative[method].apply(this._creative, args);\n                        } catch (e) {\n                            error = e;\n                        }\n\n                        callOrTriggerEvent(callback, this._subscribers, error, result);\n                    }.bind(this), 0);\n                };\n            });\n\n\n            /**\n             * initAd concreate implementation\n             *\n             * @param {number} width\n             * @param {number} height\n             * @param {string} viewMode can be 'normal', 'thumbnail' or 'fullscreen'\n             * @param {number} desiredBitrate indicates the desired bitrate in kbps\n             * @param {object} [creativeData] used for additional initialization data\n             * @param {object} [environmentVars] used for passing implementation-specific of js version, if el & video was used in constructor slot & videoSlot will be added to the object\n             * @param {NodeStyleCallback} callback\n             */\n            VPAIDAdUnit.prototype.initAd = function initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {\n                creativeData = creativeData || {};\n                environmentVars = utils.extend({\n                    slot: this._el,\n                    videoSlot: this._videoEl\n                }, environmentVars || {});\n\n                setTimeout(function() {\n                    var error;\n                    try {\n                        this._creative.initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars);\n                    } catch (e) {\n                        error = e;\n                    }\n\n                    callOrTriggerEvent(callback, this._subscribers, error);\n                }.bind(this), 0);\n            };\n\n            /**\n             * subscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             * @param {object} context\n             */\n            VPAIDAdUnit.prototype.subscribe = function subscribe(event, handler, context) {\n                this._subscribers.subscribe(handler, event, context);\n            };\n\n\n            /**\n             * unsubscribe\n             *\n             * @param {string} event\n             * @param {nodeStyleCallback} handler\n             */\n            VPAIDAdUnit.prototype.unsubscribe = function unsubscribe(event, handler) {\n                this._subscribers.unsubscribe(handler, event);\n            };\n\n            //alias\n            VPAIDAdUnit.prototype.on = VPAIDAdUnit.prototype.subscribe;\n            VPAIDAdUnit.prototype.off = VPAIDAdUnit.prototype.unsubscribe;\n\n            IVPAIDAdUnit.GETTERS.forEach(function(getter) {\n                VPAIDAdUnit.prototype[getter] = function(callback) {\n                    setTimeout(function() {\n\n                        var result, error = null;\n                        try {\n                            result = this._creative[getter]();\n                        } catch (e) {\n                            error = e;\n                        }\n\n                        callOrTriggerEvent(callback, this._subscribers, error, result);\n                    }.bind(this), 0);\n                };\n            });\n\n            /**\n             * setAdVolume\n             *\n             * @param volume\n             * @param {nodeStyleCallback} callback\n             */\n            VPAIDAdUnit.prototype.setAdVolume = function setAdVolume(volume, callback) {\n                setTimeout(function() {\n\n                    var self = this;\n                    var result, error = null;\n                    try {\n                        this._creative.setAdVolume(volume);\n                    } catch (e) {\n                        error = e;\n                    }\n                    // Wait for creative volume to be set\n                    setTimeout(function() {\n                        result = self._creative.getAdVolume();\n                        if (!error) {\n                            error = utils.validate(result === volume, 'failed to apply volume: ' + volume);\n                        }\n                        callOrTriggerEvent(callback, self._subscribers, error, result);\n                    }, 200)\n                }.bind(this), 0);\n            };\n\n            VPAIDAdUnit.prototype._destroy = function destroy() {\n                this.stopAd();\n                this._subscribers.unsubscribeAll();\n            };\n\n            function $addEventsSubscribers() {\n                // some ads implement\n                // so they only handle one subscriber\n                // to handle this we create our one\n                FILTERED_EVENTS.forEach(function(event) {\n                    this._creative.subscribe($trigger.bind(this, event), event);\n                }.bind(this));\n\n                // map the click event to be an object instead of depending of the order of the arguments\n                // and to be consistent with the flash\n                this._creative.subscribe($clickThruHook.bind(this), AD_CLICK);\n\n                // because we are adding the element inside the iframe\n                // the user is not able to click in the video\n                if (this._videoEl) {\n                    var documentElement = this._iframe.contentDocument.documentElement;\n                    var videoEl = this._videoEl;\n                    documentElement.addEventListener('click', function(e) {\n                        if (e.target === documentElement) {\n                            videoEl.click();\n                        }\n                    });\n                }\n            }\n\n            function $clickThruHook(url, id, playerHandles) {\n                this._subscribers.triggerSync(AD_CLICK, { url: url, id: id, playerHandles: playerHandles });\n            }\n\n            function $trigger(event) {\n                // TODO avoid leaking arguments\n                // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                this._subscribers.trigger(event, Array.prototype.slice.call(arguments, 1));\n            }\n\n            function callOrTriggerEvent(callback, subscribers, error, result) {\n                if (callback) {\n                    callback(error, result);\n                } else if (error) {\n                    subscribers.trigger(ERROR, error);\n                }\n            }\n\n            module.exports = VPAIDAdUnit;\n\n\n        }, { \"./IVPAIDAdUnit\": 1, \"./subscriber\": 4, \"./utils\": 5 }],\n        3: [function(require, module, exports) {\n            'use strict';\n\n\n            var utils = require('./utils');\n            var unique = utils.unique('vpaidIframe');\n            var VPAIDAdUnit = require('./VPAIDAdUnit');\n            //var defaultTemplate = \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n</head>\\n<body>\\n    <script type=\\\"text/javascript\\\" src=\\\"{{iframeURL_JS}}\\\"></script>\\n    <script>\\n        parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', window.location.origin);\\n    </script>\\n    <div class=\\\"ad-element\\\">\\n    </div>\\n</body>\\n</html>\\n\";\n            var defaultTemplate = \"<!DOCTYPE html>\\n<html>\\n <head>\\n </head>\\n <body style=\\\"margin:0px;overflow:hidden;\\\">\\n    <script type=\\\"text/javascript\\\" src=\\\"{{iframeURL_JS}}\\\"></script>\\n    <script>\\n        //parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', window.location.origin);\\n        //minthe : this should have proper logic for dynamic iframe generates on runtime.\\n        console.log(\\\"send postmessage\\\");\\n        parent.postMessage('{\\\"event\\\": \\\"ready\\\", \\\"id\\\": \\\"{{iframeID}}\\\"}', \\\"*\\\");\\n    </script>\\n    <div class=\\\"ad-element\\\">\\n    </div>\\n</body>\\n</html>\\n\";\n\n            var AD_STOPPED = 'AdStopped';\n\n            /**\n             * This callback is displayed as global member. The callback use nodejs error-first callback style\n             * @callback NodeStyleCallback\n             * @param {string|null}\n             * @param {undefined|object}\n             */\n\n            /**\n             * VPAIDHTML5Client\n             * @class\n             *\n             * @param {HTMLElement} el that will contain the iframe to load adUnit and a el to add to adUnit slot\n             * @param {HTMLVideoElement} video default video element to be used by adUnit\n             * @param {object} [templateConfig] template: html template to be used instead of the default, extraOptions: to be used when rendering the template\n             * @param {object} [vpaidOptions] timeout: when loading adUnit\n             */\n            function VPAIDHTML5Client(el, video, templateConfig, vpaidOptions) {\n                templateConfig = templateConfig || {};\n\n                this._id = unique();\n                this._destroyed = false;\n\n                this._frameContainer = utils.createElementInEl(el, 'div');\n                this._videoEl = video;\n                this._vpaidOptions = vpaidOptions || { timeout: 10000 };\n\n                this._templateConfig = {\n                    template: templateConfig.template || defaultTemplate,\n                    extraOptions: templateConfig.extraOptions || {}\n                };\n\n            }\n\n            /**\n             * destroy\n             *\n             */\n            VPAIDHTML5Client.prototype.destroy = function destroy() {\n                if (this._destroyed) {\n                    return;\n                }\n                this._destroyed = true;\n                $unloadPreviousAdUnit.call(this);\n            };\n\n            /**\n             * isDestroyed\n             *\n             * @return {boolean}\n             */\n            VPAIDHTML5Client.prototype.isDestroyed = function isDestroyed() {\n                return this._destroyed;\n            };\n\n            /**\n             * loadAdUnit\n             *\n             * @param {string} adURL url of the js of the adUnit\n             * @param {nodeStyleCallback} callback\n             */\n            VPAIDHTML5Client.prototype.loadAdUnit = function loadAdUnit(adURL, callback) {\n                $throwIfDestroyed.call(this);\n                $unloadPreviousAdUnit.call(this);\n\n                var frame = utils.createIframeWithContent(\n                    this._frameContainer,\n                    this._templateConfig.template,\n                    utils.extend({\n                        iframeURL_JS: adURL,\n                        iframeID: this.getID()\n                    }, this._templateConfig.extraOptions)\n                );\n                this._frame = frame;\n\n                this._onLoad = utils.callbackTimeout(\n                    this._vpaidOptions.timeout,\n                    onLoad.bind(this),\n                    onTimeout.bind(this)\n                );\n\n                window.addEventListener('message', this._onLoad);\n\n                function onLoad(e) {\n\n                    console.log(\"got postMessage from container\");\n\n                    //minthe : this should have proper logic for dynamic iframe generates on runtime.\n                    //don't clear timeout\n                    //if (e.origin !== window.location.origin) return;\n                    var result = JSON.parse(e.data);\n\n                    //don't clear timeout\n                    if (result.id !== this.getID()) return;\n\n                    var adUnit, error, createAd;\n                    if (!this._frame.contentWindow) {\n\n                        error = 'the iframe is not anymore in the DOM tree';\n\n                    } else {\n                        createAd = this._frame.contentWindow.getVPAIDAd;\n                        error = utils.validate(typeof createAd === 'function', 'the ad didn\\'t return a function to create an ad');\n                    }\n\n                    if (!error) {\n                        var adEl = this._frame.contentWindow.document.querySelector('.ad-element');\n                        adUnit = new VPAIDAdUnit(createAd(), adEl, this._videoEl, this._frame);\n                        adUnit.subscribe(AD_STOPPED, $adDestroyed.bind(this));\n                        error = utils.validate(adUnit.isValidVPAIDAd(), 'the add is not fully complaint with VPAID specification');\n                    }\n\n                    this._adUnit = adUnit;\n                    $destroyLoadListener.call(this);\n                    callback(error, error ? null : adUnit);\n\n                    //clear timeout\n                    return true;\n                }\n\n                function onTimeout() {\n                    callback('timeout', null);\n                }\n            };\n\n            /**\n             * unloadAdUnit\n             *\n             */\n            VPAIDHTML5Client.prototype.unloadAdUnit = function unloadAdUnit() {\n                $unloadPreviousAdUnit.call(this);\n            };\n\n            /**\n             * getID will return the unique id\n             *\n             * @return {string}\n             */\n            VPAIDHTML5Client.prototype.getID = function() {\n                return this._id;\n            };\n\n\n            /**\n             * $removeEl\n             *\n             * @param {string} key\n             */\n            function $removeEl(key) {\n                var el = this[key];\n                if (el) {\n                    el.remove();\n                    delete this[key];\n                }\n            }\n\n            function $adDestroyed() {\n                $removeAdElements.call(this);\n                delete this._adUnit;\n            }\n\n            function $unloadPreviousAdUnit() {\n                $removeAdElements.call(this);\n                $destroyAdUnit.call(this);\n            }\n\n            function $removeAdElements() {\n                $removeEl.call(this, '_frame');\n                $destroyLoadListener.call(this);\n            }\n\n            /**\n             * $destroyLoadListener\n             *\n             */\n            function $destroyLoadListener() {\n                if (this._onLoad) {\n                    window.removeEventListener('message', this._onLoad);\n                    utils.clearCallbackTimeout(this._onLoad);\n                    delete this._onLoad;\n                }\n            }\n\n\n            function $destroyAdUnit() {\n                if (this._adUnit) {\n                    this._adUnit.stopAd();\n                    delete this._adUnit;\n                }\n            }\n\n            /**\n             * $throwIfDestroyed\n             *\n             */\n            function $throwIfDestroyed() {\n                if (this._destroyed) {\n                    throw new Error('VPAIDHTML5Client already destroyed!');\n                }\n            }\n\n            module.exports = VPAIDHTML5Client;\n            window.VPAIDHTML5Client = VPAIDHTML5Client;\n\n\n        }, { \"./VPAIDAdUnit\": 2, \"./utils\": 5 }],\n        4: [function(require, module, exports) {\n            'use strict';\n\n            function Subscriber() {\n                this._subscribers = {};\n            }\n\n            Subscriber.prototype.subscribe = function subscribe(handler, eventName, context) {\n                this.get(eventName).push({ handler: handler, context: context });\n            };\n\n            Subscriber.prototype.unsubscribe = function unsubscribe(handler, eventName) {\n                this._subscribers[eventName] = this.get(eventName).filter(function(subscriber) {\n                    return handler === subscriber.handler;\n                });\n            };\n\n            Subscriber.prototype.unsubscribeAll = function unsubscribeAll() {\n                this._subscribers = {};\n            };\n\n            Subscriber.prototype.trigger = function(eventName, data) {\n                var that = this;\n                that.get(eventName).forEach(function(subscriber) {\n                    setTimeout(function() {\n                        if (that.get(eventName)) {\n                            subscriber.handler.call(subscriber.context, data);\n                        }\n                    }, 0);\n                });\n            };\n\n            Subscriber.prototype.triggerSync = function(eventName, data) {\n                this.get(eventName).forEach(function(subscriber) {\n                    subscriber.handler.call(subscriber.context, data);\n                });\n            };\n\n            Subscriber.prototype.get = function get(eventName) {\n                if (!this._subscribers[eventName]) {\n                    this._subscribers[eventName] = [];\n                }\n                return this._subscribers[eventName];\n            };\n\n            module.exports = Subscriber;\n\n\n        }, {}],\n        5: [function(require, module, exports) {\n            'use strict';\n\n            /**\n             * noop a empty function\n             */\n            function noop() {}\n\n            /**\n             * validate if is not validate will return an Error with the message\n             *\n             * @param {boolean} isValid\n             * @param {string} message\n             */\n            function validate(isValid, message) {\n                return isValid ? null : new Error(message);\n            }\n\n            var timeouts = {};\n            /**\n             * clearCallbackTimeout\n             *\n             * @param {function} func handler to remove\n             */\n            function clearCallbackTimeout(func) {\n                var timeout = timeouts[func];\n                if (timeout) {\n                    clearTimeout(timeout);\n                    delete timeouts[func];\n                }\n            }\n\n            /**\n             * callbackTimeout if the onSuccess is not called and returns true in the timelimit then onTimeout will be called\n             *\n             * @param {number} timer\n             * @param {function} onSuccess\n             * @param {function} onTimeout\n             */\n            function callbackTimeout(timer, onSuccess, onTimeout) {\n                var callback, timeout;\n\n                timeout = setTimeout(function() {\n                    onSuccess = noop;\n                    if (!timeouts[callback]) {\n                        // Timeout has already been resolved.\n                        return;\n                    }\n                    delete timeout[callback];\n                    onTimeout();\n                }, timer);\n\n                callback = function() {\n                    // TODO avoid leaking arguments\n                    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n                    if (onSuccess.apply(this, arguments)) {\n                        clearCallbackTimeout(callback);\n                    }\n                };\n\n                timeouts[callback] = timeout;\n\n                return callback;\n            }\n\n\n            /**\n             * createElementInEl\n             *\n             * @param {HTMLElement} parent\n             * @param {string} tagName\n             * @param {string} id\n             */\n            function createElementInEl(parent, tagName, id) {\n                var nEl = document.createElement(tagName);\n                if (id) nEl.id = id;\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            /**\n             * createIframeWithContent\n             *\n             * @param {HTMLElement} parent\n             * @param {string} template simple template using {{var}}\n             * @param {object} data\n             */\n            function createIframeWithContent(parent, template, data) {\n                var iframe = createIframe(parent);\n                if (!setIframeContent(iframe, simpleTemplate(template, data))) return;\n                return iframe;\n            }\n\n            /**\n             * createIframe\n             *\n             * @param {HTMLElement} parent\n             * @param {string} url\n             */\n            function createIframe(parent, url) {\n                var nEl = document.createElement('iframe');\n                nEl.src = url || 'about:blank';\n                nEl.width = '100%';\n                nEl.height = '100%';\n                nEl.style.position = 'absolute';\n                nEl.style.left = '0';\n                nEl.style.top = '0';\n                nEl.style.border = '0';\n                parent.innerHTML = '';\n                parent.appendChild(nEl);\n                return nEl;\n            }\n\n            /**\n             * simpleTemplate\n             *\n             * @param {string} template\n             * @param {object} data\n             */\n            function simpleTemplate(template, data) {\n                Object.keys(data).forEach(function(key) {\n                    var value = (typeof value === 'object') ? JSON.stringify(data[key]) : data[key];\n                    template = template.replace(new RegExp('{{' + key + '}}', 'g'), value);\n                });\n                return template;\n            }\n\n            /**\n             * setIframeContent\n             *\n             * @param {HTMLIframeElement} iframeEl\n             * @param content\n             */\n            function setIframeContent(iframeEl, content) {\n                var iframeDoc = iframeEl.contentWindow && iframeEl.contentWindow.document;\n                if (!iframeDoc) return false;\n\n                iframeDoc.write(content);\n\n                return true;\n            }\n\n\n            /**\n             * extend object with keys from another object\n             *\n             * @param {object} toExtend\n             * @param {object} fromSource\n             */\n            function extend(toExtend, fromSource) {\n                Object.keys(fromSource).forEach(function(key) {\n                    toExtend[key] = fromSource[key];\n                });\n                return toExtend;\n            }\n\n\n            /**\n             * unique will create a unique string everytime is called, sequentially and prefixed\n             *\n             * @param {string} prefix\n             */\n            function unique(prefix) {\n                var count = -1;\n                return function() {\n                    return prefix + '_' + (++count);\n                };\n            }\n\n            module.exports = {\n                noop: noop,\n                validate: validate,\n                clearCallbackTimeout: clearCallbackTimeout,\n                callbackTimeout: callbackTimeout,\n                createElementInEl: createElementInEl,\n                createIframeWithContent: createIframeWithContent,\n                createIframe: createIframe,\n                simpleTemplate: simpleTemplate,\n                setIframeContent: setIframeContent,\n                extend: extend,\n                unique: unique\n            };\n\n\n        }, {}]\n    }, {}, [3])\n\n\n    //# sourceMappingURL=VPAIDHTML5Client.js.map\n    ;\n    //Small subset of async\n    var async = {};\n\n    async.setImmediate = function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    async.iterator = function(tasks) {\n        var makeCallback = function(index) {\n            var fn = function() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function() {\n                return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n\n    async.waterfall = function(tasks, callback) {\n        callback = callback || function() {};\n        if (!isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function(iterator) {\n            return function(err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function() {};\n                } else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    } else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function() {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    async.when = function(condition, callback) {\n        if (!isFunction(callback)) {\n            throw new Error(\"async.when error: missing callback argument\");\n        }\n\n        var isAllowed = isFunction(condition) ? condition : function() {\n            return !!condition;\n        };\n\n        return function() {\n            var args = arrayLikeObjToArray(arguments);\n            var next = args.pop();\n\n            if (isAllowed.apply(null, args)) {\n                return callback.apply(this, arguments);\n            }\n\n            args.unshift(null);\n            return next.apply(null, args);\n        };\n    };\n\n\n\n    ;\n    \"use strict\";\n\n    var dom = {};\n\n    dom.isVisible = function isVisible(el) {\n        var style = window.getComputedStyle(el);\n        return style.visibility !== 'hidden';\n    };\n\n    dom.isHidden = function isHidden(el) {\n        var style = window.getComputedStyle(el);\n        return style.display === 'none';\n    };\n\n    dom.isShown = function isShown(el) {\n        return !dom.isHidden(el);\n    };\n\n    dom.hide = function hide(el) {\n        el.__prev_style_display_ = el.style.display;\n        el.style.display = 'none';\n    };\n\n    dom.show = function show(el) {\n        if (dom.isHidden(el)) {\n            el.style.display = el.__prev_style_display_;\n        }\n        el.__prev_style_display_ = undefined;\n    };\n\n    dom.hasClass = function hasClass(el, cssClass) {\n        var classes, i, len;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.contains(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            cssClass = (cssClass || '');\n\n            for (i = 0, len = classes.length; i < len; i += 1) {\n                if (classes[i] === cssClass) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    dom.addClass = function(el, cssClass) {\n        var classes;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.add(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            if (isString(cssClass) && isNotEmptyString(cssClass.replace(/\\s+/, ''))) {\n                classes.push(cssClass);\n                el.setAttribute('class', classes.join(' '));\n            }\n        }\n    };\n\n    dom.removeClass = function(el, cssClass) {\n        var classes;\n\n        if (isNotEmptyString(cssClass)) {\n            if (el.classList) {\n                return el.classList.remove(cssClass);\n            }\n\n            classes = isString(el.getAttribute('class')) ? el.getAttribute('class').split(/\\s+/) : [];\n            var newClasses = [];\n            var i, len;\n            if (isString(cssClass) && isNotEmptyString(cssClass.replace(/\\s+/, ''))) {\n\n                for (i = 0, len = classes.length; i < len; i += 1) {\n                    if (cssClass !== classes[i]) {\n                        newClasses.push(classes[i]);\n                    }\n                }\n                el.setAttribute('class', newClasses.join(' '));\n            }\n        }\n    };\n\n    dom.addEventListener = function addEventListener(el, type, handler) {\n        if (isArray(el)) {\n            forEach(el, function(e) {\n                dom.addEventListener(e, type, handler);\n            });\n            return;\n        }\n\n        if (isArray(type)) {\n            forEach(type, function(t) {\n                dom.addEventListener(el, t, handler);\n            });\n            return;\n        }\n\n        if (el.addEventListener) {\n            el.addEventListener(type, handler, false);\n        } else if (el.attachEvent) {\n            // WARNING!!! this is a very naive implementation !\n            // the event object that should be passed to the handler\n            // would not be there for IE8\n            // we should use \"window.event\" and then \"event.srcElement\"\n            // instead of \"event.target\"\n            el.attachEvent(\"on\" + type, handler);\n        }\n    };\n\n    dom.removeEventListener = function removeEventListener(el, type, handler) {\n        if (isArray(el)) {\n            forEach(el, function(e) {\n                dom.removeEventListener(e, type, handler);\n            });\n            return;\n        }\n\n        if (isArray(type)) {\n            forEach(type, function(t) {\n                dom.removeEventListener(el, t, handler);\n            });\n            return;\n        }\n\n        if (el.removeEventListener) {\n            el.removeEventListener(type, handler, false);\n        } else if (el.detachEvent) {\n            el.detachEvent(\"on\" + type, handler);\n        } else {\n            el[\"on\" + type] = null;\n        }\n    };\n\n    dom.dispatchEvent = function dispatchEvent(el, event) {\n        if (el.dispatchEvent) {\n            el.dispatchEvent(event);\n        } else {\n            el.fireEvent(\"on\" + event.eventType, event);\n        }\n    };\n\n    dom.isDescendant = function isDescendant(parent, child) {\n        var node = child.parentNode;\n        while (node !== null) {\n            if (node === parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    };\n\n    dom.getTextContent = function getTextContent(el) {\n        return el.textContent || el.text;\n    };\n\n    dom.prependChild = function prependChild(parent, child) {\n        if (child.parentNode) {\n            child.parentNode.removeChild(child);\n        }\n        return parent.insertBefore(child, parent.firstChild);\n    };\n\n    dom.remove = function removeNode(node) {\n        if (node && node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    };\n\n    dom.isDomElement = function isDomElement(o) {\n        return o instanceof Element;\n    };\n\n    dom.click = function(el, handler) {\n        dom.addEventListener(el, 'click', handler);\n    };\n\n    dom.once = function(el, type, handler) {\n        function handlerWrap() {\n            handler.apply(null, arguments);\n            dom.removeEventListener(el, type, handlerWrap);\n        }\n\n        dom.addEventListener(el, type, handlerWrap);\n    };\n\n    //Note: there is no getBoundingClientRect on iPad so we need a fallback\n    dom.getDimension = function getDimension(element) {\n        var rect;\n        var parentNode = element.parentNode;\n        if (parentNode) {\n            return {\n                width: parentNode.clientWidth,\n                height: parentNode.clientHeight\n            }\n        }\n        return {\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    };\n\n    \"use strict\";\n\n    var logger = {};\n\n    ;\n    \"use strict\";\n\n    //minthe2 profile\n    var profile = {};\n\n    profile.timeout = 0;\n    profile.initAdTimestamp = 0;\n    profile.adLoadedTimestamp = 0;\n\n    profile.startAdTimestamp = 0;\n    profile.adStartedTimestamp = 0;\n\n    profile.adImpressionTimestamp = 0;\n\n    profile.getState = function() {\n        if (profile.adImpressionTimestamp) {\n            return 'adImpression';\n        }\n        if (profile.startAdTimestamp) {\n            return 'startAd';\n        }\n        if (profile.initAdTimestamp) {\n            return 'initAd';\n        }\n        return 'pluginInit';\n    };\n\n    profile.getRemainingTime = function(type) {\n        var offset = 0;\n        var currTime = new Date().getTime();\n        switch (type) {\n            case 'initAd':\n                offset = currTime - profile.initAdTimestamp;\n                break;\n            case 'AdLoaded':\n                offset = profile.getInitTime();\n                break;\n            case 'startAd':\n                offset = profile.getInitTime();\n                break;\n            case 'AdStarted':\n                offset = profile.getInitTime() + profile.getStartTime();\n                break;\n            case 'AdImpression':\n                offset = profile.getTotalTime();\n                break;\n            default:\n                break;\n        }\n        var remainingTime = profile.timeout - offset;\n        return remainingTime;\n    };\n\n    profile.getInitTime = function() {\n        var interval = profile.adLoadedTimestamp - profile.initAdTimestamp;\n        return interval;\n    };\n\n    profile.getStartTime = function() {\n        var interval = profile.adStartedTimestamp - profile.startAdTimestamp;\n        return interval;\n    };\n\n    profile.getAdImpressionTime = function() {\n        var interval = profile.adImpressionTimestamp - profile.startAdTimestamp;\n        return interval;\n    };\n\n    profile.getTotalTime = function() {\n\n        var interval = profile.getInitTime();\n\n        if (profile.adStartedTimestamp > profile.adImpressionTimestamp) {\n            interval = interval + profile.getStartTime();\n        } else {\n            interval = interval + profile.getAdImpressionTime();\n        }\n\n        // if (profile.adImpressionTimestamp) {\n        //     interval = interval + profile.getAdImpressionTime();\n        // }\n        return interval;\n    };\n\n    ;\n    \"use strict\";\n\n    //minthe2 timer\n    var timer = {};\n\n    timer.killUnresponsiveCreative = false;\n    timer.responseWaitingTime = 1000;\n    timer.killTimeout = null;\n    timer.adCancelTimeout = 5000;\n    timer.adLoadTimeout = null;\n    timer.adStartTimeout = null;\n    // timer.adImpressionTimeout = null;\n    timer.adStartedResponseTime = 0;\n    timer.adImpressionResponseTime = 0;\n\n\n    timer.startKillTimeout = function(adUnit) {\n        if (timer.killUnresponsiveCreative) {\n            // if already timeout is set . cleanup\n            if (timer.killTimeout) {\n                timer.stopKillTimeout();\n            }\n            timer.killTimeout = setTimeout(function() {\n                if (timer.killTimeout) {\n                    logger.log('killUnresponsiveCreative Timeout reached ');\n                    adUnit.stopAd();\n                }\n            }, timer.responseWaitingTime);\n        }\n    };\n\n    timer.stopKillTimeout = function() {\n        if (!timer.killTimeout) {\n            return;\n        }\n        timer.clearTimeout(timer.killTimeout);\n        timer.killTimeout = null;\n    };\n\n    timer.handleAdTimeout = function(cb, state) {\n        logger.error('VPAID AD TIMED OUT :: AFTER ' + state + ' ,timeout value : ' + timer.adCancelTimeout);\n        if (cb) {\n            cb(new VASTError('timeout while waiting for the video to start playing', 402));\n        }\n    };\n\n    timer.clearTimeout = function(timeout) {\n        if (timeout) {\n            clearTimeout(timeout);\n            timeout = null;\n        }\n    };\n\n    timer.startInitAdTimeout = function(cb) {\n        profile.timeout = timer.adCancelTimeout;\n        profile.initAdTimestamp = new Date().getTime();\n        timer.adLoadTimeout = setTimeout(function() {\n            timer.handleAdTimeout(cb, \"initAd\");\n        }, timer.adCancelTimeout);\n    };\n\n    timer.stopInitAdTimeout = function() {\n        profile.adLoadedTimestamp = new Date().getTime();\n        timer.adStartedResponseTime = timer.adCancelTimeout - profile.getInitTime();\n        timer.clearTimeout(timer.adLoadTimeout);\n\n    };\n\n    timer.startStartAdTimeout = function(cb) {\n        profile.startAdTimestamp = new Date().getTime();\n        var timeoutFunction;\n\n        timeoutFunction = function() {\n            if (profile.adStartedTimestamp > 0) {\n                timer.handleAdTimeout(cb, \"AdStarted\");\n            } else {\n                timer.handleAdTimeout(cb, \"startAd\");\n            }\n        }\n\n        timer.adStartTimeout = setTimeout(timeoutFunction, timer.adStartedResponseTime);\n    };\n\n    timer.stopStartAdTimeout = function() {\n        timer.clearTimeout(timer.adStartTimeout);\n        logger.debug(\"stopStartAdTimeout\");\n    };\n\n    // timer.startAdImpressionTimeout =  function(cb) {\n    //     profile.adImpressionTimestamp = new Date().getTime();\n    //     timer.adImpressionTimeout = setTimeout(function(){\n    //         timer.handleAdTimeout(cb,\"AdStarted\");\n    //     }, timer.adImpressionResponseTime);\n    // };\n\n    // timer.stopAdImpressionTimeout =  function() {\n    //     profile.adImpressionTimestamp = new Date().getTime();\n    //     timer.clearTimeout(timer.adImpressionTimeout);\n    // };\n\n    timer.stopAdTimeouts = function() {\n        logger.debug(\"stopAdTimeouts\");\n        timer.clearTimeout(timer.adLoadTimeout);\n        timer.clearTimeout(timer.adStartTimeout);\n        // timer.clearTimeout(timer.adImpressionTimeout);\n    };\n\n    ;\n    \"use strict\";\n\n    function HttpRequestError(message) {\n        this.message = 'HttpRequest Error: ' + (message || '');\n    }\n    HttpRequestError.prototype = new Error();\n    HttpRequestError.prototype.name = \"HttpRequest Error\";\n\n    function HttpRequest(createXhr) {\n        if (!isFunction(createXhr)) {\n            throw new HttpRequestError('Missing XMLHttpRequest factory method');\n        }\n\n        this.createXhr = createXhr;\n    }\n\n    HttpRequest.prototype.run = function(method, url, callback, options) {\n        sanityCheck(url, callback, options);\n        var timeout, timeoutId;\n        var xhr = this.createXhr();\n        options = options || {};\n        timeout = isNumber(options.timeout) ? options.timeout : 0;\n\n        xhr.open(method, urlParts(url).href, true);\n\n        if (options.headers) {\n            setHeaders(xhr, options.headers);\n        }\n\n        if (options.withCredentials) {\n            xhr.withCredentials = true;\n        }\n\n        xhr.onload = function() {\n            var statusText, response, status;\n\n            /**\n             * The only way to do a secure request on IE8 and IE9 is with the XDomainRequest object. Unfortunately, microsoft is\n             * so nice that decided that the status property and the 'getAllResponseHeaders' method where not needed so we have to\n             * fake them. If the request gets done with an XDomainRequest instance, we will assume that there are no headers and\n             * the status will always be 200. If you don't like it, DO NOT USE ANCIENT BROWSERS!!!\n             *\n             * For mor info go to: https://msdn.microsoft.com/en-us/library/cc288060(v=vs.85).aspx\n             */\n            if (!xhr.getAllResponseHeaders) {\n                xhr.getAllResponseHeaders = function() {\n                    return null;\n                };\n            }\n\n            if (!xhr.status) {\n                xhr.status = 200;\n            }\n\n            if (isDefined(timeoutId)) {\n                clearTimeout(timeoutId);\n                timeoutId = undefined;\n            }\n\n            statusText = xhr.statusText || '';\n\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)\n            response = ('response' in xhr) ? xhr.response : xhr.responseText;\n\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            status = xhr.status === 1223 ? 204 : xhr.status;\n\n            callback(\n                status,\n                response,\n                xhr.getAllResponseHeaders(),\n                statusText);\n        };\n\n        xhr.onerror = requestError;\n        xhr.onabort = requestError;\n\n        xhr.send();\n\n        if (timeout > 0) {\n            timeoutId = setTimeout(function() {\n                xhr && xhr.abort();\n            }, timeout);\n        }\n\n        function sanityCheck(url, callback, options) {\n            if (!isString(url) || isEmptyString(url)) {\n                throw new HttpRequestError(\"Invalid url '\" + url + \"'\");\n            }\n\n            if (!isFunction(callback)) {\n                throw new HttpRequestError(\"Invalid handler '\" + callback + \"' for the http request\");\n            }\n\n            if (isDefined(options) && !isObject(options)) {\n                throw new HttpRequestError(\"Invalid options map '\" + options + \"'\");\n            }\n        }\n\n        function setHeaders(xhr, headers) {\n            forEach(headers, function(value, key) {\n                if (isDefined(value)) {\n                    xhr.setRequestHeader(key, value);\n                }\n            });\n        }\n\n        function requestError() {\n            callback(-1, null, null, '');\n        }\n    };\n\n    HttpRequest.prototype.get = function(url, callback, options) {\n        this.run('GET', url, processResponse, options);\n\n        function processResponse(status, response, headersString, statusText) {\n            if (isSuccess(status)) {\n                callback(null, response, status, headersString, statusText);\n            } else {\n                callback(new HttpRequestError(statusText), response, status, headersString, statusText);\n            }\n        }\n\n        function isSuccess(status) {\n            return 200 <= status && status < 300;\n        }\n    };\n\n    function createXhr() {\n        var xhr = new XMLHttpRequest();\n        if (!(\"withCredentials\" in xhr)) {\n            // XDomainRequest for IE.\n            xhr = new XDomainRequest();\n        }\n        return xhr;\n    }\n\n    var http = new HttpRequest(createXhr);\n\n    ;\n    var playerUtils = {};\n\n    /**\n     * Returns an object that captures the portions of player state relevant to\n     * video playback. The result of this function can be passed to\n     * restorePlayerSnapshot with a player to return the player to the state it\n     * was in when this function was invoked.\n     * @param {object} player The videojs player object\n     */\n    playerUtils.getPlayerSnapshot = function getPlayerSnapshot(player) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var snapshot = {\n            ended: player.ended(),\n            src: player.currentSrc(),\n            currentTime: player.currentTime(),\n            type: player.currentType(),\n            playing: !player.paused(),\n            suppressedTracks: getSuppressedTracks(player)\n        };\n\n        if (tech) {\n            snapshot.nativePoster = tech.poster;\n            snapshot.style = tech.getAttribute('style');\n        }\n\n        return snapshot;\n\n        /**** Local Functions ****/\n        function getSuppressedTracks(player) {\n            var tracks = player.remoteTextTracks ? player.remoteTextTracks() : [];\n\n            if (tracks && isArray(tracks.tracks_)) {\n                tracks = tracks.tracks_;\n            }\n\n            if (!isArray(tracks)) {\n                tracks = [];\n            }\n\n            var suppressedTracks = [];\n            tracks.forEach(function(track) {\n                suppressedTracks.push({\n                    track: track,\n                    mode: track.mode\n                });\n                track.mode = 'disabled';\n            });\n\n            return suppressedTracks;\n        }\n    };\n\n    /**\n     * Attempts to modify the specified player so that its state is equivalent to\n     * the state of the snapshot.\n     * @param {object} snapshot - the player state to apply\n     */\n    playerUtils.restorePlayerSnapshot = function restorePlayerSnapshot(player, snapshot) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var attempts = 20; // the number of remaining attempts to restore the snapshot\n\n        if (snapshot.nativePoster) {\n            tech.poster = snapshot.nativePoster;\n        }\n\n        if ('style' in snapshot) {\n            // overwrite all css style properties to restore state precisely\n            tech.setAttribute('style', snapshot.style || '');\n        }\n\n        if (hasSrcChanged(player, snapshot)) {\n            // on ios7, fiddling with textTracks too early will cause safari to crash\n            player.one('contentloadedmetadata', restoreTracks);\n\n            player.one('canplay', tryToResume);\n            ensureCanplayEvtGetsFired();\n\n            // if the src changed for ad playback, reset it\n            player.src({ src: snapshot.src, type: snapshot.type });\n\n            // safari requires a call to `load` to pick up a changed source\n            player.load();\n\n        } else {\n            restoreTracks();\n\n            if (snapshot.playing) {\n                player.play();\n            }\n        }\n\n        /*** Local Functions ***/\n\n        /**\n         * Sometimes firefox does not trigger the 'canplay' evt.\n         * This code ensure that it always gets triggered triggered.\n         */\n        function ensureCanplayEvtGetsFired() {\n            var timeoutId = setTimeout(function() {\n                player.trigger('canplay');\n            }, 1000);\n\n            player.one('canplay', function() {\n                clearTimeout(timeoutId);\n            });\n        }\n\n        /**\n         * Determine whether the player needs to be restored to its state\n         * before ad playback began. With a custom ad display or burned-in\n         * ads, the content player state hasn't been modified and so no\n         * restoration is required\n         */\n        function hasSrcChanged(player, snapshot) {\n            if (player.src()) {\n                return player.src() !== snapshot.src;\n            }\n            // the player was configured through source element children\n            return player.currentSrc() !== snapshot.src;\n        }\n\n        function restoreTracks() {\n            var suppressedTracks = snapshot.suppressedTracks;\n            suppressedTracks.forEach(function(trackSnapshot) {\n                trackSnapshot.track.mode = trackSnapshot.mode;\n            });\n        }\n\n        /**\n         * Determine if the video element has loaded enough of the snapshot source\n         * to be ready to apply the rest of the state\n         */\n        function tryToResume() {\n            if (playerUtils.isReadyToResume(tech)) {\n                // if some period of the video is seekable, resume playback\n                return resume();\n            }\n\n            // delay a bit and then check again unless we're out of attempts\n            if (attempts--) {\n                setTimeout(tryToResume, 50);\n            } else {\n                (function() {\n                    try {\n                        resume();\n                    } catch (e) {\n                        videojs.log.warn('Failed to resume the content after an advertisement', e);\n                    }\n                })();\n            }\n\n\n            /*** Local functions ***/\n            function resume() {\n                player.currentTime(snapshot.currentTime);\n\n                if (snapshot.playing) {\n                    player.play();\n                }\n            }\n\n        }\n    };\n\n    playerUtils.isReadyToResume = function(tech) {\n        if (tech.readyState > 1) {\n            // some browsers and media aren't \"seekable\".\n            // readyState greater than 1 allows for seeking without exceptions\n            return true;\n        }\n\n        if (tech.seekable === undefined) {\n            // if the tech doesn't expose the seekable time ranges, try to\n            // resume playback immediately\n            return true;\n        }\n\n        if (tech.seekable.length > 0) {\n            // if some period of the video is seekable, resume playback\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * This function prepares the player to display ads.\n     * Adding convenience events like the 'vast.firsPlay' that gets fired when the video is first played\n     * and ads the blackPoster to the player to prevent content from being displayed before the preroll ad.\n     *\n     * @param player\n     */\n    playerUtils.prepareForAds = function(player, isOverlayPlayer) {\n\n        var blackPoster = player.addChild('blackPoster');\n        var _firstPlay = true;\n        var volumeSnapshot;\n\n        // VID-1955 Causes Interference with Waterfall playback\n        if (!isOverlayPlayer) {\n            monkeyPatchPlayerApi();\n        }\n\n        player.on('play', tryToTriggerFirstPlay);\n        player.on('vast.reset', resetFirstPlay); //Every time we change the sources we reset the first play.\n        player.on('vast.firstPlay', restoreContentVolume);\n        player.on('error', hideBlackPoster); //If there is an error in the player we remove the blackposter to show the err msg\n        player.on('vast.adStart', hideBlackPoster);\n        player.on('vast.adsCancel', hideBlackPoster);\n        player.on('vast.adError', hideBlackPoster);\n        player.on('vast.adStart', addStyles);\n        player.on('vast.adEnd', removeStyles);\n        player.on('vast.adsCancel', removeStyles);\n\n        /*** Local Functions ***/\n\n        /**\n         What this function does is ugly and horrible and I should think twice before calling myself a good developer. With that said,\n         it is the best solution I could find to mute the video until the 'play' event happens (on mobile devices) and the plugin can decide whether\n         to play the ad or not.\n\n         We also need this monkeypatch to be able to pause and resume an ad using the player's API\n\n         If you have a better solution please do tell me.\n         */\n        function monkeyPatchPlayerApi() {\n\n            /**\n             * Monkey patch needed to handle firstPlay and resume of playing ad.\n             *\n             * @param prepareForAds necessary flag to prevent infinite loop when you are restoring a VAST ad.\n             * @returns {player}\n             */\n            var origPlay = player.play;\n            player.play = function(callOrigPlay) {\n\n\n\n\n                if (isFirstPlay()) {\n                    firstPlay.call(this);\n                } else {\n                    resume.call(this, callOrigPlay);\n                }\n\n                return this;\n\n                /*** local functions ***/\n                function firstPlay() {\n\n\n                    if (!isIPhone()) {\n                        volumeSnapshot = saveVolumeSnapshot();\n                        player.muted(true);\n                    }\n                    // Do not call play on the video element instead just trigger startAd and the creative will call play as it is suppose to.\n                    // VID-2515 Force the enabling of the spinner. As we do not call actual play the wait state to trigger spinner never gets activated until its too late.\n                    player.addClass('vjs-waiting');\n                    player.trigger('firstplay');\n                    player.trigger('play');\n                }\n\n                function resume(callOrigPlay) {\n                    if (isAdPlaying() && !callOrigPlay) {\n                        player.vast.adUnit.resumeAd();\n                    } else {\n                        origPlay.apply(this, arguments);\n                    }\n                }\n            };\n\n\n            /**\n             * Needed monkey patch to handle pause of playing ad.\n             *\n             * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.\n             * @returns {player}\n             */\n            var origPause = player.pause;\n            player.pause = function(callOrigPause) {\n                if (isAdPlaying() && !callOrigPause) {\n                    player.vast.adUnit.pauseAd();\n                } else {\n                    origPause.apply(this, arguments);\n                }\n                return this;\n            };\n\n\n            /**\n             * Needed monkey patch to handle paused state of the player when ads are playing.\n             *\n             * @param callOrigPlay necessary flag to prevent infinite loop when you are pausing a VAST ad.\n             * @returns {player}\n             */\n            var origPaused = player.paused;\n            player.paused = function(callOrigPaused) {\n                if (isAdPlaying() && !callOrigPaused) {\n                    return player.vast.adUnit.isPaused();\n                }\n                return origPaused.apply(this, arguments);\n            };\n        }\n\n        function isAdPlaying() {\n            return player.vast && player.vast.adUnit;\n        }\n\n        function tryToTriggerFirstPlay() {\n\n            if (isFirstPlay()) {\n                _firstPlay = false;\n                player.trigger('vast.firstPlay');\n            }\n        }\n\n        function resetFirstPlay() {\n            _firstPlay = true;\n            blackPoster.show();\n            restoreContentVolume();\n        }\n\n        function isFirstPlay() {\n            return _firstPlay;\n        }\n\n        function saveVolumeSnapshot() {\n            return {\n                muted: player.muted(),\n                volume: player.volume()\n            };\n        }\n\n        function restoreContentVolume() {\n            if (volumeSnapshot) {\n                player.currentTime(0);\n                restoreVolumeSnapshot(volumeSnapshot);\n                volumeSnapshot = null;\n            }\n        }\n\n        function restoreVolumeSnapshot(snapshot) {\n            if (isObject(snapshot)) {\n                player.volume(snapshot.volume);\n                player.muted(snapshot.muted);\n            }\n        }\n\n        function hideBlackPoster() {\n            if (!dom.hasClass(blackPoster.el(), 'vjs-hidden')) {\n                blackPoster.hide();\n            }\n        }\n\n        function addStyles() {\n            dom.addClass(player.el(), 'vjs-ad-playing');\n        }\n\n        function removeStyles() {\n            dom.removeClass(player.el(), 'vjs-ad-playing');\n        }\n    };\n\n    /**\n     * Remove the poster attribute from the video element tech, if present. When\n     * reusing a video element for multiple videos, the poster image will briefly\n     * reappear while the new source loads. Removing the attribute ahead of time\n     * prevents the poster from showing up between videos.\n     * @param {object} player The videojs player object\n     */\n    playerUtils.removeNativePoster = function(player) {\n        var tech = player.el().querySelector('.vjs-tech');\n        if (tech) {\n            tech.removeAttribute('poster');\n        }\n    };\n\n    /**\n     * Helper function to listen to many events until one of them gets fired, then we\n     * execute the handler and unsubscribe all the event listeners;\n     *\n     * @param player specific player from where to listen for the events\n     * @param events array of events\n     * @param handler function to execute once one of the events fires\n     */\n    playerUtils.once = function once(player, events, handler) {\n        function listener() {\n            handler.apply(null, arguments);\n\n            events.forEach(function(event) {\n                player.off(event, listener);\n            });\n        }\n\n        events.forEach(function(event) {\n            player.on(event, listener);\n        });\n    };\n\n    ;\n    'use strict';\n\n    /**\n     * documentMode is an IE-only property\n     * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n     */\n    var msie = document.documentMode;\n\n    /**\n     *\n     * IMPORTANT NOTE: This function comes from angularJs and was originally called urlResolve\n     *                 you can take a look at the original code here https://github.com/angular/angular.js/blob/master/src/ng/urlUtils.js\n     *\n     * Implementation Notes for non-IE browsers\n     * ----------------------------------------\n     * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,\n     * results both in the normalizing and parsing of the URL.  Normalizing means that a relative\n     * URL will be resolved into an absolute URL in the context of the application document.\n     * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related\n     * properties are all populated to reflect the normalized URL.  This approach has wide\n     * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See\n     * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *\n     * Implementation Notes for IE\n     * ---------------------------\n     * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other\n     * browsers.  However, the parsed components will not be set if the URL assigned did not specify\n     * them.  (e.g. if you assign a.href = \"foo\", then a.protocol, a.host, etc. will be empty.)  We\n     * work around that by performing the parsing in a 2nd step by taking a previously normalized\n     * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the\n     * properties such as protocol, hostname, port, etc.\n     *\n     * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one\n     * uses the inner HTML approach to assign the URL as part of an HTML snippet -\n     * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.\n     * Unfortunately, setting img[src] to something like \"javascript:foo\" on IE throws an exception.\n     * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that\n     * method and IE < 8 is unsupported.\n     *\n     * References:\n     *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement\n     *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *   http://url.spec.whatwg.org/#urlutils\n     *   https://github.com/angular/angular.js/pull/2902\n     *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/\n     *\n     * @kind function\n     * @param {string} url The URL to be parsed.\n     * @description Normalizes and parses a URL.\n     * @returns {object} Returns the normalized URL as a dictionary.\n     *\n     *   | member name   | Description    |\n     *   |---------------|----------------|\n     *   | href          | A normalized version of the provided URL if it was not an absolute URL |\n     *   | protocol      | The protocol including the trailing colon                              |\n     *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |\n     *   | search        | The search params, minus the question mark                             |\n     *   | hash          | The hash string, minus the hash symbol\n     *   | hostname      | The hostname\n     *   | port          | The port, without \":\"\n     *   | pathname      | The pathname, beginning with \"/\"\n     *\n     */\n\n    var urlParsingNode = document.createElement(\"a\");\n\n    function urlParts(url) {\n        var href = url;\n\n        if (msie) {\n            // Normalize before parse.  Refer Implementation Notes on why this is\n            // done in two steps on IE.\n            urlParsingNode.setAttribute(\"href\", href);\n            href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n            href: urlParsingNode.href,\n            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n            host: urlParsingNode.host,\n            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n            hostname: urlParsingNode.hostname,\n            port: isNotEmptyString(urlParsingNode.port) ? urlParsingNode.port : 80,\n            pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n        };\n    }\n\n\n    /**\n     * This function accepts a query string (search part of a url) and returns a dictionary with\n     * the different key value pairs\n     * @param {string} qs queryString\n     */\n    function queryStringToObj(qs, cond) {\n        var pairs, qsObj;\n\n        cond = isFunction(cond) ? cond : function() {\n            return true;\n        };\n\n        qs = qs.trim().replace(/^\\?/, '');\n        pairs = qs.split('&');\n        qsObj = {};\n\n        forEach(pairs, function(pair) {\n            var keyValue, key, value;\n            if (pair !== '') {\n                keyValue = pair.split('=');\n                key = keyValue[0];\n                value = keyValue[1];\n                if (cond(key, value)) {\n                    qsObj[key] = value;\n                }\n            }\n        });\n\n        return qsObj;\n    }\n\n    /**\n     * This function accepts an object and serializes it into a query string without the leading '?'\n     * @param obj\n     * @returns {string}\n     */\n    function objToQueryString(obj) {\n        var pairs = [];\n        forEach(obj, function(value, key) {\n            pairs.push(key + '=' + value);\n        });\n        return pairs.join('&');\n    }\n\n\n    ;\n    var xml = {};\n\n    xml.strToXMLDoc = function strToXMLDoc(stringContainingXMLSource) {\n        //IE 8\n        if (typeof window.DOMParser === 'undefined') {\n            var xmlDocument = new ActiveXObject('Microsoft.XMLDOM');\n            xmlDocument.async = false;\n            xmlDocument.loadXML(stringContainingXMLSource);\n            return xmlDocument;\n        }\n\n        return parseString(stringContainingXMLSource);\n\n        function parseString(stringContainingXMLSource) {\n            var parser = new DOMParser();\n            var parsedDocument;\n\n            //Note: This try catch is to deal with the fact that on IE parser.parseFromString does throw an error but the rest of the browsers don't.\n            try {\n                parsedDocument = parser.parseFromString(stringContainingXMLSource, \"application/xml\");\n\n                if (isParseError(parsedDocument) || isEmptyString(stringContainingXMLSource)) {\n                    throw new Error();\n                }\n            } catch (e) {\n                throw new Error(\"xml.strToXMLDOC: Error parsing the string: '\" + stringContainingXMLSource + \"'\");\n            }\n\n            return parsedDocument;\n        }\n\n        function isParseError(parsedDocument) {\n            try { // parser and parsererrorNS could be cached on startup for efficiency\n                var parser = new DOMParser(),\n                    errorneousParse = parser.parseFromString('INVALID', 'text/xml'),\n                    parsererrorNS = errorneousParse.getElementsByTagName(\"parsererror\")[0].namespaceURI;\n\n                if (parsererrorNS === 'http://www.w3.org/1999/xhtml') {\n                    // In PhantomJS the parseerror element doesn't seem to have a special namespace, so we are just guessing here :(\n                    return parsedDocument.getElementsByTagName(\"parsererror\").length > 0;\n                }\n\n                return parsedDocument.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0;\n            } catch (e) {\n                //Note on IE parseString throws an error by itself and it will never reach this code. Because it will have failed before\n            }\n        }\n    };\n\n    xml.parseText = function parseText(sValue) {\n        if (/^\\s*$/.test(sValue)) {\n            return null; }\n        if (/^(?:true|false)$/i.test(sValue)) {\n            return sValue.toLowerCase() === \"true\"; }\n        if (isFinite(sValue)) {\n            return parseFloat(sValue); }\n        if (isISO8601(sValue)) {\n            return new Date(sValue); }\n        return sValue.trim();\n    };\n\n    xml.JXONTree = function JXONTree(oXMLParent) {\n        var parseText = xml.parseText;\n\n        //The document object is an especial object that it may miss some functions or attrs depending on the browser.\n        //To prevent this problem with create the JXONTree using the root childNode which is a fully fleshed node on all supported\n        //browsers.\n        if (oXMLParent.documentElement) {\n            return new xml.JXONTree(oXMLParent.documentElement);\n        }\n\n        if (oXMLParent.hasChildNodes()) {\n            var sCollectedTxt = \"\";\n            for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n                oNode = oXMLParent.childNodes.item(nItem);\n                /*jshint bitwise: false*/\n                if ((oNode.nodeType - 1 | 1) === 3) { sCollectedTxt += oNode.nodeType === 3 ? oNode.nodeValue.trim() : oNode.nodeValue; } else if (oNode.nodeType === 1 && !oNode.prefix) {\n                    sProp = decapitalize(oNode.nodeName);\n                    vContent = new xml.JXONTree(oNode);\n                    if (this.hasOwnProperty(sProp)) {\n                        if (this[sProp].constructor !== Array) { this[sProp] = [this[sProp]]; }\n                        this[sProp].push(vContent);\n                    } else { this[sProp] = vContent; }\n                }\n            }\n            if (sCollectedTxt) { this.keyValue = parseText(sCollectedTxt); }\n        }\n\n        //IE8 Stupid fix\n        var hasAttr = typeof oXMLParent.hasAttributes === 'undefined' ? oXMLParent.attributes.length > 0 : oXMLParent.hasAttributes();\n        if (hasAttr) {\n            var oAttrib;\n            for (var nAttrib = 0; nAttrib < oXMLParent.attributes.length; nAttrib++) {\n                oAttrib = oXMLParent.attributes.item(nAttrib);\n                this[\"@\" + decapitalize(oAttrib.name)] = parseText(oAttrib.value.trim());\n            }\n        }\n    };\n\n    xml.JXONTree.prototype.attr = function(attr) {\n        return this['@' + decapitalize(attr)];\n    };\n\n    xml.toJXONTree = function toJXONTree(xmlString) {\n        var xmlDoc = xml.strToXMLDoc(xmlString);\n        return new xml.JXONTree(xmlDoc);\n    };\n\n    /**\n     * Helper function to extract the keyvalue of a JXONTree obj\n     *\n     * @param xmlObj {JXONTree}\n     * return the key value or undefined;\n     */\n    xml.keyValue = function getKeyValue(xmlObj) {\n        if (xmlObj) {\n            return xmlObj.keyValue;\n        }\n        return undefined;\n    };\n\n    xml.attr = function getAttrValue(xmlObj, attr) {\n        if (xmlObj) {\n            return xmlObj['@' + decapitalize(attr)];\n        }\n        return undefined;\n    };\n\n    xml.encode = function encodeXML(str) {\n        return str.replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    };\n\n    xml.decode = function decodeXML(str) {\n        return str.replace(/&apos;/g, \"'\")\n            .replace(/&quot;/g, '\"')\n            .replace(/&gt;/g, '>')\n            .replace(/&lt;/g, '<')\n            .replace(/&amp;/g, '&');\n    };;\n\n    //minthe : initalize vastClient\n    vjs.plugin('vastClient', function VASTPlugin(options) {\n\n        var snapshot;\n        var player = this;\n        var vast = new VASTClient();\n        var adsCanceled = false;\n        var defaultOpts = {\n            // maximum amount of time in ms to wait to receive `adsready` from the ad\n            // implementation after play has been requested. Ad implementations are\n            // expected to load any dynamic libraries and make any requests to determine\n            // ad policies for a video during this time.\n            timeout: 500,\n\n            //TODO:finish this IOS FIX\n            //Whenever you play an add on IOS, the native player kicks in and we loose control of it. On very heavy pages the 'play' event\n            // May occur after the video content has already started. This is wrong if you want to play a preroll ad that needs to happen before the user\n            // starts watching the content. To prevent this usec\n            iosPrerollCancelTimeout: 2000,\n\n            // maximun amount of time for the ad to actually start playing. If this timeout gets\n            // triggered the ads will be cancelled\n            adCancelTimeout: 5000,\n\n            // Boolean flag that configures the player to play a new ad before the user sees the video again\n            // the current video\n            playAdAlways: false,\n\n            // Flag to enable or disable the ads by default.\n            adsEnabled: true,\n\n            // Boolean flag to enable or disable the resize with window.resize or orientationchange\n            autoResize: true,\n\n            // Path to the VPAID flash ad's loader\n            vpaidFlashLoaderPath: '/VPAIDFlash.swf',\n\n            //Boolean flag to enable/disable Controls on mouse over/out.\n            disableControlsOnMouseover: false,\n\n            initialAudio: 'off',\n\n            overlayPlayer: false,\n\n            controlBarPosition: \"below\"\n        };\n\n        var settings = extend({}, defaultOpts, options || {});\n\n        if (isUndefined(settings.adTagUrl) && isDefined(settings.url)) {\n            settings.adTagUrl = settings.url;\n        }\n\n        if (isString(settings.adTagUrl)) {\n            settings.adTagUrl = echoFn(settings.adTagUrl);\n        }\n\n        if (isDefined(settings.adTagXML) && !isFunction(settings.adTagXML)) {\n            return trackAdError(new VASTError('on VideoJS VAST plugin, the passed adTagXML option does not contain a function'));\n        }\n\n        if (!isDefined(settings.adTagUrl) && !isFunction(settings.adTagXML)) {\n            return trackAdError(new VASTError('on VideoJS VAST plugin, missing adTagUrl on options object'));\n        }\n        playerUtils.prepareForAds(player, settings.overlayPlayer);\n        if (settings.playAdAlways) {\n            // No matter what happens we play a new ad before the user sees the video again.\n            player.on('vast.contentEnd', function() {\n                setTimeout(function() {\n                    player.trigger('vast.reset');\n                }, 0);\n            });\n        }\n\n        player.on('vast.firstPlay', tryToPlayPrerollAd);\n\n        player.on('vast.reset', function() {\n            //If we are reseting the plugin, we don't want to restore the content\n            snapshot = null;\n            cancelAds();\n        });\n\n        player.vast = {\n            isEnabled: function() {\n                return settings.adsEnabled;\n            },\n\n            enable: function() {\n                settings.adsEnabled = true;\n            },\n\n            disable: function() {\n                settings.adsEnabled = false;\n            }\n        };\n\n        if (settings.loggerCallback) {\n            logger = settings.loggerCallback;\n        } else {\n            logger = console;\n        }\n        if (settings.terminateUnresponsiveVPAIDCreative) {\n            timer.killUnresponsiveCreative = true;\n        }\n        if (settings.adCancelTimeout) {\n            timer.adCancelTimeout = settings.adCancelTimeout;\n        }\n\n        var vastResponse = getAnVastXml();\n        var adIntegrator = isVPAID(vastResponse) ? new VPAIDIntegrator(player, settings) : new VASTIntegrator(player);\n\n        if (settings.delayExpandUntilVPAIDInit) {\n            checkAd(); //minthe : invoke init method of vpaid creative here in order to check valid ad, at the end of this checkAd process it will dispatch custom event which is called \"an.readytogovpaid\"\n        }\n\n        return player.vast;\n\n\n\n        /**** Local functions ****/\n        function tryToPlayPrerollAd() {\n            //We remove the poster to prevent flickering whenever the content starts playing\n            playerUtils.removeNativePoster(player);\n\n            playerUtils.once(player, ['vast.adsCancel', 'vast.adEnd'], function() {\n                removeAdUnit();\n                restoreVideoContent();\n            });\n\n            async.waterfall([\n                checkAdsEnabled,\n                preparePlayerForAd,\n                playPrerollAd\n            ], function(error, response) {\n                if (error) {\n                    trackAdError(error, response);\n                } else {\n                    player.trigger('vast.adEnd');\n                }\n            });\n\n            /*** Local functions ***/\n\n            function removeAdUnit() {\n                if (player.vast && player.vast.adUnit) {\n                    player.vast.adUnit = null; //We remove the adUnit\n                }\n            }\n\n            function restoreVideoContent() {\n                setupContentEvents();\n                if (snapshot) {\n                    playerUtils.restorePlayerSnapshot(player, snapshot);\n                    snapshot = null;\n                }\n            }\n\n            function setupContentEvents() {\n                playerUtils.once(player, ['playing', 'vast.reset', 'vast.firstPlay'], function(evt) {\n                    if (evt.type !== 'playing') {\n                        return;\n                    }\n\n                    player.trigger('vast.contentStart');\n\n                    playerUtils.once(player, ['ended', 'vast.reset', 'vast.firstPlay'], function(evt) {\n                        if (evt.type === 'ended') {\n                            player.trigger('vast.contentEnd');\n                        }\n                    });\n                });\n            }\n\n            function checkAdsEnabled(next) {\n                if (settings.adsEnabled) {\n                    return next(null);\n                }\n                next(new VASTError('Ads are not enabled'));\n            }\n\n            function preparePlayerForAd(next) {\n                if (canPlayPrerollAd()) {\n                    snapshot = playerUtils.getPlayerSnapshot(player);\n                    addSpinnerIcon();\n                    next(null);\n                } else {\n                    next(new VASTError('video content has been playing before preroll ad'));\n                }\n            }\n\n            function canPlayPrerollAd() {\n                return !isIPhone() || player.currentTime() <= settings.iosPrerollCancelTimeout;\n            }\n\n            function addSpinnerIcon() {\n                dom.addClass(player.el(), 'vjs-vast-ad-loading');\n                playerUtils.once(player, ['vast.adStart', 'vast.adsCancel'], removeSpinnerIcon);\n            }\n\n            function removeSpinnerIcon() {\n                //IMPORTANT NOTE: We remove the spinnerIcon asynchronously to give time to the browser to start the video.\n                // If we remove it synchronously we see a flash of the content video before the ad starts playing.\n                setTimeout(function() {\n                    dom.removeClass(player.el(), 'vjs-vast-ad-loading');\n                }, 100);\n            }\n\n        }\n\n        function cancelAds() {\n            player.trigger('vast.adsCancel');\n            adsCanceled = true;\n        }\n\n        function playPrerollAd(callback) {\n            async.waterfall([\n                //getVastResponse,//minthe : comment out, we're not using mail online's vast parser and loader\n                playAd\n            ], callback);\n        }\n\n        function getVastResponse(callback) {\n            vast.getVASTResponse(settings.adTagUrl ? settings.adTagUrl() : settings.adTagXML, callback);\n        }\n\n        function getAnVastXml() { //minthe : override vast response to use jsVpaidUrl coming from videoplayer framework\n            var vastResponse = new VASTResponse();\n            vastResponse._linearAdded = true;\n            vastResponse.ads = [{\n                \"id\": 1234567,\n                \"inLine\": {\n                    \"adTitle\": \"\",\n                    \"adSystem\": \"\",\n                    \"impressions\": [],\n                    \"creatives\": [{\n                        \"sequence\": 1,\n                        \"linear\": {\n                            \"duration\": 13000,\n                            \"mediaFiles\": [{\n                                \"src\": settings.jsVpaidUrl,\n                                \"type\": \"application/javascript\",\n                                \"apiFramework\": \"VPAID\"\n                            }],\n                            \"skipoffset\": null,\n                        }\n                    }, { \"sequence\": 1 }],\n                    \"description\": \"Vpaid Linear Video Ad\",\n                    \"surveys\": []\n                }\n            }];\n            vastResponse.errorURLMacros = [];\n            vastResponse.impressions = [];\n            vastResponse.customClicks = [];\n            vastResponse.mediaFiles = [{\n                \"src\": settings.jsVpaidUrl,\n                \"type\": \"application/javascript\",\n                \"apiFramework\": \"VPAID\"\n            }];\n            vastResponse.clickThrough = settings.clickUrl;\n            vastResponse.adTitle = \"\";\n            vastResponse.adParameters = settings.adParameters;\n\n            return vastResponse;\n        }\n\n        function playAd(vastResponse, callback) {\n\n            //minthe : override vast response to use jsVpaidUrl coming from videoplayer framework\n            vastResponse = getAnVastXml();\n\n            //TODO: Find a better way to stop the play. The 'playPrerollWaterfall' ends in an inconsistent situation\n            //If the state is not 'preroll?' it means the ads were canceled therefore, we break the waterfall\n            if (adsCanceled) {\n                return;\n            }\n\n            var adFinished = false;\n\n            //comment out for VID-1359\n            //if (isIDevice()) {\n            //preventManualProgress();\n            //}\n            callback = callback || trackAdError;\n            player.vast.adUnit = adIntegrator.playAd(vastResponse, callback);\n\n            //comment out for VID-1359\n            //function preventManualProgress() {\n            //    //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that the user forwarded/rewound the ad\n            //    var PROGRESS_THRESHOLD = 3;\n            //    var previousTime = 0;\n            //    var tech = player.el().querySelector('.vjs-tech');\n            //    var skipad_attempts = 0;\n            //\n            //    player.on('timeupdate', adTimeupdateHandler);\n            //    playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adError'], stopPreventManualProgress);\n            //\n            //    /*** Local functions ***/\n            //    function adTimeupdateHandler() {\n            //        var currentTime = player.currentTime();\n            //        var progressDelta = Math.abs(currentTime - previousTime);\n            //\n            //        if (progressDelta > PROGRESS_THRESHOLD) {\n            //            skipad_attempts += 1;\n            //            if (skipad_attempts >= 2) {\n            //                player.pause();\n            //            }\n            //            player.currentTime(previousTime);\n            //        } else {\n            //            previousTime = currentTime;\n            //        }\n            //    }\n            //\n            //    function stopPreventManualProgress() {\n            //        player.off('timeupdate', adTimeupdateHandler);\n            //    }\n            //}\n        }\n\n        //minthe : checkAd to check vpaid ad is ready to go\n        function checkAd(vastResponse, callback) {\n            vastResponse = getAnVastXml();\n            callback = callback || trackAdError;\n            player.vast.adUnit = adIntegrator.playAd(vastResponse, callback, true);\n        }\n\n        function trackAdError(error, vastResponse) {\n            if (!error) return;\n            player.trigger({ type: 'vast.adError', error: error });\n            cancelAds();\n            if (console && console.log) {\n                console.log('AD ERROR:', error.message, error, vastResponse);\n            }\n        }\n\n        function isVPAID(vastResponse) {\n            var i, len;\n            var mediaFiles = vastResponse.mediaFiles;\n            for (i = 0, len = mediaFiles.length; i < len; i++) {\n                if (vastUtil.isVPAID(mediaFiles[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    });\n\n    ;\n    vjs.AdsLabel = vjs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            vjs.Component.call(this, player, options);\n\n            var that = this;\n\n            // We asynchronously reposition the ads label element\n            setTimeout(function() {\n                var currentTimeComp = player.controlBar && (player.controlBar.getChild(\"timerControls\") || player.controlBar.getChild(\"currentTimeDisplay\"));\n                if (currentTimeComp) {\n                    player.controlBar.el().insertBefore(that.el(), currentTimeComp.el());\n                }\n                dom.removeClass(that.el(), 'vjs-label-hidden');\n            }, 0);\n        }\n    });\n\n    vjs.AdsLabel.prototype.createEl = function() {\n        return vjs.Component.prototype.createEl.call(this, 'div', {\n            className: 'vjs-ads-label vjs-control vjs-label-hidden',\n            innerHTML: 'Advertisement'\n        });\n    };;\n    /**\n     * The component that shows a black screen until the ads plugin has decided if it can or it can not play the ad.\n     *\n     * Note: In case you wonder why instead of this black poster we don't just show the spinner loader.\n     *       IOS devices do not work well with animations and the browser chrashes from time to time That is why we chose to\n     *       have a secondary black poster.\n     *\n     *       It also makes it much more easier for the users of the plugin since it does not change the default behaviour of the\n     *       spinner and the player works the same way with and without the plugin.\n     *\n     * @param {vjs.Player|Object} player\n     * @param {Object=} options\n     * @constructor\n     */\n    vjs.BlackPoster = vjs.Component.extend({\n        /** @constructor */\n        init: function(player, options) {\n            vjs.Component.call(this, player, options);\n\n            var posterImg = player.getChild('posterImage');\n\n            //We need to do it asynchronously to be sure that the black poster el is on the dom.\n            setTimeout(function() {\n                if (posterImg) {\n                    player.el().insertBefore(this.el(), posterImg.el());\n                }\n            }.bind(this), 0);\n        }\n    });\n\n    /**\n     * Create the black poster div element\n     * @return {Element}\n     */\n    vjs.BlackPoster.prototype.createEl = function() {\n        return vjs.createEl('div', {\n            className: 'vjs-black-poster'\n        });\n    };;\n\n    function VPAIDAdUnitWrapper(vpaidAdUnit, opts) {\n        if (!(this instanceof VPAIDAdUnitWrapper)) {\n            return new VPAIDAdUnitWrapper(vpaidAdUnit, opts);\n        }\n        sanityCheck(vpaidAdUnit, opts);\n\n        this.options = extend({}, opts);\n\n        this._adUnit = vpaidAdUnit;\n        this._adLoaded = false;\n        this._adStopped = false;\n        this._adStarted = false;\n\n        /*** Local Functions ***/\n        function sanityCheck(adUnit, opts) {\n            if (!adUnit || !VPAIDAdUnitWrapper.checkVPAIDInterface(adUnit)) {\n                throw new VASTError('on VPAIDAdUnitWrapper, the passed VPAID adUnit does not fully implement the VPAID interface');\n            }\n\n            if (!isObject(opts)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper, expected options hash  but got '\" + opts + \"'\");\n            }\n\n            if (!(\"adCancelTimeout\" in opts) || !isNumber(opts.adCancelTimeout)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper, expected adCancelTimeout in options\");\n            }\n        }\n    }\n\n    VPAIDAdUnitWrapper.checkVPAIDInterface = function checkVPAIDInterface(VPAIDAdUnit) {\n        //NOTE: skipAd is not part of the method list because it only appears in VPAID 2.0 and we support VPAID 1.0\n        var VPAIDInterfaceMethods = [\n            'handshakeVersion', 'initAd', 'startAd', 'stopAd', 'resizeAd', 'pauseAd', 'expandAd', 'collapseAd'\n        ];\n\n        for (var i = 0, len = VPAIDInterfaceMethods.length; i < len; i++) {\n            if (!VPAIDAdUnit || !isFunction(VPAIDAdUnit[VPAIDInterfaceMethods[i]])) {\n                return false;\n            }\n        }\n\n\n        return canSubscribeToEvents(VPAIDAdUnit) && canUnsubscribeFromEvents(VPAIDAdUnit);\n\n        /*** Local Functions ***/\n\n        function canSubscribeToEvents(adUnit) {\n            return isFunction(adUnit.subscribe) || isFunction(adUnit.addEventListener) || isFunction(adUnit.on);\n        }\n\n        function canUnsubscribeFromEvents(adUnit) {\n            return isFunction(adUnit.unsubscribe) || isFunction(adUnit.removeEventListener) || isFunction(adUnit.off);\n\n        }\n    };\n\n    VPAIDAdUnitWrapper.prototype.adUnitAsyncCall = function() {\n        var args = arrayLikeObjToArray(arguments);\n        var method = args.shift();\n        var cb = args.pop();\n        var timeoutId;\n\n        sanityCheck(method, cb, this._adUnit);\n        args.push(wrapCallback());\n\n        this._adUnit[method].apply(this._adUnit, args);\n        timeoutId = setTimeout(function() {\n            timeoutId = null;\n            cb(new VASTError(\"on VPAIDAdUnitWrapper, timeout while waiting for a response on call '\" + method + \"'\"));\n            cb = noop;\n        }, this.options.adCancelTimeout);\n\n        /*** Local functions ***/\n        function sanityCheck(method, cb, adUnit) {\n            if (!isString(method) || !isFunction(adUnit[method])) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.adUnitAsyncCall, invalid method name\");\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.adUnitAsyncCall, missing callback\");\n            }\n        }\n\n        function wrapCallback() {\n            return function() {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                cb.apply(this, arguments);\n            };\n        }\n    };\n\n    VPAIDAdUnitWrapper.prototype.on = function(evtName, handler) {\n        var addEventListener = this._adUnit.addEventListener || this._adUnit.subscribe || this._adUnit.on;\n        addEventListener.call(this._adUnit, evtName, handler);\n    };\n\n    VPAIDAdUnitWrapper.prototype.off = function(evtName, handler) {\n        var removeEventListener = this._adUnit.removeEventListener || this._adUnit.unsubscribe || this._adUnit.off;\n        removeEventListener.call(this._adUnit, evtName, handler);\n    };\n\n    //minthe : waitForEvent\n    VPAIDAdUnitWrapper.prototype.waitForEvent = function(evtName, cb, context) {\n        var timeoutId;\n        sanityCheck(evtName, cb);\n        context = context || null;\n\n        this.on(evtName, responseListener);\n\n        timeoutId = setTimeout(function() {\n            cb(new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, timeout while waiting for event '\" + evtName + \"'\"));\n            timeoutId = null;\n            cb = noop;\n        }, this.options.adCancelTimeout);\n\n        /*** Local functions ***/\n        function sanityCheck(evtName, cb) {\n            if (!isString(evtName)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, missing evt name\");\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(\"on VPAIDAdUnitWrapper.waitForEvent, missing callback\");\n            }\n        }\n\n        function responseListener() {\n            var args = arrayLikeObjToArray(arguments);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n\n            args.unshift(null);\n            cb.apply(context, args);\n        }\n    };\n\n    // VPAID METHODS\n    VPAIDAdUnitWrapper.prototype.handshakeVersion = function(version, cb) {\n        this.adUnitAsyncCall('handshakeVersion', version, cb);\n    };\n\n    /* jshint maxparams:6 */\n    VPAIDAdUnitWrapper.prototype.initAd = function(width, height, viewMode, desiredBitrate, adUnitData, environmentVars, cb) {\n        //minthe : AdLoaded\n        logger.info('Calling VPAID initAd, time remaining =' + profile.getRemainingTime('initAd'));\n        this.waitForEvent('AdLoaded', cb);\n\n        //minthe VID-1580\n        this._adUnit.initAd(width, height, viewMode, desiredBitrate, adUnitData, environmentVars);\n\n    };\n\n    VPAIDAdUnitWrapper.prototype.resizeAd = function(width, height, viewMode, cb) {\n        // NOTE: AdSizeChange event is only supported on VPAID 2.0 so for the moment we are not going to use it\n        // and will assume that everything is fine after the async call\n        this.adUnitAsyncCall('resizeAd', width, height, viewMode, cb);\n    };\n\n    VPAIDAdUnitWrapper.prototype.startAd = function(cb) {\n        logger.info('Calling VPAID startAd, time remaining =' + profile.getRemainingTime('startAd'));\n        this.waitForEvent('AdStarted', cb);\n        this._adUnit.startAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.stopAd = function(cb) {\n        logger.info(' Calling VPAID stopAd');\n        this.waitForEvent('AdStopped', cb);\n        this._adUnit.stopAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.pauseAd = function(cb) {\n        if (this._adStopped || !this._adStarted) return;\n        logger.log(' Calling VPAID pauseAd');\n        this._adUnit.pauseAd();\n        timer.startKillTimeout(this._adUnit);\n    };\n\n    VPAIDAdUnitWrapper.prototype.resumeAd = function(cb) {\n        if (this._adStopped || !this._adStarted) return;\n        logger.log(' Calling VPAID resumeAd');\n        this.waitForEvent('AdPlaying', cb);\n        this._adUnit.resumeAd();\n        timer.startKillTimeout(this._adUnit);\n    };\n\n    VPAIDAdUnitWrapper.prototype.expandAd = function(cb) {\n        if (this._adStopped) return;\n        this.waitForEvent('AdExpandedChange', cb);\n        this._adUnit.expandAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.collapseAd = function(cb) {\n        if (this._adStopped) return;\n        this.waitForEvent('AdExpandedChange', cb);\n        this._adUnit.collapseAd();\n    };\n\n    VPAIDAdUnitWrapper.prototype.skipAd = function(cb) {\n        if (this._adStopped) return;\n        logger.log('Calling VPAID skipAd');\n        if (cb) {\n            this.waitForEvent('AdSkipped', cb);\n        }\n        this._adUnit.skipAd();\n    };\n\n    //VPAID property getters\n    [\n        'adLinear',\n        'adWidth',\n        'adHeight',\n        'adExpanded',\n        'adSkippableState',\n        'adRemainingTime',\n        'adDuration',\n        'adVolume',\n        'adCompanions',\n        'adIcons'\n    ].forEach(function(property) {\n        var getterName = 'get' + capitalize(property);\n\n        VPAIDAdUnitWrapper.prototype[getterName] = function(cb) {\n            this.adUnitAsyncCall(getterName, cb);\n        };\n    });\n\n    //VPAID property setters\n    VPAIDAdUnitWrapper.prototype.setAdVolume = function(volume, cb) {\n        if (this._adStopped) return;\n        logger.debug('Calling VPAID setAdVolume :: volume :' + volume);\n        this.adUnitAsyncCall('setAdVolume', volume, cb);\n    };\n\n    ;\n\n    function VPAIDFlashTech(mediaFile, settings) {\n        if (!(this instanceof VPAIDFlashTech)) {\n            return new VPAIDFlashTech(mediaFile);\n        }\n        sanityCheck(mediaFile);\n        this.name = 'vpaid-flash';\n        this.mediaFile = mediaFile;\n        this.containerEl = null;\n        this.vpaidFlashClient = null;\n        this.settings = settings;\n\n        /*** local functions ***/\n        function sanityCheck(mediaFile) {\n            if (!mediaFile || !isString(mediaFile.src)) {\n                throw new VASTError('on VPAIDFlashTech, invalid MediaFile');\n            }\n        }\n    }\n\n    VPAIDFlashTech.supports = function(type) {\n        return type === 'application/x-shockwave-flash' && VPAIDFLASHClient.isSupported();\n    };\n\n    VPAIDFlashTech.prototype.loadAdUnit = function loadFlashCreative(containerEl, objectEl, callback) {\n        var that = this;\n        var flashClientOpts = this.settings && this.settings.vpaidFlashLoaderPath ? { data: this.settings.vpaidFlashLoaderPath } : undefined;\n        sanityCheck(containerEl, callback);\n\n        this.containerEl = containerEl;\n        this.vpaidFlashClient = new VPAIDFLASHClient(containerEl, function(error) {\n            if (error) {\n                return callback(error);\n            }\n\n            that.vpaidFlashClient.loadAdUnit(that.mediaFile.src, callback);\n        }, flashClientOpts);\n\n        /*** Local Functions ***/\n        function sanityCheck(container, cb) {\n\n            if (!dom.isDomElement(container)) {\n                throw new VASTError('on VPAIDFlashTech.loadAdUnit, invalid dom container element');\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError('on VPAIDFlashTech.loadAdUnit, missing valid callback');\n            }\n        }\n    };\n\n    VPAIDFlashTech.prototype.unloadAdUnit = function() {\n        if (this.vpaidFlashClient) {\n            try {\n                this.vpaidFlashClient.destroy();\n            } catch (e) {\n                if (console && isFunction(console.log)) {\n                    console.log('VAST ERROR: trying to unload the VPAID adunit');\n                }\n            }\n            this.vpaidFlashClient = null;\n        }\n\n        if (this.containerEl) {\n            dom.remove(this.containerEl);\n            this.containerEl = null;\n        }\n    };\n\n    ;\n\n    function VPAIDHTML5Tech(mediaFile) {\n\n        if (!(this instanceof VPAIDHTML5Tech)) {\n            return new VPAIDHTML5Tech(mediaFile);\n        }\n\n        sanityCheck(mediaFile);\n\n        this.name = 'vpaid-html5';\n        this.containerEl = null;\n        this.videoEl = null;\n        this.vpaidHTMLClient = null;\n\n        this.mediaFile = mediaFile;\n\n        function sanityCheck(mediaFile) {\n            if (!mediaFile || !isString(mediaFile.src)) {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_MEDIA_FILE);\n            }\n        }\n    }\n\n    VPAIDHTML5Tech.supports = function(type) {\n        return !isOldIE() && type === 'application/javascript';\n    };\n\n    VPAIDHTML5Tech.prototype.loadAdUnit = function loadAdUnit(containerEl, videoEl, callback) {\n        sanityCheck(containerEl, videoEl, callback);\n\n        this.containerEl = containerEl;\n        this.videoEl = videoEl;\n        this.vpaidHTMLClient = new VPAIDHTML5Client(containerEl, videoEl, {});\n        this.vpaidHTMLClient.loadAdUnit(this.mediaFile.src, callback);\n\n\n\n        function sanityCheck(container, video, cb) {\n            if (!dom.isDomElement(container)) {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);\n            }\n\n            if (!dom.isDomElement(video) || video.tagName.toLowerCase() !== 'video') {\n                throw new VASTError(VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL);\n            }\n\n            if (!isFunction(cb)) {\n                throw new VASTError(VPAIDHTML5Tech.MISSING_CALLBACK);\n            }\n        }\n    };\n\n    VPAIDHTML5Tech.prototype.unloadAdUnit = function unloadAdUnit() {\n        if (this.vpaidHTMLClient) {\n            try {\n                this.vpaidHTMLClient.destroy();\n            } catch (e) {\n                if (console && isFunction(console.log)) {\n                    console.log('VAST ERROR: trying to unload the VPAID adunit');\n                }\n            }\n\n            this.vpaidHTMLClient = null;\n        }\n\n        if (this.containerEl) {\n            dom.remove(this.containerEl);\n            this.containerEl = null;\n        }\n    };\n\n    var PREFIX = 'on VPAIDHTML5Tech';\n    VPAIDHTML5Tech.INVALID_MEDIA_FILE = PREFIX + ', invalid MediaFile';\n    VPAIDHTML5Tech.INVALID_DOM_CONTAINER_EL = PREFIX + ', invalid container HtmlElement';\n    VPAIDHTML5Tech.INVALID_DOM_VIDEO_EL = PREFIX + ', invalid HTMLVideoElement';\n    VPAIDHTML5Tech.MISSING_CALLBACK = PREFIX + ', missing valid callback';\n\n\n    ;\n\n    function VPAIDIntegrator(player, settings) {\n        if (!(this instanceof VPAIDIntegrator)) {\n            return new VPAIDIntegrator(player);\n        }\n\n        this.VIEW_MODE = {\n            NORMAL: 'normal',\n            FULLSCREEN: \"fullscreen\",\n            THUMBNAIL: \"thumbnail\"\n        };\n        this.player = player;\n        this.containerEl = createVPAIDContainerEl(player);\n        this.options = {\n            adCancelTimeout: 5000,\n            VPAID_VERSION: '2.0'\n        };\n        this.settings = settings;\n        this.volume = 1;\n        this.initVolume = 1;\n        if (this.settings.initialAudio === 'off') {\n            logger.log(\"Initial audio off\");\n            this.initVolume = 0;\n        }\n        this.initAdUnitCalled = false;\n        this.initialisedAdUnit = null;\n        this.initAdTimeout = false;\n        /*** Local functions ***/\n\n        function createVPAIDContainerEl() {\n            var containerEl = document.createElement('div');\n            dom.addClass(containerEl, 'VPAID-container');\n            player.el().insertBefore(containerEl, player.controlBar.el());\n            return containerEl;\n\n        }\n        this.EVENTS = [\n            'AdLoaded', 'AdStarted', 'AdStopped', 'AdSkipped', 'AdSkippableStateChange',\n            'AdSizeChange', 'AdLinearChange', 'AdDurationChange', 'AdExpandedChange',\n            'AdRemainingTimeChange', 'AdVolumeChange', 'AdImpression', 'AdVideoStart',\n            'AdVideoFirstQuartile', 'AdVideoMidpoint', 'AdVideoThirdQuartile',\n            'AdVideoComplete', 'AdClickThru', 'AdInteraction', 'AdUserAcceptInvitation',\n            'AdUserMinimize', 'AdUserClose', 'AdPaused', 'AdPlaying', 'AdLog', 'AdError'\n        ];\n    }\n\n    //List of supported VPAID technologies\n    VPAIDIntegrator.techs = [\n        VPAIDFlashTech,\n        VPAIDHTML5Tech\n    ];\n\n    //minthe : protoype.playAd\n    VPAIDIntegrator.prototype.playAd = function playVPaidAd(vastResponse, callback, isTestPlay) {\n        //flag to sperate logic for checking vpaid ad is valid\n        isTestPlay = (isTestPlay && isTestPlay !== undefined ? isTestPlay : false);\n\n        var that = this;\n        var tech;\n        var player = this.player;\n\n        callback = callback || noop;\n        if (!(vastResponse instanceof VASTResponse)) {\n            return callback(new VASTError('on VASTIntegrator.playAd, missing required VASTResponse'));\n        }\n\n        tech = this._findSupportedTech(vastResponse, this.settings);\n        dom.addClass(player.el(), 'vjs-vpaid-ad');\n\n        player.on('vast.adsCancel', triggerVpaidAdEnd);\n        player.one('vpaid.adEnd', function() {\n            player.off('vast.adsCancel', triggerVpaidAdEnd);\n            removeAdUnit();\n        });\n\n        if (tech) {\n\n            //if it's test-play this routine will invoke initAd and return result to notify the creative is ready to go\n            if (isTestPlay) {\n                async.waterfall([\n                    function(next) {\n                        next(null, tech, vastResponse);\n                    },\n                    this._loadAdUnit.bind(this),\n                    this._initAdUnit.bind(this)\n                ], function(error, adUnit, vastResponse) {\n                    if (error) {\n                        that._trackError(vastResponse);\n                    } else {\n                        player.trigger('an.readytogovpaid');\n                    }\n                    callback(error, vastResponse);\n                });\n            } else {\n                var errorCallback = function(error, adUnit, vastResponse) {\n                    if (error) {\n                        that._trackError(vastResponse);\n                    }\n                    player.trigger('vpaid.adEnd');\n                    callback(error, vastResponse);\n                };\n                var taskList = [\n                    function(next) {\n                        next(null, that.initialisedAdUnit, vastResponse, true);\n                    },\n                    this._playAdUnit.bind(this)\n                ];\n                if (this.initialisedAdUnit) {\n                    async.waterfall(taskList, errorCallback);\n                } else {\n                    if (this.initAdUnitCalled) {\n                        player.one(\"an.readytogovpaid\", function() {\n                            async.waterfall(taskList, errorCallback);\n                        });\n                    } else {\n                        async.waterfall([\n                            function(next) {\n                                next(null, tech, vastResponse);\n                            },\n                            this._loadAdUnit.bind(this),\n                            this._initAdUnit.bind(this),\n                            this._playAdUnit.bind(this)\n                        ], errorCallback);\n                    }\n                }\n            }\n\n            this._adUnit = {\n                _paused: true,\n                type: 'VPAID',\n                pauseAd: function() {\n                    player.trigger('vpaid.pauseAd');\n                    player.pause(true); //we make sure that the video content gets stopped.\n                },\n                resumeAd: function() {\n                    player.trigger('vpaid.resumeAd');\n                },\n                isPaused: function() {\n                    return this._paused;\n                },\n                getSrc: function() {\n                    return tech.mediaFile;\n                }\n            };\n\n            return this._adUnit;\n        }\n\n        callback(new VASTError('on VPAIDIntegrator.playAd, could not find a supported mediaFile'));\n\n        return null;\n        /*** Local functions ***/\n        function triggerVpaidAdEnd() {\n            player.trigger('vpaid.adEnd');\n        }\n\n        function removeAdUnit() {\n            if (tech) {\n                tech.unloadAdUnit();\n            }\n            dom.removeClass(player.el(), 'vjs-vpaid-ad');\n        }\n    };\n\n    VPAIDIntegrator.prototype._findSupportedTech = function(vastResponse, settings) {\n        if (!(vastResponse instanceof VASTResponse)) {\n            return null;\n        }\n\n        var vpaidMediaFiles = vastResponse.mediaFiles.filter(vastUtil.isVPAID);\n        var i, len, mediaFile, VPAIDTech;\n\n        for (i = 0, len = vpaidMediaFiles.length; i < len; i += 1) {\n            mediaFile = vpaidMediaFiles[i];\n            VPAIDTech = findSupportedTech(mediaFile);\n            if (VPAIDTech) {\n                return new VPAIDTech(mediaFile, settings);\n            }\n        }\n\n        return null;\n\n        /*** Local functions ***/\n        function findSupportedTech(mediafile) {\n            var type = mediafile.type;\n            var i, len, VPAIDTech;\n\n            for (i = 0, len = VPAIDIntegrator.techs.length; i < len; i += 1) {\n                VPAIDTech = VPAIDIntegrator.techs[i];\n                if (VPAIDTech.supports(type)) {\n                    return VPAIDTech;\n                }\n            }\n            return null;\n        }\n    };\n\n    //minthe : loadAdUnit\n    VPAIDIntegrator.prototype._loadAdUnit = function(tech, vastResponse, next) {\n        if (this.initAdUnitCalled) {\n            return;\n        }\n        var player = this.player;\n        var vjsTechEl = player.el().querySelector('.vjs-tech');\n        var adCancelTimeout = this.settings.adCancelTimeout || this.options.adCancelTimeout;\n        var overlayPlayer = this.settings.overlayPlayer;\n        var initialPlayback = this.settings.initialPlayback;\n        var controlBarPosition = this.settings.controlBarPosition;\n        tech.loadAdUnit(this.containerEl, vjsTechEl, function(error, adUnit) {\n            if (error) {\n                return next(error, adUnit, vastResponse);\n            }\n\n            try {\n                var WrappedAdUnit = new VPAIDAdUnitWrapper(adUnit, { src: tech.mediaFile.src, adCancelTimeout: adCancelTimeout, overlayPlayer: overlayPlayer, initialPlayback: initialPlayback, controlBarPosition: controlBarPosition });\n                var techClass = 'vjs-' + tech.name + '-ad';\n                dom.addClass(player.el(), techClass);\n                player.one('vpaid.adEnd', function() {\n                    dom.removeClass(player.el(), techClass);\n                });\n                //Entry point for player's skip button which trigger 'skip' event;\n                player.on('skip', function() {\n                    WrappedAdUnit.skipAd();\n                });\n                next(null, WrappedAdUnit, vastResponse);\n            } catch (e) {\n                next(e, adUnit, vastResponse);\n            }\n        });\n    };\n\n\n    //minthe : _testAdUnit\n    VPAIDIntegrator.prototype._initAdUnit = function(adUnit, vastResponse, callback) {\n        if (this.initAdUnitCalled) {\n            return;\n        }\n        this.initAdUnitCalled = true;\n        async.waterfall([\n            function(next) {\n                next(null, adUnit, vastResponse);\n            },\n            this._handshake.bind(this),\n            this._setupEvents.bind(this),\n            this._initAd.bind(this)\n        ], callback);\n    };\n\n    //minthe : _playAdUnit\n    VPAIDIntegrator.prototype._playAdUnit = function(adUnit, vastResponse, callback) {\n        async.waterfall([\n            function(next) {\n                next(null, adUnit, vastResponse);\n            },\n            this._linkPlayerControls.bind(this),\n            this._startAd.bind(this)\n        ], callback);\n    };\n\n    VPAIDIntegrator.prototype._handshake = function handshake(adUnit, vastResponse, next) {\n        adUnit.handshakeVersion(this.options.VPAID_VERSION, function(error, version) {\n            if (error) {\n                return next(error, adUnit, vastResponse);\n            }\n\n            if (version && isSupportedVersion(version)) {\n                return next(null, adUnit, vastResponse);\n            }\n\n            return next(new VASTError('on VPAIDIntegrator._handshake, unsupported version \"' + version + '\"'), adUnit, vastResponse);\n        });\n\n        function isSupportedVersion(version) {\n            var majorNum = major(version);\n            return majorNum >= 1 && majorNum <= 2;\n        }\n\n        function major(version) {\n            var parts = version.split('.');\n            return parseInt(parts[0], 10);\n        }\n    };\n\n    //minthe : _initAd\n    VPAIDIntegrator.prototype._initAd = function(adUnit, vastResponse, next) {\n        var self = this;\n        var tech = this.player.el().querySelector('.vjs-tech');\n        var dimension = dom.getDimension(tech);\n        // Reset the timeout flag\n        self.initAdTimeout = false;\n\n        timer.startInitAdTimeout(function(error) {\n            self.initAdTimeout = true;\n            self._reportTimeout(adUnit, error);\n        });\n        /*\n        adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, {AdParameters: vastResponse.adParameters || ''}, function (error) {\n            self.initialisedAdUnit = adUnit;\n            next(error, adUnit, vastResponse);\n        });\n        */\n\n        adUnit.initAd(dimension.width, dimension.height, this.VIEW_MODE.NORMAL, -1, { AdParameters: vastResponse.adParameters || '' }, self.settings.vpaidEnvironmentVars, function(error) {\n            self.initialisedAdUnit = adUnit;\n            next(error, adUnit, vastResponse);\n        });\n    };\n\n    VPAIDIntegrator.prototype._setupEvents = function(adUnit, vastResponse, next) {\n        var adUnitSrc = adUnit.options.src;\n        var tracker = new VASTTracker(adUnitSrc, vastResponse);\n        var player = this.player;\n        var that = this;\n\n        function setupEventCallbacks() {\n            var cb = that.settings.vpaidEventCallback;\n            if (!cb) return;\n            that.EVENTS.forEach(function(event) {\n                adUnit.on(event, function(data) {\n                    cb.call(this, event, data);\n                });\n            });\n        };\n\n        setupEventCallbacks();\n\n        adUnit.on('AdLoaded', function() {\n            adUnit._adLoaded = true;\n            timer.stopInitAdTimeout();\n            logger.info('VPAID event received :: AdLoaded, time = ' + profile.getInitTime() + ', time remaining = ' + profile.getRemainingTime('AdLoaded'));\n        });\n\n        //minthe2 AdStarted Handler\n        //fix for VID-1525\n        adUnit.on('AdStarted', function() {\n\n            adUnit._adStarted = true;\n            profile.adStartedTimestamp = new Date().getTime();\n\n            if (that.settings.delayExpandUntilVPAIDImpression) {\n                if (profile.adImpressionTimestamp !== 0 && profile.adStartedTimestamp !== 0) {\n                    timer.stopStartAdTimeout();\n                }\n            } else {\n                timer.stopStartAdTimeout();\n            }\n\n            // if (profile.adImpressionTimestamp !== 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adLoadedTimestamp = profile.adImpressionTimestamp;\n            // }\n\n\n            if (!adUnit._adLoaded) {\n                var remainingTime = profile.timeout - (profile.adStartedTimestamp - profile.initAdTimestamp);\n                logger.info('VPAID event received :: AdStarted, time = ' + 0 + ', time remaining = ' + remainingTime + ', Out of order AdStarted');\n            } else {\n                if (that.settings.delayExpandUntilVPAIDImpression && profile.adImpressionTimestamp === 0) {\n                    logger.info('VPAID event received :: AdStarted');\n                } else {\n                    logger.info('VPAID event received :: AdStarted, time = ' + profile.getStartTime() + ', total time = ' + profile.getTotalTime() + ', time remaining = ' + profile.getRemainingTime('AdStarted'));\n                }\n            }\n            player.trigger('vpaid.AdStarted');\n            tracker.trackCreativeView();\n            notifyPlayToPlayer();\n\n\n            //activate impression timer if it's not already started\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adImpressionTimestamp === 0) {\n                profile.adImpressionTimestamp = new Date().getTime();\n                // timer.startAdImpressionTimeout(function (error) {\n                //     that._reportTimeout(adUnit, error);\n                // });\n            }\n            if (isAndroid()) {\n                ChiveFacebookHack();\n            }\n        });\n\n        // For creatives that do not use the video tag provided by the player.\n        function handleAdPlayPause() {\n            // Ad creatives do not creative their own video tags on devices so no need to handle AdProgess timer\n            // TODO : find  more reliable way to figure out the video src set.\n            if (isIDevice() || isAndroid()) {\n            \t// VIDLA-421 (do not ignore pause/resume event handlers for overlay player)\n            \tif (!adUnit.options.overlayPlayer) {\n                    return;\n            \t}\n            }\n\n            // Ad uses video JS Slot\n            if (isVideoSlotUsed()) {\n                return;\n            }\n            var creative = adUnit._adUnit ? adUnit._adUnit._creative : null;\n\n            if (adUnit.options.overlayPlayer) {\n                // since no monkeypatch api is activated.\n                player.on('pause', function() {\n                    if (adUnit._adUnit && creative) {\n                        that._adUnit.pauseAd();\n                    }\n                });\n                player.on('play', function() {\n                    if (adUnit._adUnit && creative) {\n                        that._adUnit.resumeAd();\n                    }\n                });\n            }\n\n            //IE11 has an issue to not listen this pause event - VID-2405, VID-2406\n            //video.js has their own event pooling sytem for video element and parent div of video element, the \"pause event\" area is so crowded for now - when vpaid player injects \"pause\" listener to player object on IE11, the video.js doesn't handle as well. looks like incorrect GUID setting problem in order to get events unique\n            //for handling this vpaid-creative.pause by \"pause\" signal from video.js we don't have to stick with the crowded \"pause\" signal. we can do samething with differnet signal for this\n            // player.on('pause', function(){\n            //     if(creative){\n            //         that._adUnit.pauseAd();\n            //     }\n            // });\n            player.on('apn-vpaid-pause', function() { //this \"apn-vpaid-pause\" will be dispatch from video.js pause.\n                if (creative) {\n                    // that._adUnit.pauseAd();//no need to dispatch pause again to video.js because video.js already dispatch pause before triggered \"apn-vpaid-pause\". this will also cover a case showing pause button on the UI\n                    player.trigger('vpaid.pauseAd'); //vpaid video pause\n                }\n            });\n        };\n\n        // For creatives that do not use the video tag provided by the player.\n        function handleAdProgress() {\n\n            // Ad creatives do not creative their own video tags on devices so no need to handle AdProgess timer\n            // TODO : find  more reliable way to figure out the video src set.\n            //if(isIDevice() || isAndroid()){\n            if (isIDevice()) { //for VID-2597\n                return;\n            }\n\n            // Ad uses video JS Slot\n            if (isVideoSlotUsed()) {\n                return;\n            }\n\n            // Ad is using its own Video slot.\n            var creative = adUnit._adUnit._creative;\n            var remainingTimeUnknown = false;\n\n            function updateProgress() {\n                var duration = creative.getAdDuration ? creative.getAdDuration() : 0;\n                var remainingTime = creative.getAdRemainingTime ? creative.getAdRemainingTime() : -1;\n                remainingTime = (remainingTime > duration) ? duration : remainingTime;//fix VIDLA-429\n                var currentTime = duration - remainingTime;\n\n                switch (remainingTime) {\n                    case -2:\n                        // If time is not currently known\n                        remainingTimeUnknown = true;\n                        player.controlBar.currentTimeDisplay.hide();\n                        player.controlBar.timeDivider.hide();\n                        player.controlBar.durationDisplay.hide();\n                        break;\n                    case -1:\n                        // If time is not implemeneted\n                        clearInterval(progressHandler);\n                        player.controlBar.currentTimeDisplay.hide();\n                        player.controlBar.timeDivider.hide();\n                        player.controlBar.durationDisplay.hide();\n                        break;\n                    case 0:\n                        clearInterval(progressHandler);\n                        break;\n                    default:\n                        if (remainingTimeUnknown) {\n                            remainingTimeUnknown = false;\n                            player.controlBar.currentTimeDisplay.show();\n                            player.controlBar.timeDivider.show();\n                            player.controlBar.durationDisplay.show();\n                        }\n                        player.currentTime(currentTime);\n                        player.controlBar.currentTimeDisplay.updateContent();\n                        player.duration(duration);\n                        player.controlBar.durationDisplay.updateContent();\n                        break;\n                }\n            }\n            var progressHandler = setInterval(updateProgress, 200);\n            updateProgress();\n        }\n\n        adUnit.on('AdSkipped', function() {\n            logger.log('VPAID event received :: AdSkipped');\n            player.trigger('vpaid.AdSkipped');\n            tracker.trackSkip();\n        });\n\n\n        //minthe2 AdImpression Handler\n        adUnit.on('AdImpression', function() {\n\n            profile.adImpressionTimestamp = new Date().getTime();\n\n\n            if (that.settings.delayExpandUntilVPAIDImpression) {\n                if (profile.adImpressionTimestamp !== 0 && profile.adStartedTimestamp !== 0) {\n                    timer.stopStartAdTimeout();\n                }\n            }\n\n            // if (profile.adImpressionTimestamp !== 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adLoadedTimestamp = profile.adImpressionTimestamp;\n            // }\n            // if (profile.adStartedTimestamp === 0) {//if AdImpression is deliverd without AdStarted\n            //     profile.adStartedTimestamp = profile.adLoadedTimestamp;\n            // }\n\n            if (that.settings.delayExpandUntilVPAIDImpression && profile.adStartedTimestamp === 0) {\n                logger.info('VPAID event received :: AdImpression');\n            } else {\n                logger.info('VPAID event received :: AdImpression, time = ' + profile.getAdImpressionTime() + ', total time = ' + profile.getTotalTime() + ', time remaining = ' + profile.getRemainingTime('AdImpression'));\n            }\n\n\n            player.trigger('vpaid.AdImpression');\n            tracker.trackImpressions();\n        });\n\n        adUnit.on('AdVideoStart', function() {\n            logger.info('VPAID event received :: AdVideoStart');\n\n            // VIDLA-441 This is definitely when the Ad video has started and all the metadata is ready. AdStarted event may be too early\n            handleAdPlayPause();\n            handleAdProgress();\n            \n            player.trigger('vpaid.AdVideoStart');\n            tracker.trackStart();\n            notifyPlayToPlayer();\n            if (that.settings.initialAudio === 'off') {\n                player.muted(true);\n            } else {\n                player.muted(false);\n            }\n            linkVolumeControl();\n            if (!that.settings.disableControlsOnMouseover) {\n                setupControlsOnMouseover(player, adUnit, that.VIEW_MODE);\n            } else {\n                resizeAd(player, adUnit, that.VIEW_MODE);\n            }\n            if (isIDevice()) {\n                ChiveFacebookHack();\n            }\n        });\n\n        // VID-3052 This is a temporary hack for FB creative autoplay on chive pages. Please see ticket for details.\n        function ChiveFacebookHack() {\n            var videoSlot = adUnit._adUnit._videoEl;\n            if (adUnit.options.overlayPlayer && adUnit.options.initialPlayback === 'auto' && videoSlot.paused) {\n                setTimeout(function() {\n                    // Overlay Chive hack for Facebook Creative\n                    logger.log('Applying Facebook Chive Hack');\n                    player.muted(true);\n                    that._adUnit.resumeAd();\n                }, 1000);\n            }\n        };\n\n        adUnit.on('AdPlaying', function() {\n            logger.log('VPAID event received :: AdPlaying');\n            timer.stopKillTimeout();\n            player.trigger('vpaid.AdPlaying');\n            tracker.trackResume();\n            notifyPlayToPlayer();\n        });\n\n        adUnit.on('AdPaused', function() {\n            logger.log('VPAID event received :: AdPaused');\n            timer.stopKillTimeout();\n            player.trigger('vpaid.AdPaused');\n            tracker.trackPause();\n            notifyPauseToPlayer();\n        });\n\n        function notifyPlayToPlayer() {\n            if (that._adUnit && that._adUnit.isPaused()) {\n                that._adUnit._paused = false;\n            }\n            player.trigger('play');\n\n        }\n\n        function notifyPauseToPlayer() {\n            if (that._adUnit) {\n                that._adUnit._paused = true;\n            }\n            player.trigger('pause');\n        }\n\n        adUnit.on('AdVideoFirstQuartile', function() {\n            logger.info('VPAID event received :: AdVideoFirstQuartile');\n            player.trigger('vpaid.AdVideoFirstQuartile');\n            tracker.trackFirstQuartile();\n        });\n\n        adUnit.on('AdVideoMidpoint', function() {\n            logger.info('VPAID event received :: AdVideoMidpoint');\n            player.trigger('vpaid.AdVideoMidpoint');\n            tracker.trackMidpoint();\n        });\n\n        adUnit.on('AdVideoThirdQuartile', function() {\n            logger.info('VPAID event received :: AdVideoThirdQuartile');\n            player.trigger('vpaid.AdVideoThirdQuartile');\n            tracker.trackThirdQuartile();\n        });\n\n        adUnit.on('AdVideoComplete', function() {\n            logger.info('VPAID event received :: AdVideoComplete');\n            player.trigger('vpaid.AdVideoComplete');\n            tracker.trackComplete();\n        });\n\n        adUnit.on('AdClickThru', function(data) {\n            player.trigger('vpaid.AdClickThru');\n            var url = data.url;\n            var playerHandles = data.playerHandles;\n            var clickThruUrl = isNotEmptyString(url) ? url : generateClickThroughURL(vastResponse.clickThrough);\n\n            tracker.trackClick();\n            if (playerHandles && clickThruUrl) {\n                window.open(clickThruUrl, '_blank');\n            }\n\n            function generateClickThroughURL(clickThroughMacro) {\n                var variables = {\n                    ASSETURI: adUnit.options.src,\n                    CONTENTPLAYHEAD: 0 //In VPAID there is no method to know the current time from the adUnit\n                };\n\n                return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : null;\n            }\n        });\n\n        adUnit.on('AdUserAcceptInvitation', function() {\n            player.trigger('vpaid.AdUserAcceptInvitation');\n            tracker.trackAcceptInvitation();\n            tracker.trackAcceptInvitationLinear();\n        });\n\n        adUnit.on('AdUserClose', function() {\n            player.trigger('vpaid.AdUserClose');\n            tracker.trackClose();\n            tracker.trackCloseLinear();\n        });\n\n        adUnit.on('AdUserMinimize', function() {\n            player.trigger('vpaid.AdUserMinimize');\n            tracker.trackCollapse();\n        });\n\n        adUnit.on('AdError', function(message) {\n            timer.stopAdTimeouts();\n            logger.error('VPAID event received :: AdError : message : ' + message);\n            //player.trigger('vast.adError');//TODO jeff's change for VID-583\n            player.trigger('vpaid.AdError');\n            //NOTE: we track errors code 901, as noted in VAST 3.0\n            tracker.trackErrorWithCode(901);\n        });\n\n        adUnit.on('AdVolumeChange', function() {\n            logger.debug('VPAID event received :: AdVolumeChange');\n            player.trigger('vpaid.AdVolumeChange');\n        });\n\n        adUnit.on('AdStopped', function() {\n            logger.info('VPAID event received :: AdStopped');\n            adUnit._adStopped = true;\n            player.trigger('vpaid.AdStopped');\n        });\n\n        var updateViewSize = resizeAd.bind(this, player, adUnit, this.VIEW_MODE);\n        var autoResize = this.settings.autoResize;\n\n        if (autoResize) {\n            dom.addEventListener(window, 'resize', updateViewSize);\n            dom.addEventListener(window, 'orientationchange', updateViewSize);\n        }\n\n        player.on('vast.resize', updateViewSize);\n        player.on('vpaid.pauseAd', pauseAdUnit);\n        player.on('vpaid.resumeAd', resumeAdUnit);\n\n        player.one('vpaid.adEnd', function() {\n            player.off('vast.resize', updateViewSize);\n            player.off('vpaid.pauseAd', pauseAdUnit);\n            player.off('vpaid.resumeAd', resumeAdUnit);\n\n            if (autoResize) {\n                dom.removeEventListener(window, 'resize', updateViewSize);\n                dom.removeEventListener(window, 'orientationchange', updateViewSize);\n            }\n        });\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local Functions ***/\n        function pauseAdUnit() {\n            adUnit.pauseAd(noop);\n        }\n\n        function resumeAdUnit() {\n            adUnit.resumeAd(noop);\n        }\n\n        function isVideoSlotUsed() {\n            var videoSlot = adUnit._adUnit._videoEl;\n            var creative = adUnit._adUnit._creative;\n\n            // Ad uses video JS Slot\n            if (!creative || !videoSlot || videoSlot.src) {\n                return true;\n            }\n            return false;\n        }\n\n        function linkVolumeControl() {\n            // Ad uses video JS slot. Volume be controlled via Player Framework\n            if (isVideoSlotUsed()) {\n                return;\n            }\n            // for creatives that create own tag set initial volume appropriately\n            adUnit.setAdVolume(that.initVolume, function(error, result) {\n                if (error) {\n                    logger.log('The volume change is not implemented as part of the ad unit');\n                } else {\n                    logger.debug('The volume change is implemented as part of the ad unit');\n                }\n            });\n            // Ad is using its own Video slot. Volume be controlled by setAdVolume\n            player.on('volumechange', updateAdUnitVolume);\n\n            player.one('vpaid.adEnd', function() {\n                player.off('volumechange', updateAdUnitVolume);\n            });\n\n            /*** local functions ***/\n            function updateAdUnitVolume() {\n                var vol;\n                if (player.muted()) {\n                    vol = 0;\n                } else {\n                    that.volume = player.volume() ? player.volume() : that.volume;\n                    vol = that.volume;\n                }\n                adUnit.setAdVolume(vol, logError);\n            }\n        }\n    };\n\n    VPAIDIntegrator.prototype._linkPlayerControls = function(adUnit, vastResponse, next) {\n        var that = this;\n        linkFullScreenControl(this.player, adUnit, this.VIEW_MODE);\n\n        next(null, adUnit, vastResponse);\n\n        /*** Local functions ***/\n\n        function linkFullScreenControl(player, adUnit, VIEW_MODE) {\n            var updateViewSize = resizeAd.bind(this, player, adUnit, VIEW_MODE);\n\n            player.on('fullscreenchange', updateViewSize);\n\n            player.one('vpaid.adEnd', function() {\n                player.off('fullscreenchange', updateViewSize);\n            });\n        }\n    };\n\n    //minthe : _startAd\n    VPAIDIntegrator.prototype._startAd = function(adUnit, vastResponse, next) {\n        var self = this;\n        var player = this.player;\n\n        if (self.initAdTimeout) {\n            return;\n        }\n        // VIDLA-245 IAS hack: If AdStarted is received before calling startAd then do not cap it with a timer.\n        if (!adUnit._adStarted) {\n            timer.startStartAdTimeout(function(error) {\n                self._reportTimeout(adUnit, error);\n            });\n        } else {\n            //Just set the timestamp correctly for VIDLA-245\n            profile.startAdTimestamp = new Date().getTime();\n        }\n        adUnit.startAd(function(error) {\n            if (!error) {\n                player.trigger('vast.adStart');\n            }\n        });\n    };\n\n\n    VPAIDIntegrator.prototype._trackError = function trackError(response) {\n        vastUtil.track(response.errorURLMacros, { ERRORCODE: 901 });\n    };\n\n    VPAIDIntegrator.prototype._reportTimeout = function(adUnit, error) {\n        var player = this.player;\n        player.trigger({ type: 'vast.adTimeout', error: error });\n        try {\n            if (adUnit && adUnit._adUnit) {\n                logger.log(\"Calling VPAID stopAd on TIMEOUT\");\n                adUnit._adUnit.stopAd();\n            }\n        } catch (e) {\n            logger.log('VPAID error in calling stopAd on Timeout');\n        }\n    };\n\n    function resizeAd(player, adUnit, VIEW_MODE) {\n        var tech = player.el().querySelector('.vjs-tech');\n        var dimension = dom.getDimension(tech);\n        var width = dimension.width;\n        var height = dimension.height;\n        var MODE = player.isFullscreen() ? VIEW_MODE.FULLSCREEN : VIEW_MODE.NORMAL;\n\n        var slot = adUnit._adUnit._el;\n        var videoSlot = adUnit._adUnit._videoEl;\n\n        var controlBar = player.controlBar;\n        var controlBarPosition = adUnit.options.controlBarPosition ? adUnit.options.controlBarPosition : \"over\";\n        var controlBarHeight = (controlBar && controlBarPosition === \"over\") ? controlBar.height() : 0;\n        if (controlBar && controlBarHeight) {\n            height = dimension.height - controlBarHeight;\n        }\n        //Resize both slot and video slot (Ads could use either or both)\n        if (slot && videoSlot) {\n            slot.style.height = height + 'px';\n            videoSlot.style.height = height + 'px';\n        }\n        adUnit.resizeAd(width, height, MODE, logError);\n    };\n\n    function setupControlsOnMouseover(player, adUnit, VIEW_MODE) {\n        var playerEl = player.el();\n        var controlBarPosition = adUnit.options.controlBarPosition ? adUnit.options.controlBarPosition : \"over\";\n        player.controlBar.hide();\n        if (!playerEl) return;\n        dom.addEventListener(playerEl, 'mouseover', onmouseover);\n        dom.addEventListener(playerEl, 'mouseout', onmouseout);\n\n        adUnit.on('AdStopped', function() {\n            player.controlBar.hide();\n            dom.removeEventListener(playerEl, 'mouseover', onmouseover);\n            dom.removeEventListener(playerEl, 'mouseout', onmouseout);\n        });\n\n        function onmouseover() {\n            var controlBarHeight = (controlBarPosition === \"over\" && player.controlBar) ? player.controlBar.height() : 0;\n            if (controlBarHeight === 0) {\n                player.controlBar.show();\n                resizeAd(player, adUnit, VIEW_MODE);\n            }\n        };\n\n        function onmouseout() {\n            var controlBarHeight = (controlBarPosition === \"over\" && player.controlBar) ? player.controlBar.height() : 0;\n            if (controlBarHeight !== 0) {\n                player.controlBar.hide();\n                resizeAd(player, adUnit, VIEW_MODE);\n            }\n        };\n    };\n\n    function logError(error) {\n        if (error) {\n            logger.log('ERROR: ' + error.message);\n        }\n    };\n\n    function Ad(adJTree) {\n        if (!(this instanceof Ad)) {\n            return new Ad(adJTree);\n        }\n\n        this.id = adJTree.attr('id');\n        this.sequence = adJTree.attr('sequence');\n\n        if (adJTree.inLine) {\n            this.inLine = new InLine(adJTree.inLine);\n        }\n\n        if (adJTree.wrapper) {\n            this.wrapper = new Wrapper(adJTree.wrapper);\n        }\n    };\n\n    function Creative(creativeJTree) {\n        if (!(this instanceof Creative)) {\n            return new Creative(creativeJTree);\n        }\n\n        this.id = creativeJTree.attr('id');\n        this.sequence = creativeJTree.attr('sequence');\n        this.adId = creativeJTree.attr('adId');\n        this.apiFramework = creativeJTree.attr('apiFramework');\n\n        if (creativeJTree.linear) {\n            this.linear = new Linear(creativeJTree.linear);\n        }\n    };\n\n    function InLine(inlineJTree) {\n        if (!(this instanceof InLine)) {\n            return new InLine(inlineJTree);\n        }\n\n        //Required Fields\n        this.adTitle = xml.keyValue(inlineJTree.adTitle);\n        this.adSystem = xml.keyValue(inlineJTree.adSystem);\n        this.impressions = vastUtil.parseImpressions(inlineJTree.impression);\n        this.creatives = vastUtil.parseCreatives(inlineJTree.creatives);\n\n        //Optional Fields\n        this.description = xml.keyValue(inlineJTree.description);\n        this.advertiser = xml.keyValue(inlineJTree.advertiser);\n        this.surveys = parseSurveys(inlineJTree.survey);\n        this.error = xml.keyValue(inlineJTree.error);\n        this.pricing = xml.keyValue(inlineJTree.pricing);\n        this.extensions = inlineJTree.extensions;\n\n        /*** Local Functions ***/\n        function parseSurveys(inlineSurveys) {\n            if (inlineSurveys) {\n                return transformArray(isArray(inlineSurveys) ? inlineSurveys : [inlineSurveys], function(survey) {\n                    if (isNotEmptyString(survey.keyValue)) {\n                        return {\n                            uri: survey.keyValue,\n                            type: survey.attr('type')\n                        };\n                    }\n\n                    return undefined;\n                });\n            }\n            return [];\n        }\n    };\n\n    function Linear(linearJTree) {\n        if (!(this instanceof Linear)) {\n            return new Linear(linearJTree);\n        }\n\n        //Required Elements\n        this.duration = vastUtil.parseDuration(xml.keyValue(linearJTree.duration));\n        this.mediaFiles = parseMediaFiles(linearJTree.mediaFiles && linearJTree.mediaFiles.mediaFile);\n\n        //Optional fields\n        this.trackingEvents = parseTrackingEvents(linearJTree.trackingEvents && linearJTree.trackingEvents.tracking, this.duration);\n        this.skipoffset = vastUtil.parseOffset(xml.attr(linearJTree, 'skipoffset'), this.duration);\n\n        if (linearJTree.videoClicks) {\n            this.videoClicks = new VideoClicks(linearJTree.videoClicks);\n        }\n\n        if (linearJTree.adParameters) {\n            this.adParameters = xml.keyValue(linearJTree.adParameters);\n\n            if (xml.attr(linearJTree.adParameters, 'xmlEncoded')) {\n                this.adParameters = xml.decode(this.adParameters);\n            }\n        }\n\n        /*** Local functions ***/\n        function parseTrackingEvents(trackingEvents, duration) {\n            var trackings = [];\n            if (isDefined(trackingEvents)) {\n                trackingEvents = isArray(trackingEvents) ? trackingEvents : [trackingEvents];\n                trackingEvents.forEach(function(trackingData) {\n                    trackings.push(new TrackingEvent(trackingData, duration));\n                });\n            }\n            return trackings;\n        }\n\n        function parseMediaFiles(mediaFilesJxonTree) {\n            var mediaFiles = [];\n            if (isDefined(mediaFilesJxonTree)) {\n                mediaFilesJxonTree = isArray(mediaFilesJxonTree) ? mediaFilesJxonTree : [mediaFilesJxonTree];\n\n                mediaFilesJxonTree.forEach(function(mfData) {\n                    mediaFiles.push(new MediaFile(mfData));\n                });\n            }\n            return mediaFiles;\n        }\n    };\n\n    function MediaFile(mediaFileJTree) {\n        if (!(this instanceof MediaFile)) {\n            return new MediaFile(mediaFileJTree);\n        }\n\n        //Required attributes\n        this.src = xml.keyValue(mediaFileJTree);\n        this.delivery = mediaFileJTree.attr('delivery');\n        this.type = mediaFileJTree.attr('type');\n        this.width = mediaFileJTree.attr('width');\n        this.height = mediaFileJTree.attr('height');\n\n        //Optional attributes\n        this.codec = mediaFileJTree.attr('codec');\n        this.id = mediaFileJTree.attr('id');\n        this.bitrate = mediaFileJTree.attr('bitrate');\n        this.minBitrate = mediaFileJTree.attr('minBitrate');\n        this.maxBitrate = mediaFileJTree.attr('maxBitrate');\n        this.scalable = mediaFileJTree.attr('scalable');\n        this.maintainAspectRatio = mediaFileJTree.attr('maintainAspectRatio');\n        this.apiFramework = mediaFileJTree.attr('apiFramework');\n    };\n\n    function TrackingEvent(trackingJTree, duration) {\n        if (!(this instanceof TrackingEvent)) {\n            return new TrackingEvent(trackingJTree, duration);\n        }\n\n        this.name = trackingJTree.attr('event');\n        this.uri = xml.keyValue(trackingJTree);\n\n        if ('progress' === this.name) {\n            this.offset = vastUtil.parseOffset(trackingJTree.attr('offset'), duration);\n        }\n    }\n\n    ;\n\n    //minthe : VASTClient initialize\n    function VASTClient(options) {\n\n        if (!(this instanceof VASTClient)) {\n            return new VASTClient(options);\n        }\n        var defaultOptions = {\n            WRAPPER_LIMIT: 5\n        };\n\n        options = options || {};\n        this.settings = extend({}, options, defaultOptions);\n        this.errorURLMacros = [];\n    }\n\n    VASTClient.prototype.getVASTResponse = function getVASTResponse(adTagUrl, callback) {\n        var that = this;\n\n        var error = sanityCheck(adTagUrl, callback);\n        if (error) {\n            if (isFunction(callback)) {\n                return callback(error);\n            }\n            throw error;\n        }\n\n        async.waterfall([\n                this._getVASTAd.bind(this, adTagUrl),\n                buildVASTResponse\n            ],\n            callback);\n\n        /*** Local functions ***/\n        function buildVASTResponse(adsChain, cb) {\n            try {\n                var response = that._buildVASTResponse(adsChain);\n                cb(null, response);\n            } catch (e) {\n                cb(e);\n            }\n        }\n\n        function sanityCheck(adTagUrl, cb) {\n            if (!adTagUrl) {\n                return new VASTError('on VASTClient.getVASTResponse, missing ad tag URL');\n            }\n\n            if (!isFunction(cb)) {\n                return new VASTError('on VASTClient.getVASTResponse, missing callback function');\n            }\n        }\n    };\n\n    VASTClient.prototype._getVASTAd = function(adTagUrl, callback) {\n        var that = this;\n\n        getAdWaterfall(adTagUrl, function(error, vastTree) {\n            var waterfallAds = vastTree && isArray(vastTree.ads) ? vastTree.ads : null;\n            if (error) {\n                that._trackError(error, waterfallAds);\n                return callback(error, waterfallAds);\n            }\n\n            getAd(waterfallAds.shift(), [], waterfallHandler);\n\n            /*** Local functions ***/\n            function waterfallHandler(error, adChain) {\n                if (error) {\n                    that._trackError(error, adChain);\n                    if (waterfallAds.length > 0) {\n                        getAd(waterfallAds.shift(), [], waterfallHandler);\n                    } else {\n                        callback(error, adChain);\n                    }\n                } else {\n                    callback(null, adChain);\n                }\n            }\n        });\n\n        /*** Local functions ***/\n        function getAdWaterfall(adTagUrl, callback) {\n            var requestVastXML = that._requestVASTXml.bind(that, adTagUrl);\n            async.waterfall([\n                requestVastXML,\n                buildVastWaterfall\n            ], callback);\n        }\n\n        function buildVastWaterfall(xmlStr, callback) {\n            var vastTree;\n            try {\n                vastTree = xml.toJXONTree(xmlStr);\n                vastTree.ads = isArray(vastTree.ad) ? vastTree.ad : [vastTree.ad];\n                callback(validateVASTTree(vastTree), vastTree);\n            } catch (e) {\n                callback(new VASTError(\"on VASTClient.getVASTAd.buildVastWaterfall, error parsing xml\", 100), null);\n            }\n        }\n\n        function validateVASTTree(vastTree) {\n            var vastVersion = xml.attr(vastTree, 'version');\n\n            if (!vastTree.ad) {\n                return new VASTError('on VASTClient.getVASTAd.validateVASTTree, no Ad in VAST tree', 303);\n            }\n\n            if (vastVersion && (vastVersion != 3 && vastVersion != 2)) {\n                return new VASTError('on VASTClient.getVASTAd.validateVASTTree, not supported VAST version \"' + vastVersion + '\"', 102);\n            }\n\n            return null;\n        }\n\n        function getAd(adTagUrl, adChain, callback) {\n            if (adChain.length >= that.WRAPPER_LIMIT) {\n                return callback(new VASTError(\"on VASTClient.getVASTAd.getAd, players wrapper limit reached (the limit is \" + that.WRAPPER_LIMIT + \")\", 302), adChain);\n            }\n\n            async.waterfall([\n                function(next) {\n                    if (isString(adTagUrl)) {\n                        requestVASTAd(adTagUrl, next);\n                    } else {\n                        next(null, adTagUrl);\n                    }\n                },\n                buildAd\n            ], function(error, ad) {\n                if (ad) {\n                    adChain.push(ad);\n                }\n\n                if (error) {\n                    return callback(error, adChain);\n                }\n\n                if (ad.wrapper) {\n                    return getAd(ad.wrapper.VASTAdTagURI, adChain, callback);\n                }\n\n                return callback(null, adChain);\n            });\n        }\n\n        function buildAd(adJxonTree, callback) {\n            try {\n                var ad = new Ad(adJxonTree);\n                callback(validateAd(ad), ad);\n            } catch (e) {\n                callback(new VASTError('on VASTClient.getVASTAd.buildAd, error parsing xml', 100), null);\n            }\n        }\n\n        function validateAd(ad) {\n            var wrapper = ad.wrapper;\n            var inLine = ad.inLine;\n            var errMsgPrefix = 'on VASTClient.getVASTAd.validateAd, ';\n\n            if (inLine && wrapper) {\n                return new VASTError(errMsgPrefix + \"InLine and Wrapper both found on the same Ad\", 101);\n            }\n\n            if (!inLine && !wrapper) {\n                return new VASTError(errMsgPrefix + \"nor wrapper nor inline elements found on the Ad\", 101);\n            }\n\n            if (inLine && inLine.creatives.length === 0) {\n                return new VASTError(errMsgPrefix + \"missing creative in InLine element\", 101);\n            }\n\n            if (wrapper && !wrapper.VASTAdTagURI) {\n                return new VASTError(errMsgPrefix + \"missing 'VASTAdTagURI' in wrapper\", 101);\n            }\n        }\n\n        function requestVASTAd(adTagUrl, callback) {\n            that._requestVASTXml(adTagUrl, function(error, xmlStr) {\n                if (error) {\n                    return callback(error);\n                }\n                try {\n                    var vastTree = xml.toJXONTree(xmlStr);\n                    callback(validateVASTTree(vastTree), vastTree.ad);\n                } catch (e) {\n                    callback(new VASTError(\"on VASTClient.getVASTAd.requestVASTAd, error parsing xml\", 100));\n                }\n            });\n        }\n    };\n\n    VASTClient.prototype._requestVASTXml = function requestVASTXml(adTagUrl, callback) {\n        try {\n            if (isFunction(adTagUrl)) {\n                adTagUrl(requestHandler);\n            } else {\n                http.get(adTagUrl, requestHandler, {\n                    withCredentials: true\n                });\n            }\n        } catch (e) {\n            callback(e);\n        }\n\n        /*** Local functions ***/\n        function requestHandler(error, response, status) {\n            if (error) {\n                var errMsg = isDefined(status) ?\n                    \"on VASTClient.requestVastXML, HTTP request error with status '\" + status + \"'\" :\n                    \"on VASTClient.requestVastXML, Error getting the the VAST XML with he passed adTagXML fn\";\n                return callback(new VASTError(errMsg, 301), null);\n            }\n\n            callback(null, response);\n        }\n    };\n\n    VASTClient.prototype._buildVASTResponse = function buildVASTResponse(adsChain) {\n        var response = new VASTResponse();\n        addAdsToResponse(response, adsChain);\n        validateResponse(response);\n\n        return response;\n\n        //*** Local function ****\n        function addAdsToResponse(response, ads) {\n            ads.forEach(function(ad) {\n                response.addAd(ad);\n            });\n        }\n\n        function validateResponse(response) {\n            var progressEvents = response.trackingEvents.progress;\n\n            if (!response.hasLinear()) {\n                throw new VASTError(\"on VASTClient._buildVASTResponse, Received an Ad type that is not supported\", 200);\n            }\n\n            if (response.duration === undefined) {\n                throw new VASTError(\"on VASTClient._buildVASTResponse, Missing duration field in VAST response\", 101);\n            }\n\n            if (progressEvents) {\n                progressEvents.forEach(function(progressEvent) {\n                    if (!isNumber(progressEvent.offset)) {\n                        throw new VASTError(\"on VASTClient._buildVASTResponse, missing or wrong offset attribute on progress tracking event\", 101);\n                    }\n                });\n            }\n        }\n    };\n\n    VASTClient.prototype._trackError = function(error, adChain) {\n        if (!isArray(adChain) || adChain.length === 0) { //There is nothing to track\n            return;\n        }\n\n        var errorURLMacros = [];\n        adChain.forEach(addErrorUrlMacros);\n        vastUtil.track(errorURLMacros, { ERRORCODE: error.code || 900 }); //900 <== Undefined error\n\n        /*** Local functions  ***/\n        function addErrorUrlMacros(ad) {\n            if (ad.wrapper && ad.wrapper.error) {\n                errorURLMacros.push(ad.wrapper.error);\n            }\n\n            if (ad.inLine && ad.inLine.error) {\n                errorURLMacros.push(ad.inLine.error);\n            }\n        }\n    };\n\n    ;\n    var VAST = {};\n\n    function VASTError(message, code) {\n        this.message = 'VAST Error: ' + (message || '');\n        if (code) {\n            this.code = code;\n        }\n    }\n\n    VASTError.prototype = new Error();\n    VASTError.prototype.name = \"VAST Error\";;\n    /**\n     * Inner helper class that deals with the logic of the individual steps needed to setup an ad in the player.\n     *\n     * @param player {object} instance of the player that will play the ad. It assumes that the videojs-contrib-ads plugin\n     *                        has been initialized when you use its utility functions.\n     *\n     * @constructor\n     */\n    function VASTIntegrator(player) {\n        if (!(this instanceof VASTIntegrator)) {\n            return new VASTIntegrator(player);\n        }\n\n        this.player = player;\n    }\n\n    VASTIntegrator.prototype.playAd = function playAd(vastResponse, callback) {\n        var that = this;\n        callback = callback || noop;\n\n        if (!(vastResponse instanceof VASTResponse)) {\n            return callback(new VASTError('On VASTIntegrator, missing required VASTResponse'));\n        }\n\n        async.waterfall([\n            function(next) {\n                next(null, vastResponse);\n            },\n            this._selectAdSource.bind(this),\n            this._createVASTTracker.bind(this),\n            this._addClickThrough.bind(this),\n            this._setupEvents.bind(this),\n            this._playSelectedAd.bind(this)\n        ], function(error, response) {\n            if (error && response) {\n                that._trackError(error, response);\n            }\n            callback(error, response);\n        });\n\n        this._adUnit = {\n            _src: null,\n            type: 'VAST',\n            pauseAd: function() {\n                that.player.pause(true); //video.js player pause\n            },\n\n            resumeAd: function() {\n                that.player.play(true);\n            },\n\n            isPaused: function() {\n                return that.player.paused(true);\n            },\n\n            getSrc: function() {\n                return this._src;\n            }\n        };\n\n        return this._adUnit;\n    };\n\n    VASTIntegrator.prototype._selectAdSource = function selectAdSource(response, callback) {\n        var source;\n\n        var playerWidth = dom.getDimension(this.player.el()).width;\n        response.mediaFiles.sort(function compareTo(a, b) {\n            var deltaA = Math.abs(playerWidth - a.width);\n            var deltaB = Math.abs(playerWidth - b.width);\n            return deltaA - deltaB;\n        });\n\n        source = this.player.selectSource(response.mediaFiles).source;\n\n        if (source) {\n            if (this._adUnit) {\n                this._adUnit._src = source;\n            }\n            return callback(null, source, response);\n        }\n\n        // code 403 <== Couldn't find MediaFile that is supported by this video player\n        callback(new VASTError(\"Could not find Ad mediafile supported by this player\", 403), response);\n    };\n\n    VASTIntegrator.prototype._createVASTTracker = function createVASTTracker(adMediaFile, response, callback) {\n        try {\n            callback(null, adMediaFile, new VASTTracker(adMediaFile.src, response), response);\n        } catch (e) {\n            callback(e, response);\n        }\n    };\n\n    VASTIntegrator.prototype._setupEvents = function setupEvents(adMediaFile, tracker, response, callback) {\n        var previouslyMuted;\n        var player = this.player;\n        player.on('fullscreenchange', trackFullscreenChange);\n        player.on('vast.adStart', trackImpressions);\n        player.on('pause', trackPause);\n        player.on('timeupdate', trackProgress);\n        player.on('volumechange', trackVolumeChange);\n\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], unbindEvents);\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adSkip'], function(evt) {\n            if (evt.type === 'vast.adEnd') {\n                tracker.trackComplete();\n            }\n        });\n\n        return callback(null, adMediaFile, response);\n\n        /*** Local Functions ***/\n        function unbindEvents() {\n            player.off('fullscreenchange', trackFullscreenChange);\n            player.off('vast.adStart', trackImpressions);\n            player.off('pause', trackPause);\n            player.off('timeupdate', trackProgress);\n            player.off('volumechange', trackVolumeChange);\n        }\n\n        function trackFullscreenChange() {\n            if (player.isFullscreen()) {\n                tracker.trackFullscreen();\n            } else {\n                tracker.trackExitFullscreen();\n            }\n        }\n\n        function trackPause() {\n            //NOTE: whenever a video ends the video Element triggers a 'pause' event before the 'ended' event.\n            //      We should not track this pause event because it makes the VAST tracking confusing again we use a\n            //      Threshold of 2 seconds to prevent false positives on IOS.\n            if (Math.abs(player.duration() - player.currentTime()) < 2) {\n                return;\n            }\n\n            tracker.trackPause();\n            playerUtils.once(player, ['play', 'vast.adEnd', 'vast.adsCancel'], function(evt) {\n                if (evt.type === 'play') {\n                    tracker.trackResume();\n                }\n            });\n        }\n\n        function trackProgress() {\n            var currentTimeInMs = player.currentTime() * 1000;\n            tracker.trackProgress(currentTimeInMs);\n        }\n\n        function trackImpressions() {\n            tracker.trackImpressions();\n            tracker.trackCreativeView();\n        }\n\n        function trackVolumeChange() {\n            var muted = player.muted();\n            if (muted) {\n                tracker.trackMute();\n            } else if (previouslyMuted) {\n                tracker.trackUnmute();\n            }\n            previouslyMuted = muted;\n        }\n    };\n\n    VASTIntegrator.prototype._addClickThrough = function addClickThrough(mediaFile, tracker, response, callback) {\n        var player = this.player;\n        var blocker = createClickThroughBlocker(player, tracker, response);\n        var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);\n\n        player.el().insertBefore(blocker, player.controlBar.el());\n        player.on('timeupdate', updateBlocker);\n        playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);\n\n        return callback(null, mediaFile, tracker, response);\n\n        /*** Local Functions ***/\n\n        function createClickThroughBlocker(player, tracker, response) {\n            var blocker = window.document.createElement(\"a\");\n            var clickThroughMacro = response.clickThrough;\n\n            dom.addClass(blocker, 'vast-blocker');\n            blocker.href = generateClickThroughURL(clickThroughMacro, player);\n\n            if (isString(clickThroughMacro)) {\n                blocker.target = \"_blank\";\n            }\n\n            blocker.onclick = function(e) {\n                if (player.paused()) {\n                    player.play();\n\n                    //We prevent event propagation to avoid problems with the player's normal pause mechanism\n                    if (window.Event.prototype.stopPropagation !== undefined) {\n                        e.stopPropagation();\n                    }\n                    return false;\n                }\n\n                player.pause();\n                tracker.trackClick();\n            };\n\n            return blocker;\n        }\n\n        function updateBlockerURL(blocker, response, player) {\n            blocker.href = generateClickThroughURL(response.clickThrough, player);\n        }\n\n        function generateClickThroughURL(clickThroughMacro, player) {\n            var variables = {\n                ASSETURI: mediaFile.src,\n                CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)\n            };\n\n            return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';\n        }\n\n        function removeBlocker() {\n            player.off('timeupdate', updateBlocker);\n            dom.remove(blocker);\n        }\n    };\n\n    VASTIntegrator.prototype._playSelectedAd = function playSelectedAd(source, response, callback) {\n        var player = this.player;\n\n        player.preload(\"auto\"); //without preload=auto the durationchange event is never fired\n        player.src(source);\n\n        playerUtils.once(player, ['durationchange', 'error', 'vast.adsCancel'], function(evt) {\n            if (evt.type === 'durationchange') {\n                playAd();\n            } else if (evt.type === 'error') {\n                callback(new VASTError(\"on VASTIntegrator, Player is unable to play the Ad\", 400), response);\n            }\n            //NOTE: If the ads get canceled we do nothing/\n        });\n\n        /**** local functions ******/\n        function playAd() {\n            player.play();\n            playerUtils.once(player, ['playing', 'vast.adsCancel'], function(evt) {\n                if (evt.type === 'vast.adsCancel') {\n                    return;\n                }\n\n                player.trigger('vast.adStart');\n\n                playerUtils.once(player, ['ended', 'vast.adsCancel', 'vast.adSkip'], function(evt) {\n                    if (evt.type === 'ended' || evt.type === 'vast.adSkip') {\n                        callback(null, response);\n                    }\n                    //NOTE: if the ads get cancel we do nothing\n                });\n            });\n        }\n    };\n\n    VASTIntegrator.prototype._trackError = function trackError(error, response) {\n        vastUtil.track(response.errorURLMacros, { ERRORCODE: error.code || 900 });\n    };\n\n    ;\n    (function(window) {\n        \"use strict\";\n\n\n        function VASTResponse() {\n            if (!(this instanceof VASTResponse)) {\n                return new VASTResponse();\n            }\n\n            this._linearAdded = false;\n            this.ads = [];\n            this.errorURLMacros = [];\n            this.impressions = [];\n            this.clickTrackings = [];\n            this.customClicks = [];\n            this.trackingEvents = {};\n            this.mediaFiles = [];\n            this.clickThrough = undefined;\n            this.adTitle = '';\n            this.duration = undefined;\n            this.skipoffset = undefined;\n        }\n\n        VASTResponse.prototype.addAd = function(ad) {\n            var inLine, wrapper;\n\n            if (ad instanceof Ad) {\n                inLine = ad.inLine;\n                wrapper = ad.wrapper;\n\n                this.ads.push(ad);\n\n                if (inLine) {\n                    this._addInLine(inLine);\n                }\n\n                if (wrapper) {\n                    this._addWrapper(wrapper);\n                }\n            }\n        };\n\n        VASTResponse.prototype._addErrorTrackUrl = function(error) {\n            var errorURL = error instanceof xml.JXONTree ? xml.keyValue(error) : error;\n            if (errorURL) {\n                this.errorURLMacros.push(errorURL);\n            }\n        };\n\n        VASTResponse.prototype._addImpressions = function(impressions) {\n            isArray(impressions) && appendToArray(this.impressions, impressions);\n        };\n\n        VASTResponse.prototype._addClickThrough = function(clickThrough) {\n            if (isNotEmptyString(clickThrough)) {\n                this.clickThrough = clickThrough;\n            }\n        };\n\n        VASTResponse.prototype._addClickTrackings = function(clickTrackings) {\n            isArray(clickTrackings) && appendToArray(this.clickTrackings, clickTrackings);\n        };\n\n        VASTResponse.prototype._addCustomClicks = function(customClicks) {\n            isArray(customClicks) && appendToArray(this.customClicks, customClicks);\n        };\n\n        VASTResponse.prototype._addTrackingEvents = function(trackingEvents) {\n            var eventsMap = this.trackingEvents;\n\n            if (trackingEvents) {\n                trackingEvents = isArray(trackingEvents) ? trackingEvents : [trackingEvents];\n                trackingEvents.forEach(function(trackingEvent) {\n                    if (!eventsMap[trackingEvent.name]) {\n                        eventsMap[trackingEvent.name] = [];\n                    }\n                    eventsMap[trackingEvent.name].push(trackingEvent);\n                });\n            }\n        };\n\n        VASTResponse.prototype._addTitle = function(title) {\n            if (isNotEmptyString(title)) {\n                this.adTitle = title;\n            }\n        };\n\n        VASTResponse.prototype._addDuration = function(duration) {\n            if (isNumber(duration)) {\n                this.duration = duration;\n            }\n        };\n\n        VASTResponse.prototype._addVideoClicks = function(videoClicks) {\n            if (videoClicks instanceof VideoClicks) {\n                this._addClickThrough(videoClicks.clickThrough);\n                this._addClickTrackings(videoClicks.clickTrackings);\n                this._addCustomClicks(videoClicks.customClicks);\n            }\n        };\n\n        VASTResponse.prototype._addMediaFiles = function(mediaFiles) {\n            isArray(mediaFiles) && appendToArray(this.mediaFiles, mediaFiles);\n        };\n\n        VASTResponse.prototype._addSkipoffset = function(offset) {\n            if (offset) {\n                this.skipoffset = offset;\n            }\n        };\n\n        VASTResponse.prototype._addAdParameters = function(adParameters) {\n            if (adParameters) {\n                this.adParameters = adParameters;\n            }\n        };\n\n        VASTResponse.prototype._addLinear = function(linear) {\n            if (linear instanceof Linear) {\n                this._addDuration(linear.duration);\n                this._addTrackingEvents(linear.trackingEvents);\n                this._addVideoClicks(linear.videoClicks);\n                this._addMediaFiles(linear.mediaFiles);\n                this._addSkipoffset(linear.skipoffset);\n                this._addAdParameters(linear.adParameters);\n                this._linearAdded = true;\n            }\n        };\n\n        VASTResponse.prototype._addInLine = function(inLine) {\n            var that = this;\n\n            if (inLine instanceof InLine) {\n                this._addTitle(inLine.adTitle);\n                this._addErrorTrackUrl(inLine.error);\n                this._addImpressions(inLine.impressions);\n\n                inLine.creatives.forEach(function(creative) {\n                    if (creative.linear) {\n                        that._addLinear(creative.linear);\n                    }\n                });\n            }\n        };\n\n        VASTResponse.prototype._addWrapper = function(wrapper) {\n            var that = this;\n\n            if (wrapper instanceof Wrapper) {\n                this._addErrorTrackUrl(wrapper.error);\n                this._addImpressions(wrapper.impressions);\n\n                wrapper.creatives.forEach(function(creative) {\n                    var linear = creative.linear;\n                    if (linear) {\n                        that._addVideoClicks(linear.videoClicks);\n                        that.clickThrough = undefined; //We ensure that no clickThrough has been added\n                        that._addTrackingEvents(linear.trackingEvents);\n                    }\n                });\n            }\n        };\n\n        VASTResponse.prototype.hasLinear = function() {\n            return this._linearAdded;\n        };\n\n        function appendToArray(array, items) {\n            items.forEach(function(item) {\n                array.push(item);\n            });\n        }\n\n        window.VASTResponse = VASTResponse;\n    })(window);\n\n    ;\n\n    function VASTTracker(assetURI, vastResponse) {\n        if (!(this instanceof VASTTracker)) {\n            return new VASTTracker(assetURI, vastResponse);\n        }\n\n        sanityCheck(assetURI, vastResponse);\n        this.response = vastResponse;\n        this.assetURI = assetURI;\n        this.progress = 0;\n        this.quartiles = {\n            firstQuartile: { tracked: false, time: Math.round(25 * vastResponse.duration) / 100 },\n            midpoint: { tracked: false, time: Math.round(50 * vastResponse.duration) / 100 },\n            thirdQuartile: { tracked: false, time: Math.round(75 * vastResponse.duration) / 100 }\n        };\n\n        /*** Local Functions ***/\n        function sanityCheck(assetURI, vastResponse) {\n            if (!isString(assetURI) || isEmptyString(assetURI)) {\n                throw new VASTError('on VASTTracker constructor, missing required the URI of the ad asset being played');\n            }\n\n            if (!(vastResponse instanceof VASTResponse)) {\n                throw new VASTError('on VASTTracker constructor, missing required VAST response');\n            }\n        }\n    }\n\n    VASTTracker.prototype.trackURLs = function trackURLs(urls, variables) {\n        if (isArray(urls) && urls.length > 0) {\n            variables = extend({\n                ASSETURI: this.assetURI,\n                CONTENTPLAYHEAD: vastUtil.formatProgress(this.progress)\n            }, variables || {});\n\n            vastUtil.track(urls, variables);\n        }\n    };\n\n    VASTTracker.prototype.trackEvent = function trackEvent(eventName, trackOnce) {\n        this.trackURLs(getEventUris(this.response.trackingEvents[eventName]));\n        if (trackOnce) {\n            this.response.trackingEvents[eventName] = undefined;\n        }\n\n        /*** Local function ***/\n        function getEventUris(trackingEvents) {\n            var uris;\n\n            if (trackingEvents) {\n                uris = [];\n                trackingEvents.forEach(function(event) {\n                    uris.push(event.uri);\n                });\n            }\n            return uris;\n        }\n    };\n\n    VASTTracker.prototype.trackProgress = function trackProgress(newProgressInMs) {\n        var events = [];\n        var ONCE = true;\n        var ALWAYS = false;\n        var trackingEvents = this.response.trackingEvents;\n\n        if (isNumber(newProgressInMs)) {\n            addTrackEvent('start', ONCE, newProgressInMs > 0);\n            addTrackEvent('rewind', ALWAYS, hasRewound(this.progress, newProgressInMs));\n            addQuartileEvents.call(this, newProgressInMs);\n            trackProgressEvents.call(this, newProgressInMs);\n            trackEvents.call(this);\n            this.progress = newProgressInMs;\n        }\n\n        /*** Local function ***/\n        function hasRewound(currentProgress, newProgress) {\n            var REWIND_THRESHOLD = 3000; //IOS video clock is very unreliable and we need a 3 seconds threshold to ensure that there was a rewind an that it was on purpose.\n            return currentProgress > newProgressInMs && Math.abs(newProgress - currentProgress) > REWIND_THRESHOLD;\n        }\n\n        function addTrackEvent(eventName, trackOnce, canBeAdded) {\n            if (trackingEvents[eventName] && canBeAdded) {\n                events.push({\n                    name: eventName,\n                    trackOnce: !!trackOnce\n                });\n            }\n        }\n\n        function addQuartileEvents(progress) {\n            var quartiles = this.quartiles;\n            var firstQuartile = this.quartiles.firstQuartile;\n            var midpoint = this.quartiles.midpoint;\n            var thirdQuartile = this.quartiles.thirdQuartile;\n\n            if (!firstQuartile.tracked) {\n                trackQuartile('firstQuartile', progress);\n            } else if (!midpoint.tracked) {\n                trackQuartile('midpoint', progress);\n            } else {\n                trackQuartile('thirdQuartile', progress);\n            }\n\n            /*** Local function ***/\n            function trackQuartile(quartileName, progress) {\n                var quartile = quartiles[quartileName];\n                if (canBeTracked(quartile, progress)) {\n                    quartile.tracked = true;\n                    addTrackEvent(quartileName, ONCE, true);\n                }\n            }\n        }\n\n        function canBeTracked(quartile, progress) {\n            var quartileTime = quartile.time;\n            //We only fire the quartile event if the progress is bigger than the quartile time by 5 seconds at most.\n            return progress >= quartileTime && progress <= (quartileTime + 5000);\n        }\n\n        function trackProgressEvents(progress) {\n            if (!isArray(trackingEvents.progress)) {\n                return; //Nothing to track\n            }\n\n            var pendingProgressEvts = [];\n            var that = this;\n\n            trackingEvents.progress.forEach(function(evt) {\n                if (evt.offset <= progress) {\n                    that.trackURLs([evt.uri]);\n                } else {\n                    pendingProgressEvts.push(evt);\n                }\n            });\n            trackingEvents.progress = pendingProgressEvts;\n        }\n\n        function trackEvents() {\n            events.forEach(function(event) {\n                this.trackEvent(event.name, event.trackOnce);\n            }, this);\n        }\n    };\n\n    [\n        'rewind',\n        'fullscreen',\n        'exitFullscreen',\n        'pause',\n        'resume',\n        'mute',\n        'unmute',\n        'acceptInvitation',\n        'acceptInvitationLinear',\n        'collapse',\n        'expand'\n    ].forEach(function(eventName) {\n        VASTTracker.prototype['track' + capitalize(eventName)] = function() {\n            this.trackEvent(eventName);\n        };\n    });\n\n    [\n        'start',\n        'skip',\n        'close',\n        'closeLinear'\n    ].forEach(function(eventName) {\n        VASTTracker.prototype['track' + capitalize(eventName)] = function() {\n            this.trackEvent(eventName, true);\n        };\n    });\n\n    [\n        'firstQuartile',\n        'midpoint',\n        'thirdQuartile'\n    ].forEach(function(quartile) {\n        VASTTracker.prototype['track' + capitalize(quartile)] = function() {\n            this.quartiles[quartile].tracked = true;\n            this.trackEvent(quartile, true);\n        };\n    });\n\n    VASTTracker.prototype.trackComplete = function() {\n        if (this.quartiles.thirdQuartile.tracked) {\n            this.trackEvent('complete', true);\n        }\n    };\n\n    VASTTracker.prototype.trackErrorWithCode = function trackErrorWithCode(errorcode) {\n        if (isNumber(errorcode)) {\n            this.trackURLs(this.response.errorURLMacros, { ERRORCODE: errorcode });\n        }\n    };\n\n    VASTTracker.prototype.trackImpressions = function trackImpressions() {\n        this.trackURLs(this.response.impressions);\n    };\n\n    VASTTracker.prototype.trackCreativeView = function trackCreativeView() {\n        this.trackEvent('creativeView');\n    };\n\n    VASTTracker.prototype.trackClick = function trackClick() {\n        this.trackURLs(this.response.clickTrackings);\n    };\n\n    ;\n\n    function VideoClicks(videoClickJTree) {\n        if (!(this instanceof VideoClicks)) {\n            return new VideoClicks(videoClickJTree);\n        }\n\n        this.clickThrough = xml.keyValue(videoClickJTree.clickThrough);\n        this.clickTrackings = parseClickTrackings(videoClickJTree.clickTracking);\n        this.customClicks = parseClickTrackings(videoClickJTree.customClick);\n\n        /*** Local functions ***/\n        function parseClickTrackings(trackingData) {\n            var clickTrackings = [];\n            if (trackingData) {\n                trackingData = isArray(trackingData) ? trackingData : [trackingData];\n                trackingData.forEach(function(clickTrackingData) {\n                    clickTrackings.push(xml.keyValue(clickTrackingData));\n                });\n            }\n            return clickTrackings;\n        }\n    };\n\n    function Wrapper(wrapperJTree) {\n        if (!(this instanceof Wrapper)) {\n            return new Wrapper(wrapperJTree);\n        }\n\n        //Required elements\n        this.adSystem = xml.keyValue(wrapperJTree.adSystem);\n        this.impressions = vastUtil.parseImpressions(wrapperJTree.impression);\n        this.VASTAdTagURI = xml.keyValue(wrapperJTree.vASTAdTagURI);\n\n        //Optional elements\n        this.creatives = vastUtil.parseCreatives(wrapperJTree.creatives);\n        this.error = xml.keyValue(wrapperJTree.error);\n        this.extensions = wrapperJTree.extensions;\n\n        //Optional attrs\n        this.followAdditionalWrappers = isDefined(xml.attr(wrapperJTree, 'followAdditionalWrappers')) ? xml.attr(wrapperJTree, 'followAdditionalWrappers') : true;\n        this.allowMultipleAds = xml.attr(wrapperJTree, 'allowMultipleAds');\n        this.fallbackOnNoAd = xml.attr(wrapperJTree, 'fallbackOnNoAd');\n    }\n\n\n    ;\n    \"use strict\";\n\n    var vastUtil = {\n\n        track: function track(URLMacros, variables) {\n            var sources = vastUtil.parseURLMacros(URLMacros, variables);\n            var trackImgs = [];\n            sources.forEach(function(src) {\n                var img = new Image();\n                img.src = src;\n                trackImgs.push(img);\n            });\n            return trackImgs;\n        },\n\n        parseURLMacros: function parseMacros(URLMacros, variables) {\n            var parsedURLs = [];\n\n            variables = variables || {};\n\n            if (!(variables[\"CACHEBUSTING\"])) {\n                variables[\"CACHEBUSTING\"] = Math.round(Math.random() * 1.0e+10);\n            }\n\n            URLMacros.forEach(function(URLMacro) {\n                parsedURLs.push(vastUtil._parseURLMacro(URLMacro, variables));\n            });\n\n            return parsedURLs;\n        },\n\n        parseURLMacro: function parseMacro(URLMacro, variables) {\n            variables = variables || {};\n\n            if (!(variables[\"CACHEBUSTING\"])) {\n                variables[\"CACHEBUSTING\"] = Math.round(Math.random() * 1.0e+10);\n            }\n\n            return vastUtil._parseURLMacro(URLMacro, variables);\n        },\n\n        _parseURLMacro: function parseMacro(URLMacro, variables) {\n            variables = variables || {};\n\n            forEach(variables, function(value, key) {\n                URLMacro = URLMacro.replace(new RegExp(\"\\\\[\" + key + \"\\\\\\]\", 'gm'), value);\n            });\n\n            return URLMacro;\n        },\n\n        parseDuration: function parseDuration(durationStr) {\n            var durationRegex = /(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d\\d\\d))?/;\n            var match, durationInMs;\n\n            if (isString(durationStr)) {\n                match = durationStr.match(durationRegex);\n                if (match) {\n                    durationInMs = parseHoursToMs(match[1]) + parseMinToMs(match[2]) + parseSecToMs(match[3]) + parseInt(match[5] || 0);\n                }\n            }\n\n            return isNaN(durationInMs) ? null : durationInMs;\n\n            /*** local functions ***/\n            function parseHoursToMs(hourStr) {\n                return parseInt(hourStr, 10) * 60 * 60 * 1000;\n            }\n\n            function parseMinToMs(minStr) {\n                return parseInt(minStr, 10) * 60 * 1000;\n            }\n\n            function parseSecToMs(secStr) {\n                return parseInt(secStr, 10) * 1000;\n            }\n        },\n\n        parseImpressions: function parseImpressions(impressions) {\n            if (impressions) {\n                impressions = isArray(impressions) ? impressions : [impressions];\n                return transformArray(impressions, function(impression) {\n                    if (isNotEmptyString(impression.keyValue)) {\n                        return impression.keyValue;\n                    }\n                    return undefined;\n                });\n            }\n            return [];\n        },\n\n        parseCreatives: function parseCreatives(creativesJTree) {\n            var creatives = [];\n            var creativesData;\n            if (isDefined(creativesJTree) && isDefined(creativesJTree.creative)) {\n                creativesData = isArray(creativesJTree.creative) ? creativesJTree.creative : [creativesJTree.creative];\n                creativesData.forEach(function(creative) {\n                    creatives.push(new Creative(creative));\n                });\n            }\n            return creatives;\n        },\n\n        //We assume that the progress is going to arrive in milliseconds\n        formatProgress: function formatProgress(progress) {\n            var hours, minutes, seconds, milliseconds;\n            hours = progress / (60 * 60 * 1000);\n            hours = Math.floor(hours);\n            minutes = (progress / (60 * 1000)) % 60;\n            minutes = Math.floor(minutes);\n            seconds = (progress / 1000) % 60;\n            seconds = Math.floor(seconds);\n            milliseconds = progress % 1000;\n            return toFixedDigits(hours, 2) + ':' + toFixedDigits(minutes, 2) + ':' + toFixedDigits(seconds, 2) + '.' + toFixedDigits(milliseconds, 3);\n        },\n\n        parseOffset: function parseOffset(offset, duration) {\n            if (isPercentage(offset)) {\n                return calculatePercentage(offset, duration);\n            }\n            return vastUtil.parseDuration(offset);\n\n            /*** Local function ***/\n            function isPercentage(offset) {\n                var percentageRegex = /^\\d+(\\.\\d+)?%$/g;\n                return percentageRegex.test(offset);\n            }\n\n            function calculatePercentage(percentStr, duration) {\n                if (duration) {\n                    return calcPercent(duration, parseFloat(percentStr.replace('%', '')));\n                }\n                return null;\n            }\n\n            function calcPercent(quantity, percent) {\n                return quantity * percent / 100;\n            }\n        },\n\n        isVPAID: function isVPAIDMediaFile(mediaFile) {\n            return !!mediaFile && mediaFile.apiFramework === 'VPAID';\n        }\n    };\n})(window, document, videojs);\n//# sourceMappingURL=videojs-vast-vpaid.js.map\n\n/* jshint ignore:end */\n"

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * ExtendDefaultOption for playerManager
	 * This logic will exnted options to have default value
	 *
	 * @param defaultOptions
	 * @param options_
	 * @returns {*}
	 * @constructor
	 */
	var ExtendDefaultOption = function (defaultOptions, options_) {

	    function isObject(obj) {
	        return typeof obj === 'object';
	    }

	    function isNull(o) {
	        return o === null;
	    }

	    function extend(obj) {
	        var arg, i, k;
	        for (i = 1; i < arguments.length; i++) {
	            arg = arguments[i];
	            for (k in arg) {
	                if (arg.hasOwnProperty(k)) {
	                    if (isObject(obj[k]) && !isNull(obj[k]) && isObject(arg[k])) {
	                        obj[k] = extend({}, obj[k], arg[k]);
	                    } else {
	                        obj[k] = arg[k];
	                    }
	                }
	            }
	        }
	        return obj;
	    }

	    //extend by default options
	    var options = extend({}, defaultOptions, options_ || {});

	    //manual touch
	    if (options.playerTechnology === undefined || options.playerTechnology.length === 0) {
	        options.playerTechnology = ["html5", "flash"];
	    }

	    if (!options.width || typeof options.width === "undefined" || options.width === "" || options.width === 0) {
	        options.autoInitialSize = true;
	    }

	    //handle disableCollapse if it's number or true or false
	    if (typeof(options.disableCollapse) === "number") {
	        if (options.disableCollapse >= 0) {
	            options.disableCollapseForDelay = options.disableCollapse;
	        }
	        options.disableCollapse = false;
	    }


	    //this options should be false anytime.
	    options.enableExplicitPause = true;

	    return options;//TODO is Object.create required for this?

	};

	module.exports = ExtendDefaultOption;



/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var plainCssText = __webpack_require__(24);


	var _logger = __webpack_require__(2);
	var debug = function (message) {
	    _logger.debug("Custom Skinning: " + message);
	};

	var reorderControlBar = function(playerSelf, videojs, iframeDocument, isInline) {
	    var controlBar = videojs.controlBar;

	    var buttonOrderLeft = playerSelf.options.playerSkin.buttonOrderLeft;
	    var buttonOrderRight = playerSelf.options.playerSkin.buttonOrderRight;

	    var process = function(value, index, array, float) {
	        var component;

	        if (controlBar[value]) {
	            component = controlBar[value].el_;
	            if (isInline) {
	                if (value === 'playToggle') {
	                    component = iframeDocument.getElementById('customPlayToggle');
	                } else if (value === 'fullscreenToggle') {
	                    component = iframeDocument.getElementById('customFullscreenToggle');
	                }
	            }
	            if (component) {
	                controlBar.el_.appendChild(component);
	                component.style.float = float;
	            }
	        }
	    };

	    if (buttonOrderLeft) {
	        buttonOrderLeft.forEach(function(value, index, array) {
	            process(value, index, array, 'left');
	        });
	    }

	    if (buttonOrderRight) {
	        buttonOrderRight.reverse().forEach(function(value, index, array) {
	            process(value, index, array, 'right');
	        });
	    }
	};

	var styleElements = function(playerSelf, videojs, IframeDocument, isInline) {

	    debug("Applying custom styles/skins");

	    var cssForIosInlineVideo =  "";
	    if (isInline) {
	        cssForIosInlineVideo = ".vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar {display: block !important;visibility: visible !important;opacity: 1 !important} .vjs-loading-spinner { position: absolute; top: 50%; left: 50%; font-size: 4em; line-height: 1; width: 1em; height: 1em; margin-left: -0.5em; margin-top: -0.5em; opacity: 0.75; display: block; -webkit-animation: spin 1.5s infinite linear; -moz-animation: spin 1.5s infinite linear; -o-animation: spin 1.5s infinite linear; animation: spin 1.5s infinite linear; }\n";
	    }
	    var cssForIos = "video::-webkit-media-controls-start-playback-button {display: none !important;-webkit-appearance: none;}\n";

	    var skinCss = "\n";

	    var playerSkin = playerSelf.options.playerSkin;

	    if (playerSkin) {
	        if (playerSkin.topBarColor) {
	            skinCss += "#top_chrome { background: " + playerSkin.topBarColor + "; }\n";
	        }
	        if (playerSkin.dividerColor) {
	            skinCss += "#top_chrome { border-bottom-color: " + playerSkin.dividerColor + "; }\n";
	        } else {
	            skinCss += "#top_chrome { border-bottom-color: " + playerSkin.bottomDividerColor + "; }\n";
	        }
	        if (typeof playerSkin.dividerHeight === "number") {
	            skinCss += "#top_chrome { border-bottom-width: " + playerSkin.dividerHeight + "; border-bottom-style: solid; }\n";
	        } else {
	            skinCss += "#top_chrome { border-bottom-width: " + playerSkin.bottomDividerWidth + "; border-bottom-style: solid; }\n";
	        }
	        if (playerSkin.topBarTextColor) {
	            skinCss += ".top-bar-text { color: " + playerSkin.topBarTextColor + "; }\n";
	        }
	        if (playerSkin.controlBarColor) {
	            skinCss += ".vjs-default-skin .vjs-control-bar { background-color: " + playerSkin.controlBarColor + "; }\n";
	        }
	        if (playerSkin.controlBarControlsColor) {
	            skinCss += ".vjs-default-skin .vjs-control-bar { color: " + playerSkin.controlBarControlsColor + "; }\n";
	            skinCss += ".vjs-default-skin:hover .vjs-control-bar { color: " + playerSkin.controlBarControlsColor + "; }\n";
	        }
	        if (playerSkin.bigPlayButtonColor) {
	            skinCss += ".vjs-default-skin .vjs-big-play-button { color: " + playerSkin.bigPlayButtonColor + "; border-color: " + playerSkin.bigPlayButtonColor + "; }\n";
	            skinCss += ".vjs-default-skin:hover .vjs-big-play-button { color: " + playerSkin.bigPlayButtonColor + "; border-color: " + playerSkin.bigPlayButtonColor + "; }\n";
	        }
	        if (playerSkin.progressBarElapsedColor) {
	            skinCss += ".vjs-default-skin .vjs-play-progress { background: " + playerSkin.progressBarElapsedColor + " }\n";
	        }
	        if (playerSkin.volumeBarBackground) {
	            skinCss += ".vjs-default-skin .vjs-volume-level { background: " + playerSkin.volumeBarBackground + " }\n";
	        }
	        if (playerSkin.controlBarHeight) {
	            skinCss += ".vjs-default-skin .vjs-control-bar { height: " + playerSkin.controlBarHeight + "px; }\n";
	            /* for control bar 20px-30px, font size should be one third of the control bar height*/
	            skinCss += ".vjs-default-skin .vjs-control { font-size: " + Math.ceil(playerSkin.controlBarHeight/3) + "px; }\n";
	            /* the time divider is set up different so we need to adjust the size relative to the controlBarHeight */
	            skinCss += ".vjs-default-skin .vjs-time-divider { height: " + playerSkin.controlBarHeight + "px; line-height: " + playerSkin.controlBarHeight/9.7 + "em}\n";
	            /* to ensure the progressBar doesn't change height when we change font-height */
	            skinCss += ".vjs-default-skin .vjs-progress-control { font-size: 0.3em }\n";
	        }
	    } else {
	        skinCss += "#top_chrome { border-bottom-color: " + playerSkin.bottomDividerColor + "; border-bottom-width: " + playerSkin.bottomDividerWidth + "; border-bottom-style: solid; }\n";
	    }

	    if ((playerSelf.isAndroid && playerSelf.isAndroid()) || playerSelf.options.controlBarPosition === "below") {
	        skinCss += ".vjs-default-skin .vjs-control-bar { display: block !important;visibility: visible !important;opacity: 1 !important ;bottom: -3.0em }\n";
	    }

	    //generate dynamic css
	    debug("Generating css element");
	    var cssStyle = document.createElement("style");
	    cssStyle.type = "text/css";
	    cssStyle.innerHTML = plainCssText + cssForIos + skinCss + cssForIosInlineVideo;

	    IframeDocument.head.appendChild(cssStyle);

	};

	var render = function(playerSelf, videojs, IframeDocument, isInline) {

	    reorderControlBar(playerSelf, videojs, IframeDocument, isInline);
	    styleElements(playerSelf, videojs, IframeDocument, isInline);

	};

	module.exports = {
	    "render": render
	};


/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = ".vjs-default-skin{color:#CCCCCC}@font-face{font-family:'VideoJS';src:url('font/vjs.eot');src:url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAAnMAAsAAAAADWgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAABCAAABokAAAgsXGkfVUZGVE0AAAeUAAAAHAAAABxxb8IrR0RFRgAAB7AAAAAiAAAAJgAnADxPUy8yAAAH1AAAAEMAAABgVDdTq2NtYXAAAAgYAAAAVgAAAWr6rrHraGVhZAAACHAAAAAsAAAANgaEyq9oaGVhAAAInAAAABwAAAAkCSAFLWhtdHgAAAi4AAAAJwAAAEgr1gKfbWF4cAAACOAAAAAGAAAABgAWUABuYW1lAAAI6AAAANUAAAGk8SNjJXBvc3QAAAnAAAAADAAAACAAAwAAeJxlVX9MW9cVvhf88K0Bt2txSTfLxNsSqkZaITjdgrZ2KaZiWYaI47lkCYTgphB+mFB+xFgZJDamqa+TAH4EkoDVNKRA3eF2UEqaJqHENKiVUAJI2zrSLkWZNO2P/dPqPnyg2r2A00zTue87737nfee943vuNUYqFcIYk8P2muqaGgfCcQijXCUDKZlY2RqnZMUrG1Q0KZ4mqQwa9Eij7VlKH9wkqWmuXiqOWiU9TnhUj9Bjepz5Az1K0qv3Po6eEqnikYQISkaPo1SkR0a0GW1BGWgbykYvIDP6DcpHe1AhKkKl6BC3KlTXkNGQ2bA1oyE3I2MVMgVsFZAlwCRgm4DnBPxcwC8EbBewQ8CLAnIEmAXkcshchZcacp/jCX+WsV5srGaE8Ov4JH4D+zDFfnwKn8ZncDvuwJ04gGXchc/ibtyDz+Hz+AJ6MlaVGmnQU+hptINXUYiq0S30Bb6Jb8d1xL0Z96/4syqN6j+SVVKoVpgia6Ny1KrbqAHTikln1GiZdWlet5SynLLCL0nLUviUza/IMJ+gWJfk2L1W2RSVdD/WaJUrrEb3Ew08vfSMmC69wlJ0P9XAC/98iIzOR7Xv61poc7tbdgbpUDC4uHiVEcoe42MfI1mLa2wwOESDTvKtcQo2UniGj92w0Wh0u5vbWiiB5+//X2ZFfDzML8ts9VJkSbu68CqO353XR99K0KvuKhd0PpbX+kXJZGv3sc4W+eAQ7D0LTRScFOzHS6tb3Mda3S2lVu8vT0IeOQ15Hb8a3SM3n/d2e0Yrmf0Ec77Bmk6xvV0fhLoD5zs6e8Zudv7Nz/LI8t8/0h1nxl9/CT/kn/foFoiHXHhpEeLZpjRe3sI/upmRgCGh7eUG+35KXmye++u3Q59cTxungxVnLESJPtnCjDu+hB9xtXZd/fX36p41tZeri/5HPVDRbiFrS7Mkr3DjyyEm5ohldjYSmZ21RMxmi8VsYP2gWmXvTEVm7+yeyjVbducamBn6deWDjuHhwcHhYcdgebnDUW4AlWAHHGHBhh0D5WU1NWUGEBmoOva0gVL194p+FouFB9Zi4ZqBsnIH11UqozxkGyuZmBgbmxChiZIxm62kxGbI4u+xhypHRkKhkZHKkN1eWWk3aBWrksLbMFqv1Is25AubomNh1gT54OImfDjtCD1yqvY0xHFLPQpPnCRvq2//6dNpeod2+WRfF5C/7BBtlUqYizWxfBY2rHdImCdo4igSNvG03LNVz2ecTwNZxYxMDWowcnvgmZqznBc+jU0tT+mytwMuBjUVA49n392+UMwwZWo+xhm+u0Bm8iiVIBVSKVQw7j7f9VX5fXqffjX8+WcslaVSVgHckZkZ6W72OODVTOpiwNuziXbpGybrimmp01FNlnNYleQP+ANUprIv4AsQRTCD1aPOcUoW5+YWF3PmsrJycrLSqNvv8Xu4Aqokx1BpsJgSwWfN5SzybhkNDg5xLY/5PD4PdRPBx/QGvv8Vq843c2zmyK3a6Vdu7hvff8USzr+Uf2nn2Z2+nb7f/rGgtqD294cOFJEDReXW+oL6guO7/NzO/a7f0m957+UPS8ZLJioiDZH66RPTfjLtv3Vu8tLkpWvDox9+MBa6fnGy5115+EyYnEkYHhwIp7WrN8Hzunrb4X0H7Qftf6iyNdoaLW6L3+Lf01N4sfCt/e8eGjk0Un316HVy9Ib7E/+kf7J74uK1ix+Hxv/83vvhK4MfB68FJ+Qbvgnf9ZarjeSjxrGq4VfDr759ILivb3+g0LeXUErbJFrRXxM66S0/cfhYJVnvghCFRqhrhaEO1sZ2MRtrpKJT8qEIaKxVH7TEd7wlQpQ1srpONuSFNtgFNuAC3oz5rIjRWD/HeiqN/5LsGx1lVkjvl7x9rb2eXnKPJYOe6SF5m+QKuALODlLHNoOV1sFmyel1eVweAsn3QA/6e5AseVytLm8TgfTXKFhZ+mtSR1OnS3YREyTzHHqm/Vq64On19HlJP6QzK+1n6VJfR2/gQoAwrYnxF5lYsiT3dvZ29JFl3KozWyJrB0LEsnogiG9MoTqapOF/hk8gCeMNGQWeG3TZBCZmAitYt/ybWXkFfCYlijlnTcsmShURN4mYlHj58ptuWkZWbqtpWaO79jIBL/OCeCiFmaiU+PBBv7BA2YbshYfPd6aBRF4fcEfWj/bEZtrS7u5y9tF3gn0P7ZI1oi/4Du1zxnYLiW0X94mWVe1/AVE82XMAAAAAAAABAAAAANDR138AAAAAz5mnxQAAAADRBELmeJxjYGRgYOABYjEGOQYmBkYgFAViFqAIExAzQjAACdkAZAAAeJxjYGb+xTiBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKIHEC0lxTGBwYGJ8xMB/4f4ABSAJ5QDVwBQpAyAgAobYMfwB4nGNgYGBmgGAZBkYGEEgB8hjBfBYGDyDNx8DBwMTABhRTeMD3QP4Zw/+///+DVSo8YHggB+Uz/n+swCL/VUoUqhsFMLIBMRO6KCpgxi895AEAetoSOQAAeJxjYGQAg2MiZgnx/DZfGbhZwPyLLM4yCPr/LtY45gNALgcDE0gUAOkeCHF4nGNgZGBgPvD/AAMDaxwDA5hkZEAFfABctgNZeJxjYEAAJiBmgeADQNzAguAzsDhAxFnjwHQDgwVcmzyIAABxXQOhAAAAUAAAFgAAeJx1zT0KwjAcBfDXL8UKIiguLh0FoVg8goMU6eLg4tTWIAVtIOpQPIBHcPQ2grfy1f4dG0j6y0tfAmCINyz8hy220MVIbNNzsUOvxC69F3vo4y7uMH+KfYzxYctye/JCYwsDqrFNT8UOvRS79EbsYYJc3GH+EPuY4VVfW/BY48ypUXKb67PWxBYKR9xwQgrDrTreTqlp/78t3/EegwvP6zxAhBALxspcCl0GUbho767ZLX/9FFd+D+xnqLjGv0byb6xVqUx6VYcgq4I410ld/wJ2ozpzAAAAeJxjYGbACwAAfQAE) format(\"woff\"),url('font/vjs.eot?#iefix') format('embedded-opentype'),url('font/vjs.ttf') format('truetype'),url('font/vjs.svg#icomoon') format('svg');font-weight:normal;font-style:normal}.vjs-default-skin .vjs-slider{outline:0;position:relative;cursor:pointer;padding:0;background-color:#333333;background-color:rgba(51,51,51,0.9)}.vjs-default-skin .vjs-slider:focus{-webkit-box-shadow:0 0 2em #fff;-moz-box-shadow:0 0 2em #fff;box-shadow:0 0 2em #fff}.vjs-default-skin .vjs-slider-handle{position:absolute;left:0;top:0}.vjs-default-skin .vjs-slider-handle:before{content:\"\\e009\";font-family:VideoJS;font-size:1em;line-height:1;text-align:center;text-shadow:0 0 1em #fff;position:absolute;top:0;left:0;-webkit-transform:rotate(-45deg);-moz-transform:rotate(-45deg);-ms-transform:rotate(-45deg);-o-transform:rotate(-45deg);transform:rotate(-45deg)}.vjs-default-skin .vjs-control-bar{display:none;position:absolute;bottom:0;left:0;right:0;height:3em;background-color:#07141E;background-color:rgba(7,20,30,0.7)}.vjs-default-skin.vjs-has-started .vjs-control-bar{display:block;visibility:visible;opacity:1;-webkit-transition:visibility .1s,opacity .1s;-moz-transition:visibility .1s,opacity .1s;-o-transition:visibility .1s,opacity .1s;transition:visibility .1s,opacity .1s}.vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{display:block;visibility:hidden;opacity:0;-webkit-transition:visibility 1s,opacity 1s;-moz-transition:visibility 1s,opacity 1s;-o-transition:visibility 1s,opacity 1s;transition:visibility 1s,opacity 1s}.vjs-default-skin.vjs-controls-disabled .vjs-control-bar{display:none}.vjs-default-skin.vjs-using-native-controls .vjs-control-bar{display:none}.vjs-default-skin.vjs-error .vjs-control-bar{display:none}.vjs-audio.vjs-default-skin.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{opacity:1;visibility:visible}@media \\0screen{.vjs-default-skin.vjs-user-inactive.vjs-playing .vjs-control-bar :before{content:\"\"}}.vjs-default-skin .vjs-control{outline:none;position:relative;float:left;text-align:center;margin:0;padding:0;height:3em;width:4em}.vjs-default-skin .vjs-control:before{font-family:VideoJS;font-size:1.5em;line-height:2;position:absolute;top:0;left:0;width:100%;height:100%;text-align:center;text-shadow:1px 1px 1px rgba(0,0,0,0.5)}.vjs-default-skin .vjs-control:focus:before,.vjs-default-skin .vjs-control:hover:before{text-shadow:0 0 1em #fff}.vjs-default-skin .vjs-control-text{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.vjs-default-skin .vjs-play-control{width:5em;cursor:pointer}.vjs-default-skin .vjs-play-control:before{content:\"\\e001\"}.vjs-default-skin.vjs-playing .vjs-play-control:before{content:\"\\e002\"}.vjs-default-skin .vjs-playback-rate .vjs-playback-rate-value{font-size:1.5em;line-height:2;position:absolute;top:0;left:0;width:100%;height:100%;text-align:center;text-shadow:1px 1px 1px rgba(0,0,0,0.5)}.vjs-default-skin .vjs-playback-rate.vjs-menu-button .vjs-menu .vjs-menu-content{width:4em;left:-2em;list-style:none}.vjs-default-skin .vjs-mute-control,.vjs-default-skin .vjs-volume-menu-button{cursor:pointer;float:right}.vjs-default-skin .vjs-mute-control:before,.vjs-default-skin .vjs-volume-menu-button:before{content:\"\\e006\"}.vjs-default-skin .vjs-mute-control.vjs-vol-0:before,.vjs-default-skin .vjs-volume-menu-button.vjs-vol-0:before{content:\"\\e003\"}.vjs-default-skin .vjs-mute-control.vjs-vol-1:before,.vjs-default-skin .vjs-volume-menu-button.vjs-vol-1:before{content:\"\\e004\"}.vjs-default-skin .vjs-mute-control.vjs-vol-2:before,.vjs-default-skin .vjs-volume-menu-button.vjs-vol-2:before{content:\"\\e005\"}.vjs-default-skin .vjs-volume-control{width:5em;float:right}.vjs-default-skin .vjs-volume-bar{width:5em;height:.6em;margin:1.1em auto 0}.vjs-default-skin .vjs-volume-level{position:absolute;top:0;left:0;height:.5em;width:100%;background:#66A8CC url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC) -50% 0 repeat}.vjs-default-skin .vjs-volume-bar .vjs-volume-handle{width:.5em;height:.5em;left:4.5em}.vjs-default-skin .vjs-volume-handle:before{font-size:.9em;top:-0.2em;left:-0.2em;width:1em;height:1em}.vjs-default-skin .vjs-volume-menu-button .vjs-menu{display:block;width:0;height:0;border-top-color:transparent}.vjs-default-skin .vjs-volume-menu-button .vjs-menu .vjs-menu-content{height:0;width:0}.vjs-default-skin .vjs-volume-menu-button:hover .vjs-menu,.vjs-default-skin .vjs-volume-menu-button .vjs-menu.vjs-lock-showing{border-top-color:rgba(7,40,50,0.5)}.vjs-default-skin .vjs-volume-menu-button:hover .vjs-menu .vjs-menu-content,.vjs-default-skin .vjs-volume-menu-button .vjs-menu.vjs-lock-showing .vjs-menu-content{height:2.9em;width:10em}.vjs-default-skin .vjs-progress-control{position:absolute;left:0;right:0;width:auto;font-size:.3em;height:1em;top:-1em;-webkit-transition:all .4s;-moz-transition:all .4s;-o-transition:all .4s;transition:all .4s}.vjs-default-skin:hover .vjs-progress-control{font-size:.9em;-webkit-transition:all .2s;-moz-transition:all .2s;-o-transition:all .2s;transition:all .2s}.vjs-default-skin .vjs-progress-holder{height:100%}.vjs-default-skin .vjs-progress-holder .vjs-play-progress,.vjs-default-skin .vjs-progress-holder .vjs-load-progress,.vjs-default-skin .vjs-progress-holder .vjs-load-progress div{position:absolute;display:block;height:100%;margin:0;padding:0;width:0;left:0;top:0}.vjs-default-skin .vjs-play-progress{background:#66A8CC url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGCAYAAADgzO9IAAAAP0lEQVQIHWWMAQoAIAgDR/QJ/Ub//04+w7ZICBwcOg5FZi5iBB82AGzixEglJrd4TVK5XUJpskSTEvpdFzX9AB2pGziSQcvAAAAAAElFTkSuQmCC) -50% 0 repeat}.vjs-default-skin .vjs-load-progress{background:#646464;background:rgba(255,255,255,0.2)}.vjs-default-skin .vjs-load-progress div{background:#787878;background:rgba(255,255,255,0.1)}.vjs-default-skin .vjs-seek-handle{width:1.5em;height:100%}.vjs-default-skin .vjs-seek-handle:before{padding-top:.1em}.vjs-default-skin.vjs-live .vjs-time-controls,.vjs-default-skin.vjs-live .vjs-time-divider,.vjs-default-skin.vjs-live .vjs-progress-control{display:none}.vjs-default-skin.vjs-live .vjs-live-display{display:block}.vjs-default-skin .vjs-live-display{display:none;font-size:1em;line-height:3em}.vjs-default-skin .vjs-time-controls{font-size:1em;line-height:3em}.vjs-default-skin .vjs-current-time{float:left}.vjs-default-skin .vjs-duration{float:left}.vjs-default-skin .vjs-remaining-time{display:none;float:left}.vjs-time-divider{float:left;line-height:3em}.vjs-default-skin .vjs-fullscreen-control{width:3.8em;cursor:pointer;float:right}.vjs-default-skin .vjs-fullscreen-control:before{content:\"\\e000\"}.vjs-default-skin.vjs-fullscreen .vjs-fullscreen-control:before{content:\"\\e00b\"}.vjs-default-skin .vjs-big-play-button{left:.5em;top:.5em;font-size:3em;display:block;z-index:2;position:absolute;width:4em;height:2.6em;text-align:center;vertical-align:middle;cursor:pointer;opacity:1;background-color:#07141E;background-color:rgba(7,20,30,0.7);border:.1em solid #3b4249;-webkit-border-radius:.8em;-moz-border-radius:.8em;border-radius:.8em;-webkit-box-shadow:0 0 1em rgba(255,255,255,0.25);-moz-box-shadow:0 0 1em rgba(255,255,255,0.25);box-shadow:0 0 1em rgba(255,255,255,0.25);-webkit-transition:all .4s;-moz-transition:all .4s;-o-transition:all .4s;transition:all .4s}.vjs-default-skin.vjs-big-play-centered .vjs-big-play-button{left:50%;margin-left:-2.1em;top:50%;margin-top:-1.4em}.vjs-default-skin.vjs-controls-disabled .vjs-big-play-button{display:none}.vjs-default-skin.vjs-has-started .vjs-big-play-button{display:none}.vjs-default-skin.vjs-using-native-controls .vjs-big-play-button{display:none}.vjs-default-skin:hover .vjs-big-play-button,.vjs-default-skin .vjs-big-play-button:focus{outline:0;border-color:#fff;background-color:#505050;background-color:rgba(50,50,50,0.75);-webkit-box-shadow:0 0 3em #fff;-moz-box-shadow:0 0 3em #fff;box-shadow:0 0 3em #fff;-webkit-transition:all 0s;-moz-transition:all 0s;-o-transition:all 0s;transition:all 0s}.vjs-default-skin .vjs-big-play-button:before{content:\"\\e001\";font-family:VideoJS;line-height:2.6em;text-shadow:.05em .05em .1em #000;text-align:center;position:absolute;left:0;width:100%;height:100%}.vjs-error .vjs-big-play-button{display:none}.vjs-error-display{display:none}.vjs-error .vjs-error-display{display:block;position:absolute;left:0;top:0;width:100%;height:100%}.vjs-error .vjs-error-display:before{content:'X';font-family:Arial;font-size:4em;color:#666666;line-height:1;text-shadow:.05em .05em .1em #000;text-align:center;vertical-align:middle;position:absolute;left:0;top:50%;margin-top:-0.5em;width:100%}.vjs-error-display div{position:absolute;bottom:1em;right:0;left:0;font-size:1.4em;text-align:center;padding:3px;background:#000;background:rgba(0,0,0,0.5)}.vjs-error-display a,.vjs-error-display a:visited{color:#F4A460}.vjs-loading-spinner{display:none;position:absolute;top:50%;left:50%;font-size:4em;line-height:1;width:1em;height:1em;margin-left:-0.5em;margin-top:-0.5em;opacity:.75}.vjs-waiting .vjs-loading-spinner,.vjs-seeking .vjs-loading-spinner{display:block;-webkit-animation:spin 1.5s infinite linear;-moz-animation:spin 1.5s infinite linear;-o-animation:spin 1.5s infinite linear;animation:spin 1.5s infinite linear}.vjs-error .vjs-loading-spinner{display:none;-webkit-animation:none;-moz-animation:none;-o-animation:none;animation:none}.vjs-default-skin .vjs-loading-spinner:before{content:\"\\e01e\";font-family:VideoJS;position:absolute;top:0;left:0;width:1em;height:1em;text-align:center;text-shadow:0 0 .1em #000}@-moz-keyframes spin{0%{-moz-transform:rotate(0deg)}100%{-moz-transform:rotate(359deg)}}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg)}}@-o-keyframes spin{0%{-o-transform:rotate(0deg)}100%{-o-transform:rotate(359deg)}}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(359deg)}}.vjs-default-skin .vjs-menu-button{float:right;cursor:pointer}.vjs-default-skin .vjs-menu{display:none;position:absolute;bottom:0;left:0;width:0;height:0;margin-bottom:3em;border-left:2em solid transparent;border-right:2em solid transparent;border-top:1.55em solid #000;border-top-color:rgba(7,40,50,0.5)}.vjs-default-skin .vjs-menu-button .vjs-menu .vjs-menu-content{display:block;padding:0;margin:0;position:absolute;width:10em;bottom:1.5em;max-height:15em;overflow:auto;left:-5em;background-color:#07141E;background-color:rgba(7,20,30,0.7);-webkit-box-shadow:-0.2em -0.2em .3em rgba(255,255,255,0.2);-moz-box-shadow:-0.2em -0.2em .3em rgba(255,255,255,0.2);box-shadow:-0.2em -0.2em .3em rgba(255,255,255,0.2)}.vjs-default-skin .vjs-menu-button:hover .vjs-control-content .vjs-menu,.vjs-default-skin .vjs-control-content .vjs-menu.vjs-lock-showing{display:block}.vjs-default-skin.vjs-scrubbing .vjs-menu-button:hover .vjs-control-content .vjs-menu{display:none}.vjs-default-skin .vjs-menu-button ul li{list-style:none;margin:0;padding:.3em 0 .3em 0;line-height:1.4em;font-size:1.2em;text-align:center;text-transform:lowercase}.vjs-default-skin .vjs-menu-button ul li.vjs-selected{background-color:#000}.vjs-default-skin .vjs-menu-button ul li:focus,.vjs-default-skin .vjs-menu-button ul li:hover,.vjs-default-skin .vjs-menu-button ul li.vjs-selected:focus,.vjs-default-skin .vjs-menu-button ul li.vjs-selected:hover{outline:0;color:#111;background-color:#fff;background-color:rgba(255,255,255,0.75);-webkit-box-shadow:0 0 1em #fff;-moz-box-shadow:0 0 1em #fff;box-shadow:0 0 1em #fff}.vjs-default-skin .vjs-menu-button ul li.vjs-menu-title{text-align:center;text-transform:uppercase;font-size:1em;line-height:2em;padding:0;margin:0 0 .3em 0;font-weight:bold;cursor:default}.vjs-default-skin .vjs-subtitles-button:before{content:\"\\e00c\"}.vjs-default-skin .vjs-captions-button:before{content:\"\\e008\"}.vjs-default-skin .vjs-chapters-button:before{content:\"\\e00c\"}.vjs-default-skin .vjs-chapters-button.vjs-menu-button .vjs-menu .vjs-menu-content{width:24em;left:-12em}.vjs-default-skin .vjs-captions-button:focus .vjs-control-content:before,.vjs-default-skin .vjs-captions-button:hover .vjs-control-content:before{-webkit-box-shadow:0 0 1em #fff;-moz-box-shadow:0 0 1em #fff;box-shadow:0 0 1em #fff}.video-js{background-color:#000;position:relative;padding:0;font-size:10px;vertical-align:middle;font-weight:normal;font-style:normal;font-family:Arial,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.video-js .vjs-tech{position:absolute;top:0;left:0;width:100%;height:100%}.video-js:-moz-full-screen{position:absolute}body.vjs-full-window{padding:0;margin:0;height:100%;overflow-y:auto}.video-js.vjs-fullscreen{position:fixed;overflow:hidden;z-index:1000;left:0;top:0;bottom:0;right:0;width:100% !important;height:100% !important;_position:absolute}.video-js:-webkit-full-screen{width:100% !important;height:100% !important}.video-js.vjs-fullscreen.vjs-user-inactive{cursor:none}.vjs-poster{background-repeat:no-repeat;background-position:50% 50%;background-size:contain;background-color:#000000;cursor:pointer;margin:0;padding:0;position:absolute;top:0;right:0;bottom:0;left:0}.vjs-poster img{display:block;margin:0 auto;max-height:100%;padding:0;width:100%}.video-js.vjs-has-started .vjs-poster{display:none}.video-js.vjs-audio.vjs-has-started .vjs-poster{display:block}.video-js.vjs-controls-disabled .vjs-poster{display:none}.video-js.vjs-using-native-controls .vjs-poster{display:none}.video-js .vjs-text-track-display{position:absolute;top:0;left:0;bottom:3em;right:0;pointer-events:none}.vjs-caption-settings{position:relative;top:1em;background-color:#000;opacity:.75;color:#FFF;margin:0 auto;padding:.5em;height:15em;font-family:Arial,Helvetica,sans-serif;font-size:12px;width:40em}.vjs-caption-settings .vjs-tracksettings{top:0;bottom:2em;left:0;right:0;position:absolute;overflow:auto}.vjs-caption-settings .vjs-tracksettings-colors,.vjs-caption-settings .vjs-tracksettings-font{float:left}.vjs-caption-settings .vjs-tracksettings-colors:after,.vjs-caption-settings .vjs-tracksettings-font:after,.vjs-caption-settings .vjs-tracksettings-controls:after{clear:both}.vjs-caption-settings .vjs-tracksettings-controls{position:absolute;bottom:1em;right:1em}.vjs-caption-settings .vjs-tracksetting{margin:5px;padding:3px;min-height:40px}.vjs-caption-settings .vjs-tracksetting label{display:block;width:100px;margin-bottom:5px}.vjs-caption-settings .vjs-tracksetting span{display:inline;margin-left:5px}.vjs-caption-settings .vjs-tracksetting>div{margin-bottom:5px;min-height:20px}.vjs-caption-settings .vjs-tracksetting>div:last-child{margin-bottom:0;padding-bottom:0;min-height:0}.vjs-caption-settings label>input{margin-right:10px}.vjs-caption-settings input[type=\"button\"]{width:40px;height:40px}.vjs-hidden{display:none !important}.vjs-lock-showing{display:block !important;opacity:1;visibility:visible}.vjs-no-js{padding:2em;color:#ccc;background-color:#333;font-size:1.8em;font-family:Arial,sans-serif;text-align:center;width:30em;height:15em;margin:0 auto}.vjs-no-js a,.vjs-no-js a:visited{color:#F4A460}"

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Appnexus Viewability Wrapper for core video framework
	 */

	var ANVideoViewabilityTracker = __webpack_require__(26);//appnexus viewability library
	var prefixOfLog = "[PlayerManager_ANVideoViewabilityTracker]";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	var info = function (message) {
	    APN_Logger.info(prefixOfLog, message);
	};

	var html5VideoViewability = function () {

	    var tracker = null;
	    var mappedActions = {
	        "video_start": "start",
	        "expand": "expand",
	        "collapse": "collapse",
	        "video_unmute": "sound_on",
	        "video_mute": "sound_off",
	        "video_pause": "pause",
	        "video_resume": "resume",
	        "ad-click": "click",
	        "video_skip": "stop",
	        "video_complete": "stop",
	        "fullscreen": "fullscreen",
	        "exitFullscreen": "exitFullscreen",
	    };

	    var getConfig = function (options_) {
	        return options_ && options_.viewability && options_.viewability.config;
	    };

	    var getPlayerDOMElement = function (options_) {
	        return options_.targetElement;
	    };

	    var getVideoInfo = function (duration, width, height) {
	        return {duration: duration, w: width, h: height};
	    };

		// return a string that reflect the context in which the viewability is executed
		// Setting this value will make the viewability measurement active only if the
		// viewability config contains a vid_context key matching a known value
	    // (anoutstream for outstream).
		var getContext = function (options_) {
	        if( options_ ){
			return options_.playerContextId;
	        }
	    };

		// Using callback for logs helps getting a right logger in each app
		var loggerCallback = function (_level, _message) {
			if (_level && _level === "debug") {
				debug(_message);
			} else {
				info(_message);
			}
	    };

	    this.init = function (options_, duration, width, height) {
	        info("initialize");
	        debug("duration: " + duration + ", width: " + width + ", height: " + height);
	        try {
	            tracker = new ANVideoViewabilityTracker(
					getConfig(options_),
	                getPlayerDOMElement(options_),
	                getVideoInfo(duration, width, height), // The duration of the video ad
					getContext(options_),
					loggerCallback
	            );
	            this.isReady = true;
	        } catch (ex) {
	            debug("error on viewability library: ");
	            debug(ex);
	        }

	    };

	    this.invokeEvent = function (event_) {
	        if (event_ && mappedActions[event_]) {
	            try {
	                info("event invoked by viewability library: " + mappedActions[event_]);
	                tracker.notifyEvent(mappedActions[event_]);
	            } catch (ex) {
	                debug("error on viewability library: ");
	                debug(ex);
	            }
	        }
	    };

	    this.isReady = false;


	};


	module.exports = html5VideoViewability;

/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * @namespace ANVideoViewabilityTracker
	 */

	/**
	 * Video Viewability module - Acts as a proxy the CDN based viewability script
	 * @param {string} _viewabilityPayload   the string containing all viewability parameters
	 * @param {string} _domElt the ID of the object to measure
	 * @param {Object} _videoInfos the object containing video attributes
	 * @param {string} _contextKey an optional config. If set, it will be compared to the value provided in the _viewabilityPayload, and avoid measurement if not equals. ex: outstream
	 * @type {loggerCallback} _logger an optional logger with prototype function(level = info|debug|error, message)
	 */
	var ANVideoViewabilityTracker = function (_viewabilityPayload, _domElt, _videoInfos, _contextKey, _loggerCallback) {
		"use strict";

		this.contextKey = _contextKey;
		if (_loggerCallback) {
			this.loggerCallback = _loggerCallback;
		}

		this.adUID = "WR_" + new Date().getTime() + Math.round(Math.random() * 1000);

		// result of contextKey matching, disable any viewability measurement feature if false
		this.viewabilityMeasurementActive = true;

		// Get object with Viewability Payload
		this.viewabilityData = this.decodePayload(_viewabilityPayload);

		if (!this.viewabilityData) {
			this.log("error", "No viewability data provided");
			this.viewabilityMeasurementActive = false;
			return;
		}

		// Check if contextKey is set
		if (this.contextKey && this.contextKey !== "") {
			// Check if a contextKey is provided in the viewability paylaod
			// Considering the viewability config can contain multiple values in the the contextKey, ex: outstream|overlay
			this.log("info", "contextKey is set in this app, checking contextKey in viewability config");

			if (!this.viewabilityData.hasOwnProperty("contextKey") || this.viewabilityData.contextKey.indexOf(this.contextKey) === -1) {
				// contextKey doesn't match, viewability measurement is disabled
				this.log("info", "contextKey doesn't mach, disabling viewability measurement");
				this.viewabilityMeasurementActive = false;
				return;
			}
		}

		// identify document and window of the iframe where the script must be installed
		// get the id of the dom element to analyse (entry could be the id or a dom element)
		var domId = "";
		try {
			if (typeof _domElt === "object") {
				// try to get document form domElt first, if fail, no id will be set
				this.videoNodeDocument = _domElt.ownerDocument;
				this.videoNodeWindow = this.videoNodeDocument.defaultView || this.videoNodeDocument.videoNodeWindow;

				// if dom Element haven't id, set a default
				if (_domElt.id === "") {
					_domElt.id = "an_video_" + this.adUID;
				}
				domId = _domElt.id;
			} else {
				domId = _domElt;
				this.videoNodeDocument = document;
				this.videoNodeWindow = window;
			}
		} catch (e) {
			this.videoNodeDocument = document;
			this.videoNodeWindow = window;
		}

		// Get object containing duration, dimension and position
		this.videoInfo = this.decodeVideoInfos(_videoInfos);

		this.log("info", "ANVideoViewabilityTracker start with parameters  \n" +
			"DomID:\t\t[" + domId + "]\n" +
			"adUID:\t\t[" + this.adUID + "]\n" +
			"Duration:\t[" + this.videoInfo.duration + "]\n" +
			"Payload:\t" + _viewabilityPayload + "\n\n" +
			"Dimension:\t(" + this.videoInfo.w + "," + this.videoInfo.h + ")\n" +
			"Position:\t(" + this.videoInfo.x + "," + this.videoInfo.y + ")"
		);

		try {
			// Create temporary cache, used to store API calls until the viewability script is loaded
			if (typeof this.videoNodeWindow.anxVVAPICache === 'undefined') {
				this.videoNodeWindow.anxVVAPICache = {
					events: Array(),
					init: Array()
				};

				// Injects the viewability script in the page
				var scriptElement = this.videoNodeDocument.createElement('script');
				scriptElement.type = 'text/javascript';
				scriptElement.async = true;
				scriptElement.src = this.viewabilityData.vjs;
				var head = this.videoNodeDocument.getElementsByTagName("head")[0];
				head.appendChild(scriptElement);
			}
		} catch (e) {
			this.log("error", { message: "ANVideoViewabilityTracker initialization failed", exception: e });
		}

		// Init module version
		this.extractVersionModule(this.viewabilityData);

		// Initialize Viewability Script if present, cache informations if not
		if (typeof this.videoNodeWindow.anxVVAPI === 'undefined') {
			var createCall = {
				a: this.adUID,
				params: this.viewabilityData.viewParams,
				id: domId,
				v: this.VIEWABILITY_MODULE_VERSION,
				dur: this.videoInfo.duration,
				// Considering the video size is the player size :
				w: this.videoInfo.w,
				h: this.videoInfo.h,
				x: this.videoInfo.x,
				y: this.videoInfo.y
			};
			this.videoNodeWindow.anxVVAPICache.init.push(createCall);
		} else {
			this.videoNodeWindow.anxVVAPI.initializeFromParams(
				this.viewabilityData.viewParams,
				domId,
				this.adUID,
				this.VIEWABILITY_MODULE_VERSION,
				this.videoInfo.duration,
				this.videoInfo.w,
				this.videoInfo.h,
				this.videoInfo.x,
				this.videoInfo.y
			);
		}
	};



	ANVideoViewabilityTracker.prototype = {
		// This module version
		VIEWABILITY_MODULE_VERSION: 1,
		// Default logger is empty
		loggerCallback: null,
		log: function (_level, _message) {

			if (this.loggerCallback) {
				try {
					this.loggerCallback(_level, _message);
				} catch (e) {
					// logging is disabled
				}
			}
		},
		//Sound Tracking
		lastKnownVolume: -1,

		// Internal parsing
		parseUrl: function (_url) {
			"use strict";

			var urlObject = {
				http: "",
				params: ""
			};

			try {
				if (_url && typeof _url === "string") {
					var split = _url.split(/:/);
					if (split.length === 2) {
						_url = split[1];
						urlObject.http = split[0];
					}

					split = _url.split(/\?/);
					if (split.length === 2) {
						urlObject.params = split[1];
					} else if ((urlObject.http === "" || _url.substr(0, 2) !== "//") && _url.indexOf("=") > -1) {
						urlObject.params = split[0];
					}

					if (urlObject.params !== "") {
						split = urlObject.params.split(/&/);
						urlObject.params = {};
						for (var param in split) {
							// get parameter name and value
							var keyValue = split[param].split(/=/);
							if (keyValue.length === 2) {
								urlObject.params[keyValue[0]] = decodeURIComponent(keyValue[1]);
							} else if (keyValue.length > 2) {
								var value = "";
								for (var i = 1; i < keyValue.length; i++) {
									value += "=" + keyValue[i];
								}

								urlObject.params[keyValue[0]] = decodeURIComponent(value.substr(1));
							} else {
								urlObject.params[keyValue[0]] = "";
							}
						}
					}
				}
			} catch (ex) {
				this.log("debug", ex);
			}

			return urlObject;
		},

		// Internal parsing
		parseConfigs: function (_url) {
			"use strict";
			try {
				if (_url && typeof _url === "string") {
					if (_url.substring(0, 9) === "<![CDATA[") {
						_url = _url.substring(9, _url.length - 3);
					}
					var extracted = this.parseUrl(_url);

					if (extracted.hasOwnProperty("params") && extracted.params !== "") {
						return extracted.params;
					}
				}
			} catch (ex) {
				this.log("debug", ex);
			}
			// Return empty object
			return {};
		},

		// Internal parsing
		createViewabilityConfig: function (_payload) {

			var params = [];

			for (var key in _payload) {
				var value = _payload[key];

				// Possible values for vc:
				// vc=iab
				// vc=iab;cid=1
				// vc=iab;cid=1;samp=100
				// this will become : vc=iab&cid=1&samp=100
				if (key == "vc") {
					var split = value.split(/;/);
					params.push("vc=" + encodeURIComponent(split[0]));

					for (var i = 1; i < split.length; i++) {
						params.push(split[i]);
					}
					continue;
				}

				params.push(key + "=" + encodeURIComponent(value));
			}
			params.sort();

			return params.join("&");
		},


		/**
		 * Decode data string received from the viewability API
		 * @param {string} _payload the string formated viewability config
		 * @returns {Object} validated object with configs
		 */

		decodePayload: function (_payload) {
			"use strict";

			// Object
			var config = this.parseConfigs(_payload);

			var decodedPayload = {
				viewParams: this.createViewabilityConfig(config)
			};

			if (config.hasOwnProperty("vjs")) {
				decodedPayload.vjs = config.vjs;
			} else {
				this.log("error", "no viewability script js to load");
				return null;
			}

			if (config.hasOwnProperty("vid_context")) {
				decodedPayload.contextKey = config.vid_context;
			}

			return decodedPayload;

		},

		/**
		 * Extract Ad informations (duration, dimensions and positions)
		 * @param _videoInfos {Object} the oject containing video attributes
		 */
		decodeVideoInfos: function (_videoInfos) {
			"use strict";
			var ad = { duration: 0, w: 0, h: 0, x: 0, y: 0 };

			if (typeof _videoInfos.duration === "number" || _videoInfos.duration > 0) {
				ad.duration = _videoInfos.duration;
			}
			if (typeof _videoInfos.w === "number" || _videoInfos.w > 0) {
				ad.w = _videoInfos.w;
			}
			if (typeof _videoInfos.h === "number" || _videoInfos.h > 0) {
				ad.h = _videoInfos.h;
			}
			if (typeof _videoInfos.x === "number" || _videoInfos.x > 0) {
				ad.x = _videoInfos.x;
			}
			if (typeof _videoInfos.y === "number" || _videoInfos.y > 0) {
				ad.y = _videoInfos.y;
			}

			return ad;
		},

		// Extract module version from viewability script url
		extractVersionModule: function (_viewData) {
			"use strict";


			if (_viewData) {
				var regex = /.+\/(\d+)\/trk\.js/;
				var match = regex.exec(_viewData.viewJS);
				if (match && match[1]) {
					this.VIEWABILITY_MODULE_VERSION = match[1];
				}
			}
		},

		//
		/**
		 * Pass video events to the viewability JS
		 * @param {string} _eventCode the name of the event. <br>
		 * Expected values : <br>
		 * start<br>
		 * stop<br>
		 * pause<br>
		 * resume<br>
		 * fullscreen<br>
		 * exitFullscreen<br>
		 * click<br>
		 */
		notifyEvent: function (_eventCode) {
			"use strict";

			// Avoid any action if viewability is disabled in the config
			if (!this.viewabilityMeasurementActive) {
				this.log("info", "notifyEvent cancelled because viewability is not active");
				return;
			}

			this.log("info", "notifyEvent: [" + _eventCode + "]");

			// expand and collapse event reserved for Outstream video tag resize, not used by viewJS script
			// fullscreen and exitFullscreen be used instead to notify fullscreen activity to viewJS. These event are known as expand and collapse by viewJS
			switch (_eventCode) {
			case "fullscreen":
				_eventCode = "expand";
				break;
			case "exitFullscreen":
				_eventCode = "collapse";
				break;

				// VIDKP-701 - Avoid conflicts with Outstream
			case "expand":
			case "collapse":
				return;
			}

			var timeData = new Date().getTime();
			try {
				if (typeof this.videoNodeWindow.anxVVAPI === 'undefined') {
					var createCall = {
						a: this.adUID,
						c: _eventCode,
						d: timeData
					};
					this.videoNodeWindow.anxVVAPICache.events.push(createCall);
				} else {
					this.videoNodeWindow.anxVVAPI.notifyEvent(this.adUID, _eventCode);
				}
			} catch (e) {
				this.log("debug", { message: "notifyEvent failed", exception: e });
			}
		},

		/**
		 * Update volume state and notify event when volume changed
		 * @param {Number} _volume the volume between 0 and 1
		 */
		onVolumeChange: function (_volume) {
			"use strict";

			// Avoid any action if viewability is disabled in the config
			if (!this.viewabilityMeasurementActive) {
				this.log("info", "onVolumeChange cancelled because viewability is not active");
				return;
			}

			if (typeof _volume !== "number") {
				return;
			}

			if (_volume > 1) {
				_volume = 1;
			}

			if (_volume < 0) {
				_volume = 0;
			}

			if (_volume !== this.lastKnownVolume) {
				if (_volume > 0) {
					this.notifyEvent("sound_on");
				} else {
					this.notifyEvent("sound_off");
				}

				this.lastKnownVolume = _volume;
			}
		}
	};

	module.exports = ANVideoViewabilityTracker;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Autoplay Handler
	 * this module supports an auto-play feature to get over limitations on mobile devices
	 *
	 * architecture diagram for this mdule : https://appnexus.slack.com/files/ksong/F3H5U82HX/androidautoplayforoutstream.pdf
	 */


	var APN_MOBILE_VIDEO_PLACEMENT_ID = "apn_mobile_video_placements";//video placement id in iframes which will be used on core video framework
	var APN_MOBILE_IFRAME_NAME_PREFIX = "iframeVideoWrapper";//prefix of iframe names which will be used on core video framework
	var BLANK_VIDEO_URL = "http://acdn.adnxs.com/video/static/res/b2.mp4";//2 seconds 70x70 empty video to resolve human activity for VID-1924,VID-1907,VID-1980

	var prefixOfLog = "[AutoplayHandler]";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	var error = function (message) {
	    APN_Logger.error(prefixOfLog, message);
	};
	var warn = function (message) {
	    APN_Logger.warn(prefixOfLog, message);
	};
	var info = function (message) {
	    APN_Logger.info(prefixOfLog, message);
	};

	var hasDoneFakingAutoStartForAndroid = false;//flag to block second execution

	/**
	 * get iOSversion as array [major,minor,build] if it's not proper mobile safari it will returen [0,0,0]
	 * this also check iOS Chrome
	 * @returns {*}
	 */
	var iOSversion = function () {
	    var browser = "safari";
	    try {
	        var platform = navigator.platform;
	        var agent = navigator.userAgent;
	        var appVersion = navigator.appVersion;

	        if (/CriOS/.test(agent)) {
	            //do nothing, we decided to allow to use inline for iOS Chrome by VID-1464
	            browser = "chrome";
	        }
	        if (/iP(hone|od|ad)/.test(platform)) {
	            var v = (appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);//chrome and safari both has iOS version in the user agent string (especially in appVersion)
	            return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10), browser];
	        } else {
	            return [0, 0, 0, browser];//return this value when it's not iOS and Mobile Safari browser
	        }
	    } catch (ex) {
	        error(ex);
	        return [0, 0, 0, browser];//return [0,0,0] if any error happens;
	    }
	};

	/**
	 * check iOS incliding phone and pad
	 * @returns {boolean}
	 */
	var isIOS = function () {
	    return (/iphone/i.test(navigator.userAgent.toLowerCase())) || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	};

	/**
	 * retrieve version number of iOS Chrome
	 * @returns {number}
	 */
	var getiOSChromeVersion = function () {
	    var version = -1;
	    if (isIOS()) {
	        try {
	            var tmp = navigator.userAgent.match(/CriOS\/([0-9]+)\./);
	            if (tmp && Array.isArray(tmp) && tmp.length > 1) {
	                version = Number.parseInt(tmp[1]);
	            }
	        } catch (ex) {
	            debug(ex);
	        }
	    }
	    return version;
	};

	/**
	 * detection logic if ad unit requires human activity to initiate adunit itself.
	 * a combination of iOS10 and Chrome53 has a bug on their application which is not dispatching "loadedmetada" event from generic html5 event
	 * @returns {boolean}
	 */
	var doesBrowserNeedUserActionToPlayVideo = function () {//for https://jira.corp.appnexus.com/browse/VID-2557
	    var result = iOSversion();
	    if (result && Array.isArray(result) && result.length >= 4) {
	        var majoriOSVersion = result[0];
	        var kindOfBrowser = result[3];
	        if (kindOfBrowser === "chrome" && majoriOSVersion === 10 && getiOSChromeVersion() === 53) {
	            return true;
	        } else {
	            return false;
	        }
	    }
	};

	/**
	 * This method will create empty video placement and play it to resolve initial playback by human activity
	 * It's required for breaking iOS and Android limitation which is not playing video automatically
	 * @param targetWindow
	 */
	var prepareVideoPlacementsForMobile = function (iframes, type, callback, targetElementId) {

	    var totalStepsForWaterfall = iframes.length;//waterfall will have mutiple iframes to prepare independent execution area for each of waterfall steps
	    var totalCountsOfResolvedHumanActivity = 0;

	    /**
	     * final steps and execute callback of ad unit entry point.
	     *
	     * @param _type
	     */
	    var doFinalSteps = function (_type) {
	        if (totalCountsOfResolvedHumanActivity === totalStepsForWaterfall) {//if this step is last and all steps resolved human activity
	            //proceed AdUnit to start expanding
	            if (typeof(callback) === "function") {
	                hasDoneFakingAutoStartForAndroid = true;
	                warn("set hasDoneFakingAutoStartForAndroid = true by " + _type);
	                callback();
	            }
	        }
	    };

	    /**
	     * store a video placement which is successfully resolved human activiy.
	     *
	     * @param videoPlacement
	     * @param _type
	     * @param targetWindow
	     */
	    var storeResolvedVideo = function (videoPlacement, _type, targetWindow) {
	        if (hasDoneFakingAutoStartForAndroid) {
	            return;
	        }
	        warn("successfully performed autoplay trick by " + _type);
	        targetWindow[APN_MOBILE_VIDEO_PLACEMENT_ID] = videoPlacement;
	        totalCountsOfResolvedHumanActivity++;
	        doFinalSteps(_type);
	    };

	    /**
	     * remove failed iframe to avoid confusion
	     *
	     * @param _iframe
	     * @param index
	     * @param _type
	     */
	    var removeFailedIFrames = function (_iframe, index, _type) {
	        warn("removing failed iframe #" + (index + 1) + " by " + _type);
	        document.getElementById(targetElementId).removeChild(_iframe);
	    };

	    /**
	     * test video play promise to decide which user activity is effective for resolving human activity
	     *
	     * @param _iframe
	     * @param _index
	     * @param _type
	     */
	    var createEmptyVideoPlacementAndTest = function (_iframe, _index, _type) {
	        try {
	            var targetWindow = _iframe.contentWindow;
	            if (!targetWindow[APN_MOBILE_VIDEO_PLACEMENT_ID]) {
	                var videoPlacement;
	                var playPromise;
	                videoPlacement = targetWindow.document.createElement("video");
	                targetWindow.document.body.appendChild(videoPlacement);
	                videoPlacement.src = BLANK_VIDEO_URL;
	                playPromise = videoPlacement.play();
	                videoPlacement.pause();// VID-1726 Chrome issue for Android playback, When load is interrupting in play state Android Chrome sometimes is not showing video
	                //Android Modern Chrome (+50) returns promise object by invoking play() method to handle asyncnorouse action - https://developers.google.com/web/updates/2016/03/play-returns-promise
	                if (playPromise !== undefined) {
	                    playPromise.then(function () {
	                        debug("video promise done successfully by " + _type);
	                        totalCountsOfResolvedHumanActivity++;
	                        doFinalSteps("promise done");
	                    }).catch(function (error) {
	                        var returnedError = {
	                            "code": error.code,
	                            "name": error.name,
	                            "message": error.message
	                        };
	                        //TODO unit test to reproduce when touch-start doesn't work
	                        // if (_type === "touchstart") {
	                        //     returnedError.code = 0;
	                        //     returnedError.name = "testing";
	                        //     returnedError.message = "testing";
	                        // }

	                        //TODO unit test to reproduce when touch-start doesn't work
	                        // if (_type === "touchend") {
	                        //     returnedError.code = 0;
	                        //     returnedError.name = "testing";
	                        //     returnedError.message = "testing";
	                        // }

	                        //TODO unit test to reproduce when all event doesn't work (For fallback play)
	                        // returnedError.code = 0;
	                        // returnedError.name = "testing";
	                        // returnedError.message = "testing";

	                        if (returnedError.code === 0) {//handle not acceptable error case we have to do fallback, at the time, code : 0, name : Not Allowed, message : Failed to execute 'play' on 'HTMLMediaElement': API can only be initiated by a user gesture.
	                            warn("playback failed : " + returnedError.code + "," + returnedError.name + "," + returnedError.message + " by " + _type);
	                            removeFailedIFrames(_iframe, _index, _type);//remove iframes of touchstart to give "touchend" opportunity which is next order of this execution
	                        } else {
	                            //handle accetable error like abort playing
	                            warn("waterfall steps #" + (Number(totalCountsOfResolvedHumanActivity) + 1) + " by " + _type + " : autoplay trick's possible due to video promise be caught with " + error.name);
	                            storeResolvedVideo(videoPlacement, _type, targetWindow);
	                        }
	                    });
	                }
	            }
	        } catch (ex) {
	            debug(ex);
	        }

	    };

	    //start point
	    iframes.forEach(function (_iframe, _index) {
	        createEmptyVideoPlacementAndTest(_iframe, _index, type);
	    });

	};

	/**
	 * check to see if it's mobile device including iOS and Android
	 *
	 * @returns {boolean}
	 */
	var isMobile = function () {
	    var index = navigator.appVersion.indexOf("Mobile");
	    var indexForAndroid = navigator.appVersion.indexOf("Android");
	    return (index > -1) || (indexForAndroid > -1);
	};

	/**
	 * check to see if it's android device
	 *
	 * @returns {boolean}
	 */
	var isAndroid = function () {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	};


	/**
	 * retireve android Chrome version
	 *
	 * @returns {number}
	 */
	var getChromeVersion = function () {
	    var version = -1;
	    if (isAndroid()) {
	        try {
	            var tmp = navigator.userAgent.match(/Chrome\/([0-9]+)\./);
	            if (tmp && Array.isArray(tmp) && tmp.length > 1) {
	                version = Number.parseInt(tmp[1]);
	            }
	        } catch (ex) {
	            debug(ex);
	        }
	    }
	    return version;
	};

	/**
	 * check to see whether human actitivy is required for autoplaying or not.
	 *
	 * @param initialPlayback
	 * @param initialAudio
	 * @param automatedTestingOnlyAndroidSkipTouchStart
	 * @param dataSaverEnabled : result of data saver testing
	 * @returns {boolean}
	 */
	var isRequiredHumanInteractionForAutoPlayOnAndroid = function (initialPlayback, initialAudio, automatedTestingOnlyAndroidSkipTouchStart, dataSaverEnabled) {
	    // If "automatedTestingOnlyAndroidSkipTouchStart" flag in options is true don't require a touch to start on android,
	    // used to allow automated tests to run without requiring a human touch.

	    if (isAndroid() === false) {
	        return false;
	    }

	    var isAutoPlay = initialPlayback && (initialPlayback === "auto");
	    var isAudioOn = initialAudio && (initialAudio === "on");

	    // if (getChromeVersion() >= 56 ) {
	    //     return false;//since Chrome 56 beta, autoplay with user interaction will be blocked
	    // }

	    if (getChromeVersion() >= 53) {//Since Chrome53 Google allows autoplay with no-sound refers with https://corpwiki.appnexus.com/display/~ksong/Summarize+HTML5+Video+limitations+on+Mobile+devices
	        if (isAudioOn && isAutoPlay && !automatedTestingOnlyAndroidSkipTouchStart) {
	            return true;//require user action
	        } else {
	            //exception for DataSaver option in Android devices
	            if (isAutoPlay && dataSaverEnabled && !automatedTestingOnlyAndroidSkipTouchStart) {
	                return true;//for Chrome DataSaver option - it needs to have user action for autoplaying
	            }
	            return false;
	        }
	    }

	    if (getChromeVersion() <= 52) {
	        //for old version of Chrome
	        if (isAutoPlay && !automatedTestingOnlyAndroidSkipTouchStart) {
	            return true;//require user action
	        } else {
	            return false;
	        }
	    }


	};

	/**
	 * asyncTestDataSaverForAndroid
	 *
	 * If Data Saver turns on in Chrome, we have to rely on user event for autoplaying since Chrome 53
	 * This method will test that Chrome option by playing empty mute video and will work as async and final callback will be invoked in the end of steps to inform result
	 *
	 * @returns {boolean} callback(true): DataSaver is off, callback(false): DataSaver is on
	 */
	var asyncTestDataSaverForAndroid = function (callback) {
	    info("Start to detect Android Data Saver option in this device");
	    try {
	        var videoPlacement = window.document.createElement("video");

	        videoPlacement.src = BLANK_VIDEO_URL;
	        videoPlacement.muted = true;
	        document.body.appendChild(videoPlacement);

	        var playPromise;
	        playPromise = videoPlacement.play();

	        if (playPromise !== undefined) {
	            playPromise.then(function () {
	                info("Android Data Saver option isn't detected in this device");
	                callback(false);
	            }).catch(function () {
	                info("Android Data Saver option is detected in this device, so auto-play will be initiated by user's activity like touch");
	                callback(true);
	            });
	        }
	    } catch (ex) {
	        debug(ex);
	        info("failed to detect Android Data Saver option in this device, so auto-play will be initiated by user's activity like touch");
	        callback(true);
	    }
	};

	/**
	 * check ios inline required
	 *
	 * @param enableInlineVideoForIos
	 * @returns {*}
	 */
	var isIosInlineRequired = function (enableInlineVideoForIos) {
	    var result;
	    try {
	        result = (iOSversion()[0] >= 8 && enableInlineVideoForIos === true);//from iOS8, browser and webview supports a canvas trick to move currentTime of video even if it's not loaded by human's activirty
	    } catch (ex) {
	        error(ex);
	    }
	    return result;
	};

	/**
	 * create iframes to embed video element resolved human activity
	 *
	 * @param type
	 * @param callback
	 * @param waterfallSteps
	 * @param maxWaterfallIframes
	 * @param targetElementId
	 */
	var createAndroidIframes = function (type, callback, waterfallSteps, maxWaterfallIframes, targetElementId) {


	    if (hasDoneFakingAutoStartForAndroid) {
	        //debug("ignored a request to create iframes for Android autoplay by " + type + " due to it's already completed by other events");
	        return;
	    }
	    debug("create iframes for Android autoplay by " + type);
	    //calculate number of total placements
	    var steps = 1;
	    if (!waterfallSteps || waterfallSteps === -1) {
	        // if waterfall steps is set to infinite, then we will create maximum of 5 Android iframes
	        // for resolving Autoplay on android.
	        steps = maxWaterfallIframes;
	    } else {
	        steps = waterfallSteps + 1;
	    }
	    debug("total " + steps + " iframes will be made by waterfall structure with " + type + " event");
	    var iframes = [];
	    //loop to resolve all placements's video element
	    for (var i = 0; i < steps; i++) {
	        var name = "";
	        if (i === 0) {
	            name = APN_MOBILE_IFRAME_NAME_PREFIX;
	        } else {
	            name = APN_MOBILE_IFRAME_NAME_PREFIX + "_Waterfall_" + i;
	        }
	        var iframeVideoWrapper = document.createElement("iframe");
	        document.getElementById(targetElementId).appendChild(iframeVideoWrapper);

	        //generate body tag
	        //VIDLA-90 fix IAS viewability tracking issue to have proper Iframe.location.origin
	        //var defaultTemplate = "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body style=\"margin:0px;overflow:hidden;\">\n</body>\n</html>\n";
	        var defaultTemplate = "<html></html>";//fix VIDLA-320 to have null doctype like we did before - it means this is the same with not invoking .write("") like we did at the begining of this project


	        iframeVideoWrapper.contentWindow.document.open();
	        iframeVideoWrapper.contentWindow.document.write(defaultTemplate);
	        iframeVideoWrapper.contentWindow.document.close();

	        //set name
	        iframeVideoWrapper.name = name;
	        iframeVideoWrapper.style.display = "none";

	        debug("iframes injected for waterfall steps #" + (i + 1) + " by " + type);
	        iframes.push(iframeVideoWrapper);//keep it on array
	    }
	    //pass iframe array to a method
	    if (iframes && Array.isArray(iframes) && iframes.length >= 1 && type !=="general") {
	        prepareVideoPlacementsForMobile(iframes, type, callback, targetElementId);
	    } else {
	        if (typeof(callback) === "function") {
	            callback();
	        }
	    }
	};

	/**
	 * initialize and register callback for calling ad unit entry point
	 *
	 * @param param
	 */
	var initialize = function (param) {

	    //if any of error occurred param.callbackAdUnitEntryPoint() will be inboked, so param.callbackAdUnitEntryPoint is required field at least
	    try {
	        var targetElementId = param.targetElementId;
	        var windowForPublisher = param.windowForPublisher;
	        var callbackAdUnitOverridingAudioToOff = param.callbackAdUnitEntryPoint;
	        var callbackPatchForIOSChrome = param.callbackPatchForIOSChrome;
	        var waterfallSteps = param.waterfallSteps;
	        var maxWaterfallIframes = param.maxWaterfallIframes;
	        var initialPlayback = param.initialPlayback;
	        var initialAudio = param.initialAudio;
	        var automatedTestingOnlyAndroidSkipTouchStart = param.automatedTestingOnlyAndroidSkipTouchStart;
	        var androidDSOverride = param.androidDSOverride;

	        //nested function which will have variables propogated from parent function - don't move this outside, this structure is requried to do aysnc-video-autoplay-test
	        var autoplayDecisionCallback = function (dataSaverEnabled) {

	            //VIDLA-258 autoplay with sound-on and data-saver on will end up click-to-play on Chrome55 and androidDSOverride:false
	            if (androidDSOverride === false && dataSaverEnabled && getChromeVersion() <= 55 && initialAudio === "on" && initialPlayback === "auto") {
	                callbackAdUnitOverridingAudioToOff(false,true);//no override audio, override autoplay to click-to-play
	                return;
	            }
	            if (androidDSOverride === false) {
	                dataSaverEnabled = false;//regard data saver is disabled if androidDSOverride options is false and trust user's decision for saving network traffick
	            }

	            if (getChromeVersion() < 56 && isRequiredHumanInteractionForAutoPlayOnAndroid(initialPlayback, initialAudio, automatedTestingOnlyAndroidSkipTouchStart, dataSaverEnabled)) {
	                /////////////////////////////////////////////////////////////////////////////////
	                //when need to wait humain interaction, inject additional event listener to DOM
	                /////////////////////////////////////////////////////////////////////////////////

	                //only for android autostart - this will use Android auto-play trick to pre-resolve human activity
	                //callback when the trick finished
	                var resolveHumanTouch = function (type) {
	                    createAndroidIframes(type, function () {
	                        callbackAdUnitOverridingAudioToOff(false,false);//no override audio, no override autoplay, start expadning, invoke explicitPlay (vpaid startAd)
	                    }, waterfallSteps, maxWaterfallIframes, targetElementId);
	                };
	                windowForPublisher.addEventListener("touchstart", function () {
	                    resolveHumanTouch("touchstart");
	                }, {passive: true});//passive event will help to avoid race condition when both event happens at a time
	                windowForPublisher.addEventListener("touchend", function () {
	                    setTimeout(function () {
	                        resolveHumanTouch("touchend");
	                    }, 1);//to guaranty touchstart and touchend will be delived to a listener in order (touchstart first, touchend last)
	                }, {passive: true});//passive event will help to avoid race condition when both event happens at a time
	            } else {
	                /////////////////////////////////////////////////////////////////////////////////
	                //when no need to wait humain interaction
	                /////////////////////////////////////////////////////////////////////////////////

	                var shouldOverrideAudioToOff = (getChromeVersion() >= 56 && initialAudio === "on" && initialPlayback === "auto" && dataSaverEnabled === false) ? true : false;
	                var shouldOverrideAutoplayToOff = (getChromeVersion() >= 56 && initialPlayback === "auto" && dataSaverEnabled === true) ? true : false;

	                //to resolve waterfall issue
	                createAndroidIframes("general", function () {
	                    callbackAdUnitOverridingAudioToOff(shouldOverrideAudioToOff,shouldOverrideAutoplayToOff);//a case for click-to-play, autoplay+sound-off (if autoplay is possible by DataSaver options's test)
	                }, waterfallSteps, maxWaterfallIframes, targetElementId);


	            }
	        };

	        if (isMobile()) {//for mobile
	            //mobile needs to have special handling for a case of autoplaying
	            if (isAndroid()) {
	                debug("intialize for Android");
	                asyncTestDataSaverForAndroid(autoplayDecisionCallback);//async test for checking data saver option on Android, test and then will invoke callback to notirfy result
	            } else {
	                debug("intialize for iOS and etc");
	                callbackAdUnitOverridingAudioToOff(false);

	                //this is required for iOS-Chrome 53 which has an bug not dispatching "loadedMetaData" event from generic video element
	                if (doesBrowserNeedUserActionToPlayVideo() && callbackPatchForIOSChrome && typeof(callbackPatchForIOSChrome) === "function") {
	                    windowForPublisher.addEventListener("touchstart", callbackPatchForIOSChrome);
	                }
	            }
	        } else {
	            //for desktop
	            debug("initialize for general html5 browsers");
	            callbackAdUnitOverridingAudioToOff(false);
	        }
	    } catch (ex) {
	        //fallback when error
	        debug(ex);
	        //call adunit next entry point
	        if (param.callbackAdUnitEntryPoint && typeof(param.callbackAdUnitEntryPoint) === "function") {
	            param.callbackAdUnitEntryPoint(false);
	        }
	    }

	};


	//shared attribute to other module
	module.exports = {
	    APN_MOBILE_VIDEO_PLACEMENT_ID: APN_MOBILE_VIDEO_PLACEMENT_ID,//video placement id in iframes which will be used on core video framework
	    APN_MOBILE_IFRAME_NAME: APN_MOBILE_IFRAME_NAME_PREFIX,//prefix of iframe names which will be used on core video framework
	    initialize: initialize,//initialize method for ad units
	    iOSversion: iOSversion,//shared method for core video framework
	    isIOS: isIOS,//shared method for core video framework
	    isIosInlineRequired: isIosInlineRequired,//shared method for core video framework
	    isRequiredFakeAndroidAutoStart: isRequiredHumanInteractionForAutoPlayOnAndroid,//shared method for core video framework
	    isMobile: isMobile, //shared method for core video framework
	    testDataSaverForAndroid: asyncTestDataSaverForAndroid //test data-saver options
	};


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var APNVideo_VastParser = __webpack_require__(29);
	var APN_RenditionManager = __webpack_require__(36);
	var APN_TrackingManager = __webpack_require__(38);
	var APN_CompanionManager = __webpack_require__(41);
	var APN_Logger = __webpack_require__(34);

	var debug = function (message) {
	    APN_Logger.debug(message, "AdHandler");
	};

	//common part to load video player
	module.exports = function (targetElement, options, cbAdunits) {


	    var VAST_ERROR_UNDEFINED = 900;
	    var ERROR_TYPE_VAST = 1;//vast-error (one of the error codes specified in the VAST spec)
	    var isDoneCbHandlingRendition = false;//flag for checking callback is done
	    var timeToWaitFor = 3000;//callback waiting
	    var vastVersion = "2.0";
	    var adId = new Date().getTime() + Math.floor(Math.random() * 10000);

	    // waterfall Initializations
	    var vastObjArr = [];
	    var rtbAd;
	    var currentAd;
	    var impressionSent = false;
	    var isWaterfall = false;
	    var waterfallTimeout = options.waterfallTimeout;
	    var waterfallTimeoutHandler;
	    var waterfallTimeoutOccurred = false;
	    var waterfallStepLogged = false;
	    var adCount = 0;
	    var maxNonRtbAdCount = 0;
	    var totalAvailableAds = 0;
	    var waterfallSteps = options.waterfallSteps;
	    var waterfallStartTimestamp;
	    //callback for sent waterfall step details to the adUnit
	    var waterfallCallback =  function (obj){
	        if(cbAdunits.cbWhenWaterfall){
	            cbAdunits.cbWhenWaterfall(obj);
	        }
	    };
	    //inject additional callback (getting override whenDestory callback)
	    var tmpCallback = cbAdunits.cbWhenDestroy;
	    // callback for impression sent event
	    var impCallback = cbAdunits.cbWhenImpression;
	    var notificationEventMapping = {
	        "creative-view": "creativeView",
	        "video-start": "start",
	        "video-mid": "midpoint",
	        "video-first-quartile": "firstQuartile",
	        "video-third-quartile": "thirdQuartile",
	        "video-complete": "complete",
	        "audio-mute": "mute",
	        "audio-unmute": "unmute",
	        "video-pause": "pause",
	        "video-rewind": "rewind",
	        "video-resume": "resume",
	        "video-fullscreen": "fullscreen",
	        "ad-expand": "expand",
	        "ad-collapse": "collapse",
	        "video-stopped": "close",
	        "video-exit-fullscreen": "exitFullscreen",
	        "video-skip": "skip",
	        "ad-progress": "progress",
	        "acceptInvitation": "acceptInvitation",
	        "acceptInvitationLinear": "acceptInvitationLinear",
	        "closeLinear": "closeLinear",
	        "impression": "impression",
	        "error": "error",
	        "video-failed": "error",
	        "ad-click": "ClickTracking"
	    };

	    // companions
	    var companionAdsObj = null;
	    var currentVastObj = null;

	    var isIphone = function () {
	        var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	        return isFlag;
	    };

	    var isIos = function () {
	        var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	        return isFlag;
	    };

	    var printWaterfallLog = function(stepLog, succ, errObj) {
	        if(!isWaterfall) {return;}
	        if(!currentAd) {return;}
	        var type = currentAd.rtb ? "rtb" : "csm";
	        var id = currentAd.adId;
	        var notifyurl = currentAd.notifyurl;
	        var currentTimestamp = new Date().getTime();
	        var statusObj = {};
	        statusObj.step = adCount;
	        statusObj.totalAvailableSteps = totalAvailableAds;
	        statusObj.stepLimit = waterfallSteps;
	        statusObj.maxTime = waterfallTimeout;
	        statusObj.timeRemaining = waterfallTimeout;
	        if(waterfallStartTimestamp){
	            statusObj.timeRemaining = waterfallTimeout - (currentTimestamp - waterfallStartTimestamp);
	        }

	        if(stepLog){
	            waterfallStepLogged = false;
	            options.waterfallStepId = "Waterfall_Step_"+ new Date().getTime() + Math.floor(Math.random() * 10000);
	            statusObj.status = 'stepStart';
	            debug("Waterfall Step #" + adCount +" , type=" + type + ", adId=" + id +", timeout="+ waterfallTimeout +  ", notifyurl=" + notifyurl);
	            waterfallCallback(statusObj);
	            return;
	        }

	        if(waterfallStepLogged){
	            // outcome for the step is already logged;
	            return;
	        }
	        waterfallStepLogged = true;

	        if(succ){
	            statusObj.status = 'stepSuccess';
	            debug("Waterfall outcome, Step #" + adCount + ": ACCEPTED, type= " + type +", adId=" + id +", timeout="+ waterfallTimeout + ", notifyurl=" + notifyurl);
	            waterfallCallback(statusObj);
	            return;
	        }

	        if(waterfallTimeoutOccurred){
	            statusObj.status = 'timeout';
	            debug("Waterfall outcome, Step #" + adCount + ": TIMED-OUT, type= " + type +", timeout="+ waterfallTimeout +", ads processed="+ adCount);
	            waterfallCallback(statusObj);
	            return;
	        }

	        if(errObj){
	            statusObj.status = 'stepFail';
	            debug("Waterfall outcome, Step #" + adCount + ": REJECTED, type= " + type +", adId=" + id +", timeout="+ waterfallTimeout+ ", reason=" + errObj.message);
	            waterfallCallback(statusObj);
	        }
	    };

	    var notifyVastTracking = function(eventName) {
	        var vastEvent = notificationEventMapping[eventName];
	        if (!vastEvent) {
	            // internal event
	            return;
	        }
	        options.cbNotification('VAST', vastEvent, options.targetId);

	        // remove one time deal events
	        if (eventName === "impression" || eventName === "video-complete" || eventName === "video-start") {
	            if (notificationEventMapping.hasOwnProperty(eventName)) {
	                delete notificationEventMapping[eventName];
	            }
	        }
	    };

	    var companionCallback = function(obj) {
		if (!obj || !obj.command || !obj.uniqueId) {
			return;
		}
		var command = obj.command;
	        debug("Companion callback command: " + command + ", unique companion id: " + obj.uniqueId);
		switch(command) {
		case 'addTrackingEvents': {
				var companion = obj.data;
				if (companion) {
			        //prepare tracking manager
			        var unrestrictedEvents = [
			            "error",
			            "creative-view",
			            "companion-click"
			        ];
			        var i;
			        APN_TrackingManager.init(unrestrictedEvents, obj.uniqueId);//set unrestricted event (multiple invokes)
					if (companion.CompanionClickTracking && companion.CompanionClickTracking.length > 0) {
						for (i = 0; i < companion.CompanionClickTracking.length; i++) {
							APN_TrackingManager.addTrackingEvent("companion-click", companion.CompanionClickTracking[i], obj.uniqueId);
						}
					}
					if (companion.TrackingEvents && companion.TrackingEvents.length > 0) {
						for (i = 0; i < companion.TrackingEvents.length; i++) {
							if (companion.TrackingEvents[i].eventType === 'creativeView') {
								// only creativeView event is available for companion
								APN_TrackingManager.addTrackingEvent("creative-view", companion.TrackingEvents[i].url, obj.uniqueId);
							}
						}
					}
				}
			}
			break;
		case 'requestTracking':	{
				var eventName = obj.data;
				if (eventName) {
					APN_TrackingManager.requestTracking(eventName, obj.uniqueId);
				}
			}
			break;
		}
	    };

	    //function for handle callback invoke from video player framework
	    var cbForHandlingDispatchedEvent = function (eventObject) {

	        debug("TM>requesting - dispatch : " + eventObject.name);
	        var eventName = eventObject.name;


	        //normalizated values in tracking manager
	        /*
	         * 	- bid-impression
	         *  - network-request
	         *  - network-response
	         * 	- impression
	         * 	- video-start
	         *  - video-first-quartile
	         *  - video-mid
	         *  - video-third-quartile
	         *  - video-complete
	         *  - ad-click
	         *  - video-pause
	         *  - video-rewind
	         *  - video-resume
	         *  - audio-mute
	         *  - audio-unmute
	         *  - video-fullscreen
	         *  - video-exit-fullscreen
	         *  - creative-view
	         *  - ad-expand
	         *  - ad-collapse
	         *  - user-accept-invitation
	         *  - user-close
	         *  - ad-progress
	         *  - error
	         */
	        var evenetMappingForFlash = {
	            "video_start": "video-start",
	            "video_impression": "impression",
	            "video_mute": "audio-mute",
	            "video_click": "video-click",
	            "video_complete": "video-complete",
	            "video_fullscreen": "video-fullscreen",
	            "quartile_event": "quartile-event",
	            "video_pause": "video-pause",
	            "video_unmute": "audio-unmute",
	            "video_failed": "video-failed",
	            "video_time": "video-time",
	            "video_resume": "video-resume",
	            "video_stopped": "video-stopped",
	            "fullscreenchange": "video-fullscreen",
	            "video_skip": "video-skip"
	        };
	        var invokeEventName = evenetMappingForFlash[eventName];


	        //convert flash quartile events
	        if (invokeEventName === "quartile-event") {
	            switch (eventObject.quartile) {
	                case 1 :
	                    invokeEventName = "video-first-quartile";
	                    break;
	                case 2 :
	                    invokeEventName = "video-mid";
	                    break;
	                case 3 :
	                    invokeEventName = "video-third-quartile";
	                    break;
	            }
	        }


	        //handle vast3 full-screen-exit
	        if (invokeEventName === "video-fullscreen" && vastVersion === "3.0") {
	            switch (eventObject.fullscreenStatus) {
	                case "enter" :
	                    invokeEventName = "video-fullscreen";
	                    break;
	                case "exit" :
	                    invokeEventName = "video-exit-fullscreen";
	                    break;
	                default :
	                    invokeEventName = "video-fullscreen";
	                    break;
	            }
	        }

	        //if it's for flash, just use it.
	        if (invokeEventName === undefined) {
	            invokeEventName = eventName;
	        }
	        if(eventObject && eventObject.name && eventObject.name === "ad-click" && !eventObject.trackClick){
	            // Where clickThru landing url was not found. Do not track click and Do not send VAST notifications for ClickTracking
	            return;
	        }else{
	            //comment out due to a change of VIDLA-92 spec.
	            //fix fox VIDLA-92 only report skip event when VAST video is skippable which is defiend by VAST XML (creative skipoffset)
	            //if (eventObject && eventObject.name === "video_skip" && options && options.data.isVastVideoSkippable === false) {
	            //    debug("tracking video_skip got canceled because VAST video is not skippable (skipOffset doesn't exist in VAST)");
	            //} else {
	                APN_TrackingManager.requestTracking(invokeEventName, adId);
	            //}
	        }
	        if (options.hasOwnProperty('cbNotification')) {
	            notifyVastTracking(invokeEventName);
	        }
	        if (options.cbApnVastPlayer) {
	            options.cbApnVastPlayer(invokeEventName);
	        }

	        if (invokeEventName === "canplay") {
			if (eventObject.companionAds) {
				currentVastObj.companionAds = APN_CompanionManager.parse(eventObject.companionAds);
			}
	        }

	        if(invokeEventName === "impression"){
	            // waterfall
	            impressionSent = true;
	            if(impCallback && typeof(impCallback) === "function"){
	                impCallback();
	            }
	            if(isWaterfall){
	                if(waterfallTimeoutHandler){
	                    clearTimeout(waterfallTimeoutHandler);
	                }
	                printWaterfallLog(false, true);
	                APN_TrackingManager.requestTracking("notifyurl", adId);
	            }
	            // companion support
	            if (currentVastObj.hasOwnProperty('companionAds') && currentVastObj.companionAds.companions.length > 0 &&
			options.hasOwnProperty('companionContainers')) {
				companionAdsObj = APN_CompanionManager.renderCompanions(currentVastObj.companionAds, options, companionCallback);
	            }
	        }
	    };

	    //function for registring tracking event based on impbus object
	    var fnRegisterTracking = function (vastObject) {

	        vastVersion = vastObject.vastVersion;

	        //prepare tracking manager
	        var unrestrictedEvents = [
	            "video-pause",
	            "video-play",
	            "video-fullscreen",
	            "ad-click",
	            "video-rewind",
	            "video-resume",
	            "audio-mute",
	            "audio-unmute",
	            "video-fullscreen",
	            "video-exit-fullscreen",
	            "ad-expand",
	            "ad-collapse",
	            "ad-progress",
	            "creative-view"
	        ];
	        APN_TrackingManager.init(unrestrictedEvents, adId);//set unrestricted event (multiple invokes)

	        //register all tracking nodes in trackins
	        APN_TrackingManager.addTrackingEvents(vastObject.trackingUrls, adId);
	        //console.log(vastObject.trackingUrls);

	        //register indivisual tracking
	        /*
	         elemenet to be handled by
	         vastObject.clickTrackingUrls
	         vastObject.clickUrls
	         vastObject.errorUrls
	         vastObject.impressionUrls
	         vastObject.trackingUrls
	         */


	        var cnt;
	        var url;

	        //handle clickTrackingUrls
	        var clickTrackingUrls = vastObject.clickTrackingUrls;
	        for (cnt = 0; cnt < clickTrackingUrls.length; cnt++) {
	            url = clickTrackingUrls[cnt];
	            debug("register clickTrackingUrls : " + url);
	            APN_TrackingManager.addTrackingEvent("ad-click", url, adId);//TODO make sure eventname
	        }


	        //handle errorUrls
	        var errorUrls = vastObject.errorUrls;

	        for (cnt = 0; cnt < errorUrls.length; cnt++) {
	            url = errorUrls[cnt];
	            debug("register errorUrls  : " + url);
	            APN_TrackingManager.addTrackingEvent("error", url, adId);
	        }
	        //handle impressionUrls
	        var impressionUrls = vastObject.impressionUrls;
	        for (cnt = 0; cnt < impressionUrls.length; cnt++) {
	            url = impressionUrls[cnt];
	            debug("register impressionUrls  : " + url);
	            APN_TrackingManager.addTrackingEvent("impression", url, adId);
	        }

	        //handle Notify URL:
	        var notifyUrl = vastObject.notifyurl;
	        if(isWaterfall && notifyUrl){
	            debug("register notifyurl  : " + notifyUrl);
	            APN_TrackingManager.addTrackingEvent("notifyurl", notifyUrl, adId);
	        }
	    };


	    var setWaterfallTimeout = function(){
	        if(isWaterfall && !waterfallTimeoutHandler){
	            waterfallStartTimestamp = new Date().getTime();
	            waterfallTimeoutHandler = setTimeout(function () {
	                waterfallTimeoutOccurred = true;
	            }, waterfallTimeout);
	        }
	    };


	    //callback to handle a step from vast varser
	    var cbHandlingRendition = function (vastObject) {

	        var errorDescr;
	        try {
	            fnRegisterTracking(vastObject);//regist tracking event
	            APN_RenditionManager.init(vastObject.mediaFiles);
	            var renditionResult = APN_RenditionManager.getUrl(options.width, options.height, null, options);


	            if (renditionResult !== null && renditionResult.success === true) {

	                //expected result from rendtion manager
	                /*
	                 renditionResult.bitrate;
	                 renditionResult.delivery;
	                 renditionResult.width;
	                 renditionResult.height;
	                 renditionResult.maintainAspectRatio;
	                 renditionResult.scalable;
	                 renditionResult.type;
	                 renditionResult.url;
	                 renditionResult.variation;
	                 renditionResult.requiredPlayer;//0 - any, 1 - html5, 2 - flash
	                 */




	                //define options by result of rendition manager
	                options.video = {};
	                options.video.url = renditionResult.url;

	                options.video.width = renditionResult.width;
	                options.video.height = renditionResult.height;


	                // console.log(vastObject);

	                //set vast skippable here for VIDLA-92
	                options.data.skipOffset = (vastObject && vastObject.skipOffset) ? vastObject.skipOffset : "";

	                //gather progress event
	                var vastProgressEvent = {};
	                for (var tmp in vastObject.trackingUrls) {
	                    if (tmp.indexOf("progress_") >= 0) {
	                        vastProgressEvent[tmp] = null;
	                    }
	                }
	                options.data.vastProgressEvent = vastProgressEvent;

	                if (renditionResult.maintainAspectRatio && renditionResult.maintainAspectRatio !== undefined) {
	                    options.video.maintainAspectRatio = renditionResult.maintainAspectRatio;
	                    options.maintainAspectRatio = renditionResult.maintainAspectRatio;
	                } else {
	                    options.video.maintainAspectRatio = true;
	                    options.maintainAspectRatio = true;
	                }

	                if (renditionResult.scalable && renditionResult.scalable !== undefined) {
	                    options.video.scalable = renditionResult.scalable;
	                    options.canScale = renditionResult.scalable;
	                } else {
	                    options.video.scalable = true;
	                    options.canScale = true;
	                }


	                options.video.apiFramework = renditionResult.apiFramework;
	                options.video.type = renditionResult.type;
	                options.requiredPlayer = renditionResult.requiredPlayer;
	                options.videoUrl = renditionResult.url;//TODO refactoricing needed
	                options.clickUrls = vastObject.clickUrls;
	                options.adParameters = vastObject.adParameters;	//TODO check adParams
	                options.extensions = vastObject.extensions;
	                options.data.vastDurationMsec = vastObject.durationMsecs;


	                if (options.video.apiFramework && options.video.apiFramework.toLowerCase().indexOf('vpaid') >= 0) {
	                    options.vpaid = true;
	                } else {
	                    options.vpaid = false;
	                }

	                //redefine width,height for vpaid to give a proper values to Flash wrapper
	                //if (options.vpaid && typeof options.width == "undefined" ) {
	                //    options.width = renditionResult.width;
	                //
	                //}
	                //
	                //if (options.vpaid && typeof options.height == "undefined" ) {
	                //    options.height = renditionResult.height;
	                //}

	                //define target element in publisher page
	                options.targetElement = targetElement;

	                //link dispatch callback
	                cbAdunits.cbForHandlingDispatchedEvent = cbForHandlingDispatchedEvent;

	                //override cbWhenReady to insert a logic to get duration of video metadata, usually this logic will get called by playerManager when it got video-meta-data to norify video is ready to play
	                var original_cbWhenReady = cbAdunits.cbWhenReady;//keep original function reference

	                cbAdunits.cbWhenReady = function(playerManager) {//override
	                    //set VAST3 attributes to options
	                    playerManager.setVastAttribute();

	                    //do unit test if it's configured by options
	                    playerManager.test("VIDLA163", playerManager.options.data);

	                    //call original cbWhenReady callback to continue a flow
	                    original_cbWhenReady(playerManager);
	                };
	                //render video
	                cbAdunits.cbRenderVideo(cbAdunits, options, setWaterfallTimeout);

	                isDoneCbHandlingRendition = true;

	                currentVastObj = vastObject;
	                return;
	            } else {
	                isDoneCbHandlingRendition = true;
	                cbAdunits.cbWhenDestroy({
	                    type: 1,
	                    code: renditionResult.errorCode,
	                    message: "Unable to select rendition"
	                });
	                return;
	            }

	        } catch (ex) {
	            debug(ex);
	            errorDescr = 'Exception error: ' + ex;
	        }
	        isDoneCbHandlingRendition = true;
	        cbAdunits.cbWhenDestroy({type: 0, code: 0, message: errorDescr});
	    };

	    var handleNextAd = function(vastObj) {
	        isDoneCbHandlingRendition = false;
	        if(vastObj){
	            cbHandlingRendition(vastObj);
	        }
	    };

	    var getRtbAd = function(){
	        var obj = null;
	        if (rtbAd){
	            obj = rtbAd;
	            rtbAd = null;
	        } else{
	            obj = vastObjArr.shift();
	        }
	        return obj;
	    };

	    var getNextEligibleAd = function(totalNonRtbAttempts){
	        var obj = null;
	        if(adCount < totalNonRtbAttempts){
	            obj = vastObjArr.shift();
	        }else {
	            obj = getRtbAd();
	        }
	        return obj;
	    };

	    var getNextAd = function() {
	        isDoneCbHandlingRendition = false;
	        var vastObj = null;
	        if(vastObjArr && isWaterfall){
	            switch (waterfallSteps){
	                case 0:
	                    if(adCount === 0){
	                        vastObj = vastObjArr.shift();
	                        if(!vastObj){
	                            vastObj = getRtbAd();
	                        }
	                    }
	                    break;
	                case -1:
	                    vastObj = getNextEligibleAd(maxNonRtbAdCount);
	                    break;
	                default:
	                    if(waterfallSteps < maxNonRtbAdCount){
	                        vastObj = getNextEligibleAd(waterfallSteps);
	                    } else {
	                        vastObj = getNextEligibleAd(maxNonRtbAdCount);
	                    }
	                    break;
	            }
	        } else {
	            vastObj = vastObjArr.shift();
	        }
	        currentAd = vastObj;
	        adCount++;
	        printWaterfallLog(true);
	        if(vastObj){
	            adId = vastObj.adId;
	        }
	        return vastObj;
	    };

	    var cbHandlingParsedVAST = function (succ, id, vast, errorUrls){

	        if (succ) {
	            if (Array.isArray(vast)) {
	                // VID-1861 Disable waterfall when non inline IOS player is used due to autoplay limitation
	                if(!isIos() ||(isIos() && options.enableInlineVideoForIos)){
	                    // Ad Waterfall is on.
	                    isWaterfall = true;
	                    options.isWaterfall = true;
	                    vastObjArr = vast;
	                    totalAvailableAds = vastObjArr.length;
	                    // find Rtb Ad
	                    for(var index= 0; index< vastObjArr.length; index++){
	                        var obj= vastObjArr[index];
	                        if(obj.rtb){
	                            rtbAd = obj;
	                            vastObjArr.splice(index, 1);
	                            break;
	                        }
	                    }
	                    maxNonRtbAdCount = vastObjArr.length;
	                } else{
	                    isWaterfall = false;
	                    vastObjArr = vast;
	                }
	            } else {
	                //if not water fall
	                isWaterfall = false;
	                vastObjArr.push(vast);
	            }
	            var vastObj = getNextAd();
	            if(vastObj) {
	                handleNextAd(vastObj);
	            }
	        }
	        else {
	            //if not successful by vast-parser
	            var msg = "Vast Parser error (" + vast + ")";

	            //register error tracking to handle errorUrls if errorUrls returns from vast parser in order to handle internal error happened from vast parser
	            if (errorUrls && errorUrls.length > 0) {
	                errorUrls.forEach(function(url) {
	                    debug("register errorUrls  : " + url);
	                    APN_TrackingManager.addTrackingEvent("error", url, adId);
	                });
	                cbAdunits.cbWhenDestroy({type: ERROR_TYPE_VAST, code: VAST_ERROR_UNDEFINED, message: msg});
	            } else {
	                cbAdunits.cbWhenDestroy({type: 0, code: 0, message: msg});
	            }

	        }
	    };


	    cbAdunits.cbWhenDestroy = function (errorObject, keepFullscreen, _options) {

	        //errorObject.type: type of error (0 = general appnexus error, 1 = vast-error (one of the error codes specified in the VAST spec), 2 = http error
	        //errorObject.code: code for identifying error condition
	        //errorObject.message: message of error

	        if(isWaterfall){
	            if( _options && _options.waterfallStepId !== options.waterfallStepId){
	                return;
	            }
	            options = _options;
	            printWaterfallLog(false, false, errorObject);
	        }

	        if(isWaterfall && !impressionSent && !waterfallTimeoutOccurred){
	            var nextAd = getNextAd();
	            if(nextAd){
	                handleNextAd(nextAd);
	                return;
	            }
	            // For final error in waterfall we would be requesting notifyurl;
	            APN_TrackingManager.requestTracking("notifyurl", adId);
	        }

	        if (errorObject && typeof(errorObject.type) !== "undefined") {
	            debug("requesting error in whenDestroy callback : " + errorObject.code + "," + errorObject.type + "," + errorObject.message);
	            // VID-2661 - Decision to not report Errors once Impression is sent(as Vast 3.0 spec says report errors before Ad Load.)
	            // Deferring skipOffset error reporting mentioned in Vast 3.0 TODO: need to decide on that with product
	            if(!impressionSent){
	                APN_TrackingManager.requestErrorTracking(errorObject.code, errorObject.type, errorObject.message, adId);
	            }else{
	                debug("not requesting error tracker because the Ad Impression was already reported");
	            }
	        } else {
	            debug("requesting error in whenDestroy callback : " + errorObject + "," + (errorObject ? true : false));
	        }

	        if (companionAdsObj) {
			APN_CompanionManager.stopCompanions(companionAdsObj);
			companionAdsObj = null;
	        }

	        //invoke override whenDestory callback
	        if (typeof(tmpCallback) === "function") {
	            tmpCallback(errorObject ? errorObject : false, keepFullscreen);
	        }
	    };

	    //get value from vastXM to decide video URL
	    if (options !== undefined && options && options.vastXml) {


	        setTimeout(function () {
	            if (!isDoneCbHandlingRendition) {
	                cbAdunits.cbWhenDestroy({type: 0, code: 0, message: "VAST Parser didn't answer until timeout"});
	            }

	        }, timeToWaitFor);
	        debug("Ad XML : " + options.vastXml);
	        APNVideo_VastParser.parse(options.vastXml, cbHandlingParsedVAST, null, 2000, null, null, options);

	    }

	    //get value from adObj to decide video URL
	    if (options !== undefined && options && options.useAdObj && options.adObj) {
		cbHandlingRendition(options.adObj);
	    }
	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * VAST Parser module.
	 * @module VastParser
	 */

	var VastXMLParserHelper = function () {
	    this.getSubNodes = function (node, subNodeName) {
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > 0) {
	            return nodes;
	        }
	        return null;
	    };

	    this.getSubNode = function (node, subNodeName, index) {
	        if (!index) {
	            index = 0;
	        }
	        var nodes = node.getElementsByTagName(subNodeName);
	        if (nodes.length > index) {
	            return nodes[index];
	        }
	        return null;
	    };

	    this.getNodeValue = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var val = node.childNodes[0].nodeValue;
	        return val.trim();
	    };

	    this.getNodeValues = function (node) {
	        if (node.childNodes.length === 0) {
	            return '';
	        }
	        var wholeVal = '';
	        for (var i = 0; i < node.childNodes.length; i++) {
	            var val = node.childNodes[i].nodeValue;
	            wholeVal += val;
	        }
	        return wholeVal.trim();
	    };

	    this.getNodeAttributeValue = function (node, attributeName) {
	        var val = node.getAttribute(attributeName);
	        if (val === null) {
	            val = '';
	        }
	        return val;
	    };

	    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = 0;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            if (val.indexOf('.') >= 0) {
	                answer = parseFloat(val);
	            }
	            else {
	                answer = parseInt(val);
	            }
	        }

	        return answer;
	    };

	    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
	        if (!defaultValue) {
	            defaultValue = false;
	        }
	        var answer = defaultValue;
	        var val = this.getNodeAttributeValue(node, attributeName);

	        if (val.length > 0) {
	            var char = val.toLowerCase().charAt(0);
	            answer = (char === 't');
	        }

	        return answer;
	    };

	    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValue(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
	        var subnode = this.getSubNode(parentNode, subNodeName);
	        if (subnode !== null) {
	            return this.getNodeValues(subnode);
	        }
	        return defaultValue;
	    };

	    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
	        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

	        var value = this.getSubNodeValue(parentNode, subNodeName);
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
	            return true;
	        }
	        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
	            return false;
	        }
	        return defaultValue;
	    };
	};

	var APN_CompanionAds = __webpack_require__(30);
	var APN_Icons = __webpack_require__(31);
	var VastParser = function(id, nMsecTimeout, options) {

		var _logger = __webpack_require__(2);
		var _prefix = 'VAST Parser';

		var _callback = null;
		var _options = options;
		var _sourceVastXml = null;
		var _id = id;
		var _nTimeOut = nMsecTimeout && nMsecTimeout > 0 ? nMsecTimeout : 1000;	// 1 second default
		var _arrMediaFiles = [],
		    _arrTrackings = {},
		    _arrImpressions = [],
		    _arrClickUrls = [],
		    _arrClickTrackings = [],
		    _arrErrorUrls = [],
	        _arrInternalErrorUrls = [],
		    _sExtensions = '',
		    _adParameters = '',
		    _nMsecDuration = 0,
	        _strSkipOffset = "";

	    var _arrTrackingsMerge = {},
		_arrImpressionsMerge = [],
		_arrClickUrlsMerge = [],
		_arrClickTrackingsMerge = [],
		_arrErrorUrlsMerge = [];

		var _helper = new VastXMLParserHelper();
		var _startTime = null;
		var _withWrapper = false;
		var _vastVersion = '';

		var _adTree = [];
		var _currTreeIdx = -1;

		var _terminated = false;

	    var _capabilityDetection = __webpack_require__(32);

	    var _waterfall = false;
	    var _vastObjects = [];
	    var _topLevel = false;
	    var _notifyurls = {};
	    var _curNotifyUrl = '';
	    var _buyerMemberIds = {};
	    var _curBuyerMemberId = '';

	    var _csmCount = 0;
	    var _rtbCount = 0;

	    _logger.always(_prefix, 'Version 1.1.14');

		function getVASTVersion(vastNode) {
		    var version = 'unknown';
		    if (vastNode) {
		        version = _helper.getNodeAttributeValue(vastNode, 'version');
		        version = version.trim();
		        if (version.length > 3) {
				version = version.substr(0, 3);
		        }
		    }
		    return version;
		}

		function substituteErrorCode(arrErrorUrls, errorCode) {
			if (arrErrorUrls && arrErrorUrls.length > 0) {
			    for (var i = 0; i < arrErrorUrls.length; i++) {
	                arrErrorUrls[i] = arrErrorUrls[i].replace('[ERRORCODE]', errorCode);
				}
			}
		}

		function traceTreePath(idx, message) {
			var curIdx = idx;
			var text = 'AD DETECTED=' + (message.substr(0,7) === 'SUCCESS' ? 'SUCCESS' : 'NONE') + ' :: Reason=' + message +
				', playerTechnology=' + (_options.hasOwnProperty('playerTechnology') ? JSON.stringify(_options.playerTechnology) : 'unknown') +
				', platform=' + _capabilityDetection.getPlatformType() + ', Ad tree path=';
			var tree = '';
			while (curIdx !== -1) {
				var ad = _adTree[curIdx].children[0];
				if (ad) {
					var val = _helper.getNodeAttributeValue(ad, 'id');
					if (tree.length > 0) {
						tree = ' -> ' + tree;
					}
					tree = val + tree;
				}
				curIdx = _adTree[curIdx].parentIdx;
			}
			_logger.info(_prefix, text + tree);
		}

		function processWrapper(parentNode) {
		    var node = _helper.getSubNode(parentNode, 'VASTAdTagURI');
		    if (!node) {
			traceTreePath(_currTreeIdx, 'INVALID WRAPPER NODE');
			if (_adTree.length === 0) {
				reportError('300', 'invalid wrapper node');
			}
			else {
				processNextAd();
			}
		        return;
		    }
		    var url = _helper.getNodeValues(node);
		    if (!url || url.length === 0) {
			traceTreePath(_currTreeIdx, 'EMPTY VASTAdTagURI');
			if (_adTree.length === 0) {
				reportError('300', 'Invalid VASTAdTagURI node value');
			}
			else {
				processNextAd();
			}
		        return;
		    }

		    if (_terminated) {
			traceTreePath(_currTreeIdx, 'terminated');
		        _callback(false, _id, 'terminated', null);		// terminated
			return;
		    }

		    _withWrapper = true;

		    var UrlLoader = __webpack_require__(33);
		    UrlLoader.load(url,
		        function(error, responseText) {
				    if (_terminated) {
					traceTreePath(_currTreeIdx, 'terminated');
				        _callback(false, _id, 'terminated', null);		// terminated
					return;
				    }
				if (error || responseText.length === 0) {
				traceTreePath(_currTreeIdx, 'VASTAdTagURI TIMED OUT: ' + url);
				if (_adTree.length === 0) {
					reportError('301', 'Timeout of VAST URI provided in wrapper element');
				}
				else {
					processNextAd();
				}
				}
				else {
					_topLevel = false;
					parseXML(responseText);
				}
		        }, _nTimeOut);
		}

		function isInArray(arr, value) {
		    for (var i = 0; i < arr.length; i++) {
		        if (arr[i] === value) {
		            return true;
		        }
		    }
		    return false;
		}

		function addErrorUrls(parentNode, arrErrorUrls) {
		    if (parentNode) {
		        var nodes = _helper.getSubNodes(parentNode, 'Error');
		        if (nodes) {
		            for (var i = 0; i < nodes.length; i++) {
		                var node = nodes[i];
		                var url = _helper.getNodeValues(node);
		                if (url && !isInArray(arrErrorUrls, url)) {
					arrErrorUrls.push(url);
		                }
		            }
		        }
		    }
		}

		function addImpressions(parentNode, arrImpressions) {
		    if (parentNode) {
		        var nodes = _helper.getSubNodes(parentNode, 'Impression');
		        if (nodes) {
		            for (var i = 0; i < nodes.length; i++) {
		                var node = nodes[i];
		                var url = _helper.getNodeValues(node);
		                if (url && !isInArray(arrImpressions, url)) {
					arrImpressions.push(url);
		                }
		            }
		        }
		    }
		}

		function addTrackings(parentNode, arrTrackings) {
		    //var _nMsecDuration;
		    if (parentNode) {
		        var linear = _helper.getSubNode(parentNode, 'Linear', 0);
		        if (linear) {

	                //comment out by VIDLA-163
	                //var duration_node = _helper.getSubNode(linear, 'Duration');
	                //if (duration_node) {
	                    //var str = _helper.getNodeValue(duration_node);
	                    //_nMsecDuration = getMsecTime(str, -1);
	                //}


		            var node = _helper.getSubNode(linear, 'TrackingEvents');
		            if (node) {
		                var nodes = _helper.getSubNodes(node, 'Tracking');
		                if (nodes) {
		                    for (var i = 0; i < nodes.length; i++) {
		                        node = nodes[i];
		                        var url = _helper.getNodeValues(node);
		                        if (url) {


		                            var event = _helper.getNodeAttributeValue(node, 'event');

	                                //VIDLA-422 progress event also can be multiple in wrapper case
		                            if (event === 'progress') {
	                                    var offset = _helper.getNodeAttributeValue(node, 'offset');
	                                    if (offset) {
	                                        //event = 'progress_' + getMsecTime(offset,_nMsecDuration);
	                                        event = 'progress_' + offset;
	                                    } else {
	                                        event = '';
	                                    }
	                                }
	                                if (event) {
	                                    if (arrTrackings.hasOwnProperty(event)) {
	                                        if (!isInArray(arrTrackings[event], url)) {
	                                            arrTrackings[event].push(url);
	                                        }
	                                    }
	                                    else {
	                                        arrTrackings[event] = [];
	                                        arrTrackings[event].push(url);
	                                    }
	                                }
		                        }
		                    }
		                }
		            }
		        }
		    }
		}

		function addExtensions(parentNode, treeIdx) {
		    if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Extensions');
	            if (node && node.innerHTML && node.innerHTML.length > 0) {
			_adTree[treeIdx].state.sExtensions = _adTree[treeIdx].state.sExtensions + node.innerHTML.toString();
	             }
		    }
		}

		function addCompanions(parentNode, treeIdx) {
		    if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'CompanionAds');
	            if (node &&
			((node.innerHTML && node.innerHTML.length > 0) ||
			 (node.textContent && node.textContent.length > 0))) {
			APN_CompanionAds.parse(_adTree[treeIdx].state.companions, node, _helper);
	             }
		    }
		}

		function addIcons(parentNode, treeIdx) {
		    if (parentNode) {
	            var node = _helper.getSubNode(parentNode, 'Icons');
	            if (node && node.innerHTML && node.innerHTML.length > 0) {
			APN_Icons.parse(_adTree[treeIdx].state.icons, node, _helper);
	             }
		    }
		}

		function addClickUrls(parentNode, arrClickUrls, arrClickTrackings) {
		    if (parentNode) {
		        var linear = _helper.getSubNode(parentNode, 'Linear', 0);
		        if (linear) {
				var url = null;
		            var parentNode2 = _helper.getSubNode(linear, 'VideoClicks');
		            if (parentNode2) {
		                var node = _helper.getSubNode(parentNode2, 'ClickThrough');
		                if (node) {
		                    url = _helper.getNodeValues(node);
		                    if (url && !isInArray(arrClickUrls, url)) {
					arrClickUrls.push(url);
		                    }
		                }
		                var nodes = _helper.getSubNodes(parentNode2, 'ClickTracking');
		                if (nodes) {
		                    for (var i = 0; i < nodes.length; i++) {
		                        node = nodes[i];
			                    url = _helper.getNodeValues(node);
			                    if (url && !isInArray(arrClickTrackings, url)) {
						arrClickTrackings.push(url);
			                    }
		                    }
		                }
		            }
		        }
		    }
		}

		function getMsecTime(strTime, duration) {
		    var nPos = strTime.indexOf('%');
		    if (nPos > 0) {
		        if (duration && duration > 0) {
		            return Number(strTime.substring(0, nPos));
		        }
		        else {
		            return 0;
		        }
		    } else {
		        nPos = strTime.indexOf('.');
		        var msecs = nPos > 0 ? Number(strTime.substring(nPos + 1)) : 0;
		        if (nPos > 0) {
		            strTime = strTime.substring(0, nPos);
		        }
		        var arr = strTime.split(':');
		        if (arr.length === 3) {
		            return (Number(arr[0]) * 3600 + Number(arr[1]) * 60 + Number(arr[2])) * 1000 + msecs;
		        }
		        else {
		            return 0;
		        }
		    }
		}

		function isCapable(type, codec) {
			return _capabilityDetection.canPlay(type, codec);
		}

		function isFlashOnlyType(type) {
			return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
				type === 'application/x-shockwave-flash';
		}

		function isHtml5OnlyType(type) {
			return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
				type === 'application/x-javascript';
		}

		function isVpaidType(type) {
			return type === 'application/x-shockwave-flash' || type === 'application/javascript' ||
				type === 'application/x-javascript';
		}

		function isOptionsValidated(type) {
			if (_options.playerTechnology && Array.isArray(_options.playerTechnology) && _options.playerTechnology.length > 0) {
			    var supported = false;
			    for (var i = 0; i < _options.playerTechnology.length; i++) {
				var tech = _options.playerTechnology[i].toLowerCase();
				if (!isFlashOnlyType(type.toLowerCase()) && !isHtml5OnlyType(type.toLowerCase())) {
					supported = true;
					break;
				}
				if (tech === 'flash' && !isHtml5OnlyType(type.toLowerCase())) {
					supported = true;
					break;
				}
				if (tech === 'html5' && !isFlashOnlyType(type.toLowerCase())) {
					supported = true;
					break;
				}
			    }
			    if (!supported) {
				return false;
			    }
			}
			if (_options.hasOwnProperty('supportVpaid') && !_options.supportVpaid) {
				if (isVpaidType(type.toLowerCase())) {
					return false;
				}
			}
			return true;
		}

		function configureMediaRendition(node, url, num, mediaTypes) {
		    var rendition = null;
		    if (node) {
		        rendition = {};
		        rendition.type = _helper.getNodeAttributeValue(node, 'type');
		        if (mediaTypes.indexOf(rendition.type) === -1) {
				mediaTypes.push(rendition.type);
		        }
		        // check capability
		        if (!rendition.type || rendition.type.length === 0) {
				return null;
		        }
		        var codec = _helper.getNodeAttributeValue(node, 'codec');
		        if (codec && codec.length > 0) {
				rendition.codec = codec;
		        }
		        if (!isCapable(rendition.type, codec)) {
				return null;
		        }
		        if (_options) {
				if (!isOptionsValidated(rendition.type)) {
					return null;
				}
		        }
		        rendition.url = url;
		        rendition.variation = 'Media#' + num;
		        rendition.delivery = _helper.getNodeAttributeValue(node, 'delivery');
		        var bitrate = _helper.getNodeAttributeNumberValue(node, 'bitrate', -1);
		        if (bitrate !== -1) {
				rendition.bitrate = bitrate;
		        }
		        rendition.width = _helper.getNodeAttributeNumberValue(node, 'width');
		        rendition.height = _helper.getNodeAttributeNumberValue(node, 'height');
		        var valNode = _helper.getNodeAttributeValue(node, 'scalable');
		        if (valNode.length > 0) {
			        rendition.scalable = _helper.getNodeAttributeBooleanValue(node, 'scalable', true);
		        }
		        valNode = _helper.getNodeAttributeValue(node, 'maintainAspectRatio');
		        if (valNode.length > 0) {
			        rendition.maintainAspectRatio = _helper.getNodeAttributeBooleanValue(node, 'maintainAspectRatio', true);
		        }
		        var apiFramework = _helper.getNodeAttributeValue(node, 'apiFramework');
		        if (apiFramework && apiFramework.length > 0) {
				rendition.apiFramework = apiFramework.toUpperCase();
		        }
		    }

		    return rendition;
		}

		function addMediaFilesAndDuration(parentNode) {
			_nMsecDuration = 0;
			_strSkipOffset = "";
			_adParameters = '';
			_arrMediaFiles = [];
			var message = '';
			var mediaTypes = [];
		    if (parentNode) {
		        var linear = _helper.getSubNode(parentNode, 'Linear', 0);
		        if (linear) {
		            var node = _helper.getSubNode(linear, 'Duration');
		            if (node) {
		                var str = _helper.getNodeValue(node);
		                _nMsecDuration = getMsecTime(str, -1);
		                // debugger;
		            }
		            var strSkipOffset = _helper.getNodeAttributeValue(linear, 'skipoffset');

		            //comment out by VIDLA-163
		            //if (strSkipOffset && strSkipOffset.length > 0) {
		            //    _nSkipOffset = getMsecTime(strSkipOffset, _nMsecDuration);
		            //}
	                _strSkipOffset = strSkipOffset;

		            //_adParameters = _helper.getSubNodeValue(linear, 'AdParameters', '');
		            _adParameters = _helper.getSubNodeWholeValue(linear, 'AdParameters', '');

		            node = _helper.getSubNode(linear, 'MediaFiles');
		            if (node) {
		                var nodes = _helper.getSubNodes(node, 'MediaFile');
		                if (nodes) {
		                    for (var i = 0; i < nodes.length; i++) {
		                        node = nodes[i];
		                        var url = _helper.getNodeValues(node);

		                        if (url.length > 0) {
		                            var rendition = configureMediaRendition(node, url, i, mediaTypes);

		                            if (rendition) {
		                                _arrMediaFiles.push(rendition);
		                            }
		                        }
		                    }
		                    if (_arrMediaFiles.length === 0) {
					message = 'INCOMPATIBLE MEDIA TYPE, Available = ' + JSON.stringify(mediaTypes);
		                    }
		                }
		                else {
					message = 'MISSING MEDIA FILES';
		                }
		            }
		            else {
				message = 'MISSING MEDIA FILES';
		            }
		        }
		        else {
				message = 'INVALID VAST STRUCTURE';
		        }
		    }
		    return message;
		}

		function trimXml(strVastXml) {
			var nPos = strVastXml.indexOf('<');
			var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
			nPos = strXml.lastIndexOf('>');
			if (nPos !== -1) {
				strXml = strXml.substr(0, nPos + 1);
			}
			return strXml.trim();
		}

		function isValidVastVersion(vastVersion) {
			return vastVersion === '2.0' || vastVersion === '3.0';
		}

		function reportError(errCode, message) {
		    var arrErrorForInternalAndExternal = _arrErrorUrls.concat(_arrInternalErrorUrls);//merge with internal error and external error
		substituteErrorCode(arrErrorForInternalAndExternal, errCode);
		_logger.error(_prefix, 'Error ' + errCode + ' - ' + message);
	        _callback(false, _id, 'vast' + errCode, arrErrorForInternalAndExternal);
		}

		function processNextAd() {

	        //push error urls to global variable _arrInternalErrorUrls which has empty array as an default, it will be used for reportError() to return array of error urls to _callback
	        //the _arrInternalErrorUrls will be emptied by processAd() when exit out of siblings and if there's no internal parsing error
	        var arrStateOfNode = _adTree[_currTreeIdx].state;
	        if (arrStateOfNode && Array.isArray(arrStateOfNode.arrErrorUrls)) {
	            arrStateOfNode.arrErrorUrls.forEach(function(element) {
	                _arrInternalErrorUrls.push(element);
	            });
	        }

			if (_currTreeIdx >= 0) {
				_adTree[_currTreeIdx].children[0] = null;
				_adTree[_currTreeIdx].children.splice(0, 1);
				if (_adTree[_currTreeIdx].children.length === 0) {
					var parentIdx = _adTree[_currTreeIdx].parentIdx;
					_adTree.splice(_currTreeIdx, 1);
					_currTreeIdx = parentIdx;
					if (_currTreeIdx === -1) {
						if (_waterfall && _vastObjects.length > 0) {
							_logger.info(_prefix, 'Waterfall: Vast XML node count detected: # csm nodes: ' + _csmCount + ', # rtb nodes: ' + _rtbCount);
							_callback(true, _id, _vastObjects, null);
						}
						else {
							reportError('900', 'no Ad available');
						}
						return;
					}
					else {
						processNextAd();
						return;
					}
				}
				_adTree[_currTreeIdx].state = preapareAdStateData();
				processAd(_adTree[_currTreeIdx].children[0]);
			}
		}

		function preapareAdStateData() {
			var state = {
				arrTrackings: {},
				arrImpressions: [],
				arrClickUrls: [],
				arrClickTrackings: [],
				arrErrorUrls: [],
				sExtensions: '',
				sequence: 1,
				companions: {required: 'unknown', companions: []},
				icons: []
			};
			return state;
		}

		function saveNotificationUrl(adNode) {
			var id = _helper.getNodeAttributeValue(adNode, 'id');
			if (id.length > 0) {
				var url = _helper.getNodeAttributeValue(adNode, 'notifyurl');
				if (url && url.length > 0) {
					_notifyurls[id] = url;
				}
			}
		}

		function saveBuyerMemberId(adNode) {
			var id = _helper.getNodeAttributeValue(adNode, 'id');
			if (id.length > 0) {
				var buyerId = _helper.getNodeAttributeValue(adNode, 'buyerMemberId');
				if (buyerId && buyerId.length > 0) {
					_buyerMemberIds[id] = buyerId;
				}
			}
		}

		function parseXML(strVastXml) {
		    _startTime = (new Date()).getTime();

		    _sourceVastXml = strVastXml;
		    var strXml = trimXml(strVastXml);
		    if (strXml.length === 0) {
			traceTreePath(_currTreeIdx, 'EMPTY VAST');
			if (_adTree.length === 0) {
				reportError('110', 'no bid response for mediation');
			}
			else {
				processNextAd();
			}
			return;
		    }
		    var xmlDoc = null;
		    if (typeof window.DOMParser !== 'undefined') {
			xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
			if (xmlDoc.documentElement.nodeName === 'parsererror') {
				try{
					_logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
				}
				catch(e) {}
				traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
				if (_adTree.length === 0) {
					reportError('100', 'VAST XML parsing error');
				}
				else {
					processNextAd();
				}
			        return;
			}
		    }
		    else if (typeof window.ActiveXObject !== 'undefined') {
			try {
				xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.loadXML(strXml);
				    if (xmlDoc.parseError.errorCode !== 0) {
					_logger.error(_prefix, xmlDoc.parseError);
					traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
					if (_adTree.length === 0) {
						reportError('100', xmlDoc.parseError.errorCode + ', Error reason = ' + xmlDoc.parseError.reason);
					}
					else {
						processNextAd();
					}
				        return;
				    }
			}
			catch (ex) {
				_logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
				traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
				if (_adTree.length === 0) {
					reportError('100', 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
				}
				else {
					processNextAd();
				}
			        return;
			}
		    }
		    else {
			_logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
			traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
			if (_adTree.length === 0) {
				reportError('100', 'Failed to get vast xml');
			}
			else {
				processNextAd();
			}
		        return;
		    }
		    if (!xmlDoc) {
			traceTreePath(_currTreeIdx, 'INVALID VAST STRUCTURE');
			if (_adTree.length === 0) {
				reportError('102', 'VAST XML parsing error');
			}
			else {
				processNextAd();
			}
		        return;
		    }
		    var vastNode = _helper.getSubNode(xmlDoc, 'VAST');
		    if (!vastNode) {
			traceTreePath(_currTreeIdx, 'EMPTY VAST');
			if (_adTree.length === 0) {
				reportError('110', 'no bid response for mediation');
			}
			else {
				processNextAd();
			}
		        return;
		    }

		    var vastVersion = getVASTVersion(vastNode);
		    if (isValidVastVersion(vastVersion)) {
			if (_topLevel) {
				 _waterfall = _helper.getNodeAttributeBooleanValue(vastNode, 'apn_waterfall');
				 if (_waterfall) {
					 _options.waterfall = true;
				 }
			}
			var ads = _helper.getSubNodes(vastNode, 'Ad');
			if (!ads || ads.length === 0) {
				traceTreePath(_currTreeIdx, 'NO AD NODE');
				if (_adTree.length === 0) {
					reportError('900', 'no Ad available');
				}
				else {
					processNextAd();
				}
			        return;
			}
			var children = [];
			for (var i = 0; i < ads.length; i++) {
				children.push(ads[i]);
				if (_waterfall && _topLevel) {
					saveNotificationUrl(ads[i]);
				}
				if (_topLevel) {
					saveBuyerMemberId(ads[i]);
				}
			}
			var treeElem = {parentIdx: _currTreeIdx, currentIdx: 0, children: children, state: preapareAdStateData()};
			_adTree.push(treeElem);
			treeElem.currentIdx = _adTree.length - 1;
			_currTreeIdx = treeElem.currentIdx;
			processAd(_adTree[_currTreeIdx].children[0], vastVersion);
		    }
		    else {
			traceTreePath(_currTreeIdx, 'INVALID VAST VERSION: ' + vastVersion);
			if (_adTree.length === 0) {
				reportError('102', 'VAST version not supported');
			}
			else {
				processNextAd();
			}
		    }
		}

		function mergeTrackings(idx) {
			for (var event in _adTree[idx].state.arrTrackings) {
				for (var i = 0; i < _adTree[idx].state.arrTrackings[event].length; i++) {
		            if (_arrTrackingsMerge.hasOwnProperty(event)) {
		                if (!isInArray(_arrTrackingsMerge[event], _adTree[idx].state.arrTrackings[event][i])) {
					_arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
		                }
		            }
		            else {
				_arrTrackingsMerge[event] = [];
				_arrTrackingsMerge[event].push(_adTree[idx].state.arrTrackings[event][i]);
		            }
				}
			}
			return _arrTrackingsMerge;
		}

		function mergeTreeTrackings(treeIdx) {
			var idx = treeIdx;
			while (idx >= 0) {
				mergeTrackings(idx);
				idx = _adTree[idx].parentIdx;
			}
			return _arrTrackingsMerge;
		}

		function mergeImpressions(idx) {
			for (var i = 0; i < _adTree[idx].state.arrImpressions.length; i++) {
	            if (!isInArray(_arrImpressionsMerge, _adTree[idx].state.arrImpressions[i])) {
			_arrImpressionsMerge.push(_adTree[idx].state.arrImpressions[i]);
	            }
			}
			return _arrImpressionsMerge;
		}

		function mergeTreeImpressions(treeIdx) {
			var idx = treeIdx;
			while (idx >= 0) {
				mergeImpressions(idx);
				idx = _adTree[idx].parentIdx;
			}
			return _arrImpressionsMerge;
		}

		function mergeClickUrls(idx) {
			for (var i = 0; i < _adTree[idx].state.arrClickUrls.length; i++) {
	            if (!isInArray(_arrClickUrlsMerge, _adTree[idx].state.arrClickUrls[i])) {
			_arrClickUrlsMerge.push(_adTree[idx].state.arrClickUrls[i]);
	            }
			}
			return _arrClickUrlsMerge;
		}

		function mergeTreeClickUrls(treeIdx) {
			var idx = treeIdx;
			while (idx >= 0) {
				mergeClickUrls(idx);
				idx = _adTree[idx].parentIdx;
			}
			return _arrClickUrlsMerge;
		}

		function mergeClickTrackings(idx) {
			for (var i = 0; i < _adTree[idx].state.arrClickTrackings.length; i++) {
	            if (!isInArray(_arrClickTrackingsMerge, _adTree[idx].state.arrClickTrackings[i])) {
			_arrClickTrackingsMerge.push(_adTree[idx].state.arrClickTrackings[i]);
	            }
			}
			return _arrClickTrackingsMerge;
		}

		function mergeTreeClickTrackings(treeIdx) {
			var idx = treeIdx;
			while (idx >= 0) {
				mergeClickTrackings(idx);
				idx = _adTree[idx].parentIdx;
			}
			return _arrClickTrackingsMerge;
		}

		function mergeErrorUrls(idx) {
			for (var i = 0; i < _adTree[idx].state.arrErrorUrls.length; i++) {
	            if (!isInArray(_arrErrorUrlsMerge, _adTree[idx].state.arrErrorUrls[i])) {
			_arrErrorUrlsMerge.push(_adTree[idx].state.arrErrorUrls[i]);
	            }
			}
			return _arrErrorUrlsMerge;
		}

		function mergeTreeErrorUrls(treeIdx) {
			var idx = treeIdx;
			while (idx >= 0) {
				mergeErrorUrls(idx);
				idx = _adTree[idx].parentIdx;
			}
			return _arrErrorUrlsMerge;
		}

		function mergeExtensions(idx) {
	        if (_adTree[idx].state.sExtensions.length > 0) {
			_sExtensions = _sExtensions + _adTree[idx].state.sExtensions;
	        }
			return _sExtensions;
		}

		function mergeTreeExtensions(treeIdx) {
			var idx = treeIdx;
			while (idx >= 0) {
				mergeExtensions(idx);
				idx = _adTree[idx].parentIdx;
			}
			return _sExtensions;
		}

		function mergeCompanions(treeIdx) {
			var idx = treeIdx;
			while (idx > 0) {
				var parentIdx = _adTree[idx].parentIdx;
				APN_CompanionAds.mergeCompanions(_adTree[parentIdx].state.companions, _adTree[idx].state.companions);
				idx = parentIdx;
			}
			if (_adTree[idx].state.companions.required === 'unknown') {
				delete _adTree[idx].state.companions.required;
			}
			return _adTree[idx].state.companions;
		}

		function mergeTreeCompanions(treeIdx) {
			var arrCompanions = {required: 'unknown', companions: []};
			var idx = treeIdx;
			while (idx >= 0) {
				APN_CompanionAds.mergeCompanions(arrCompanions, _adTree[idx].state.companions);
				idx = _adTree[idx].parentIdx;
			}
			return arrCompanions;
		}

		function isProgramExist(arrIcons, program) {
			for (var i = 0; i < arrIcons.length; i++) {
				if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
					return true;
				}
			}
			return false;
		}

		function removeProgram(arrIcons, program) {
			for (var i = 0; i < arrIcons.length; i++) {
				if (arrIcons[i].program.toLowerCase() === program.toLowerCase()) {
					arrIcons[i].splice(i, 1);
					return;
				}
			}
		}

		function mergeIcons(treeIdx) {
			var idx = treeIdx;
			while (idx > 0) {
				var parentIdx = _adTree[idx].parentIdx;
				for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
					// avoid duplicate icons with same program (replace if exist)
					if (isProgramExist(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program)) {
						removeProgram(_adTree[parentIdx].state.icons, _adTree[idx].state.icons[i].program);
					}
					_adTree[parentIdx].state.icons.push(_adTree[idx].state.icons[i]);
				}
				idx = parentIdx;
			}
			return _adTree[idx].state.icons;
		}

		function mergeTreeIcons(treeIdx) {
			var arrIcons = [];
			var idx = treeIdx;
			while (idx >= 0) {
				for (var i = 0; i < _adTree[idx].state.icons.length; i++) {
					// avoid duplicate icons with same program
					if (!isProgramExist(arrIcons, _adTree[idx].state.icons[i].program)) {
						arrIcons.push(_adTree[idx].state.icons[i]);
					}
				}
				idx = _adTree[idx].parentIdx;
			}
			return arrIcons;
		}

		function aggregateCompanions(companionsObj) {
			// get companions with resources and without resorces
			var resCompanions = [];
			var noresCompanions = [];
			var companions = companionsObj.companions;
			if (!companionsObj.companions) {
				return companionsObj;
			}
			var companion;
			var i, j;
			for (i = companions.length - 1; i >= 0; i--) {
				companion = companions[i];
				if (companion.StaticResource || companion.IFrameResource || companion.HTMLResource) {
					var sameSize = false;
					for (j = 0; j < resCompanions.length; j++) {
						if (companion.width === resCompanions[j].width &&
							companion.height === resCompanions[j].height) {
							sameSize = true;
							break;
						}
					}
					if (!sameSize) {
						resCompanions.push(companion);
					}
				}
				else {
					noresCompanions.push(companion);
				}
			}

			// aggregate companions without resorces into companions with resources
			for (i = 0; i < noresCompanions.length; i++) {
				for (j = 0; j < resCompanions.length; j++) {
					if (noresCompanions[i].width === resCompanions[j].width && noresCompanions[i].height === resCompanions[j].height) {
						if ((noresCompanions[i].id && noresCompanions[i].id === resCompanions[j].id) ||	(!noresCompanions[i].id)) {
							// add click trackings
							if (noresCompanions[i].CompanionClickTracking) {
								if (!resCompanions[j].CompanionClickTracking) {
									resCompanions[j].CompanionClickTracking = [];
								}
								resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(noresCompanions[i].CompanionClickTracking);
							}
							// add view trackings
							if (noresCompanions[i].TrackingEvents) {
								if (!resCompanions[j].TrackingEvents) {
									resCompanions[j].TrackingEvents = [];
								}
								resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(noresCompanions[i].TrackingEvents);
							}
						}
					}
				}
			}
			var ret = {companions: resCompanions};
			if (companionsObj.required) {
				ret.required = companionsObj.required;
			}
			return ret;
		}

		function processAd(adNode, vastVersion) {
	        var inLineWrapperNode = _helper.getSubNode(adNode, 'Wrapper');
	        var isWrapper = inLineWrapperNode !== null;
	        if (!isWrapper) {
	            inLineWrapperNode = _helper.getSubNode(adNode, 'InLine');
	        }
	        if (!inLineWrapperNode) {
			traceTreePath(_currTreeIdx, 'MISSING WRAPPER / INLINE NODE');
			processNextAd();
	            return;
	        }

	        if (vastVersion > _vastVersion) {
			_vastVersion = vastVersion;
	        }

	        var id = _helper.getNodeAttributeValue(adNode, 'id');
	        if (_notifyurls.hasOwnProperty(id)) {
			_curNotifyUrl = _notifyurls[id];
	        }
	        if (_buyerMemberIds.hasOwnProperty(id)) {
			_curBuyerMemberId = _buyerMemberIds[id];
	        }
	        // worried only about top level ad sequence attribute
	        if (_currTreeIdx === 0) {
		        var seq = _helper.getNodeAttributeValue(adNode, 'sequence');
		        if (seq) {
				_adTree[_currTreeIdx].state.sequence = Number.parseInt(seq);
		        }
	        }

	        addErrorUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrErrorUrls);
	        addImpressions(inLineWrapperNode, _adTree[_currTreeIdx].state.arrImpressions);
	        addTrackings(inLineWrapperNode, _adTree[_currTreeIdx].state.arrTrackings);
	        addClickUrls(inLineWrapperNode, _adTree[_currTreeIdx].state.arrClickUrls, _adTree[_currTreeIdx].state.arrClickTrackings);
	        addExtensions(inLineWrapperNode, _currTreeIdx);
	        addCompanions(inLineWrapperNode, _currTreeIdx);
	        addIcons(inLineWrapperNode, _currTreeIdx);

	        _arrInternalErrorUrls = [];//clear _arrInternalErrorUrls at this time, all same sibiling's error will be gathered by processNextAd()

	        if (isWrapper) {
	            processWrapper(inLineWrapperNode);
	        }
	        else {
	            var message = addMediaFilesAndDuration(inLineWrapperNode);
	            if (_arrMediaFiles.length === 0 || message.length > 0) {
				traceTreePath(_currTreeIdx, message);
			processNextAd();
			return;
	            }
	            _arrTrackingsMerge = JSON.parse(JSON.stringify(_arrTrackings));
			_arrImpressionsMerge = _arrImpressions.slice(0);
			_arrClickUrlsMerge = _arrClickUrls.slice(0);
			_arrClickTrackingsMerge = _arrClickTrackings.slice(0);
			_arrErrorUrlsMerge = _arrErrorUrls.slice(0);
			_sExtensions = '';

	            var strTrackingUrls = JSON.stringify(mergeTreeTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strImpressionUrls = JSON.stringify(mergeTreeImpressions(_adTree[_currTreeIdx].parentIdx));
	            var strClickUrls = JSON.stringify(mergeTreeClickUrls(_adTree[_currTreeIdx].parentIdx));
	            var strClickTrackingUrls = JSON.stringify(mergeTreeClickTrackings(_adTree[_currTreeIdx].parentIdx));
	            var strErrorUrls = JSON.stringify(mergeTreeErrorUrls(_adTree[_currTreeIdx].parentIdx));
	            var strExtensions = mergeTreeExtensions(_adTree[_currTreeIdx].parentIdx);
	            var strCompanions = JSON.stringify(mergeTreeCompanions(_adTree[_currTreeIdx].parentIdx));
	            var strIcons = JSON.stringify(mergeTreeIcons(_adTree[_currTreeIdx].parentIdx));
	            _sExtensions = '';
	            var companions = mergeCompanions(_currTreeIdx);
	            companions = aggregateCompanions(companions);
	            var vastObj = {
			vastVersion : _vastVersion,
			withWrapper: _withWrapper,
	                mediaFiles: _arrMediaFiles,
	                trackingUrls: mergeTrackings(_currTreeIdx),
	                impressionUrls: mergeImpressions(_currTreeIdx),
	                clickUrls: mergeClickUrls(_currTreeIdx),
	                clickTrackingUrls: mergeClickTrackings(_currTreeIdx),
	                errorUrls: mergeErrorUrls(_currTreeIdx),
	                durationMsecs: _nMsecDuration,
	                skipOffset: _strSkipOffset,
	                extensions: mergeExtensions(_currTreeIdx),
	                adParameters: _adParameters,
	                vastXml: _sourceVastXml,			// inline vast xml
	                extTrackingUrls: strTrackingUrls,
	                extImpressionUrls: strImpressionUrls,
	                extClickUrls: strClickUrls,
	                extClickTrackingUrls: strClickTrackingUrls,
	                extErrorUrls: strErrorUrls,
	                extExtensions: strExtensions,
	                adId: id,
	                sequence: _adTree[0].state.sequence,
	                companionAds: companions,
	                extCompanions: strCompanions,
	                icons: mergeIcons(_currTreeIdx),
	                extIcons: strIcons
	            };
	            if (_waterfall && _curNotifyUrl.length > 0) {
				vastObj.notifyurl = _curNotifyUrl;
	            }
	            if (_curBuyerMemberId.length > 0) {
				vastObj.buyerMemberId = _curBuyerMemberId;
	            }
	            // becaurse waterfall xml always unwrapped, we can set rtb flag base on current ad node
	            var rtb = false;
	            if (_waterfall) {
					var rtbAttr = _helper.getNodeAttributeValue(adNode, 'rtb');
					if (rtbAttr && rtbAttr === 'true') {
						rtb = true;
						vastObj.rtb = true;
					}
	            }
		    if (_terminated) {
				traceTreePath(_currTreeIdx, 'terminated');
		        _callback(false, _id, 'terminated', null);		// terminated
			return;
		    }
		    var mediaTypes = [];
		    for (var i = 0 ; i < _arrMediaFiles.length; i++) {
			if (mediaTypes.indexOf(_arrMediaFiles[i].type) === -1) {
				mediaTypes.push(_arrMediaFiles[i].type);
			}
		    }
		    traceTreePath(_currTreeIdx, 'SUCCESS, Available=' + JSON.stringify(mediaTypes));
		    if (_waterfall) {
			_vastObjects.push(vastObj);
			if (rtb) {
				_rtbCount++;
			}
			else {
				_csmCount++;
			}
			processNextAd();
		    }
		    else {
			_callback(true, _id, vastObj, null);
		    }
	        }
		}

		function prepareExternalTrackers(videoTrackers, impTracker) {

			var url;
			var i;
			var arr;
			var name;
			if (impTracker) {
				_arrImpressions.push(impTracker.trim());
			}
			if (videoTrackers) {
				if (Array.isArray(videoTrackers) && videoTrackers.length === 1) {
					// new format
					var trackers = videoTrackers[0];
					if (trackers.impression_urls) {
						for (i = 0; i < trackers.impression_urls.length; i++) {
							url = trackers.impression_urls[i].trim();
							_arrImpressions.push(url);
						}
					}
					if (trackers.error_urls) {
						for (i = 0; i < trackers.error_urls.length; i++) {
							url = trackers.error_urls[i].trim();
							_arrErrorUrls.push(url);
						}
					}
					if (trackers.video_click_urls) {
						for (i = 0; i < trackers.video_click_urls.length; i++) {
							url = trackers.video_click_urls[i].trim();
							_arrClickTrackings.push(url);
						}
					}
					for (name in trackers.video_events) {
						arr = trackers.video_events[name];
						for (i = 0; i < arr.length; i++) {
							url = arr[i].trim();
			                if (_arrTrackings.hasOwnProperty(name)) {
			                    if (!isInArray(_arrTrackings[name], url)) {
			                        _arrTrackings[name].push(url);
			                    }
			                }
			                else {
			                    _arrTrackings[name] = [url];
			                }
						}
					}
				}
				else {
					for (name in videoTrackers) {
						if (name === 'service') {	// ignore not vast related trackers
							continue;
						}
						if (Array.isArray(videoTrackers[name])) {
							arr = videoTrackers[name];
							for (i = 0; i < arr.length; i++) {
								url = arr[i].trim();
								if (name === 'click') {
									_arrClickTrackings.push(url);
								}
								else if (name === 'error') {
									_arrErrorUrls.push(url);
								}
								else if (name === 'impression') {
									_arrImpressions.push(url);
								}
								else {
					                if (_arrTrackings.hasOwnProperty(name)) {
					                    if (!isInArray(_arrTrackings[name], url)) {
					                        _arrTrackings[name].push(url);
					                    }
					                }
					                else {
					                    _arrTrackings[name] = [url];
					                }
								}
							}
						}
						else {
							url = videoTrackers[name].trim();
							if (name === 'click') {
								_arrClickTrackings.push(url);
							}
							else if (name === 'error') {
								_arrErrorUrls.push(url);
							}
							else if (name === 'impression') {
								_arrImpressions.push(url);
							}
							else {
				                if (_arrTrackings.hasOwnProperty(name)) {
				                    if (!isInArray(_arrTrackings[name], url)) {
				                        _arrTrackings[name].push(url);
				                    }
				                }
				                else {
				                    _arrTrackings[name] = [url];
				                }
							}
						}
					}
				}
			}
		}

		this.parse = function(strVastXml, videoTrackers, impTracker, callback) {
			_callback = callback;
			prepareExternalTrackers(videoTrackers, impTracker);
			_topLevel = true;
			parseXML(strVastXml);
		};

		this.terminate = function() {
			_terminated = true;
		};
	};

	var VastModifier = function(parserData, adToken, notifyUrl, contentSource, buyerMemberId) {

		var _logger = __webpack_require__(2);
		var _prefix = 'VAST Parser';

		var _parserData = parserData;
		var _adToken = adToken;
		var _notifyUrl = notifyUrl;
		var _buyerMemberId = buyerMemberId;
		var _contentSource = contentSource;
		var _helper = new VastXMLParserHelper();

		function trimXml(strVastXml) {
			var nPos = strVastXml.indexOf('<');
			var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
			nPos = strXml.lastIndexOf('>');
			if (nPos !== -1) {
				strXml = strXml.substr(0, nPos + 1);
			}
			return strXml;
		}

		function prepareDocObject(strVastXml) {
		    var strXml = trimXml(strVastXml);
		    var xmlDoc = null;
		    if (typeof window.DOMParser !== 'undefined') {
			xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
			if (xmlDoc.documentElement.nodeName === 'parsererror') {
				try {
					_logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
				}
				catch(e) {}
			        return null;
			}
		    }
		    else if (typeof window.ActiveXObject !== 'undefined') {
			try {
				xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.loadXML(strXml);
				    if (xmlDoc.parseError.errorCode !== 0) {
					_logger.error(_prefix, xmlDoc.parseError);
				        return null;
				    }
			}
			catch (ex) {
				_logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
			        return null;
			}
		    }
		    else {
			_logger.error(_prefix, 'Failed to get vast xml parser');
		        return null;
		    }
		    return xmlDoc;
		}

		var _xmlDoc = prepareDocObject(parserData.vastXml);

		function updateVastVersion(vastVersion) {
			if (_xmlDoc) {
			    var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
			    if (vastNode) {
					var attr = _xmlDoc.createAttribute('version');
					attr.value = vastVersion;
			        vastNode.setAttributeNode(attr);
			    }
			}
		}

		updateVastVersion(parserData.vastVersion);

		function appendAttributesToAdNode() {
			if (_xmlDoc) {
			    var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
			    if (vastNode) {
				var ads = _helper.getSubNodes(vastNode, 'Ad');
				if (ads && ads.length > 0) {
					for (var i = 0; i < ads.length; i++) {
						if (_notifyUrl) {
							var attr = _xmlDoc.createAttribute('notifyurl');
							attr.value = _notifyUrl;
							ads[i].setAttributeNode(attr);
						}
						if (_contentSource && _contentSource === 'rtb') {
							var attr2 = _xmlDoc.createAttribute('rtb');
							attr2.value = 'true';
							ads[i].setAttributeNode(attr2);
						}
						var attr3 = _xmlDoc.createAttribute('sequence');
						attr3.value = _parserData.sequence.toString();
						ads[i].setAttributeNode(attr3);
						if (_buyerMemberId) {
							var attr4 = _xmlDoc.createAttribute('buyerMemberId');
							attr4.value = _buyerMemberId;
							ads[i].setAttributeNode(attr4);
						}
					}
				}
			    }
			}
		}

		appendAttributesToAdNode();

		function addCdataBlock(parentNode, url) {
			var cdata = _xmlDoc.createCDATASection(url);
			parentNode.appendChild(cdata);
		}

		var _creativesNode = null;
		function getLinearNode() {
			if (_adToken) {
			    var vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
				var attr = _xmlDoc.createAttribute('adtoken');
				attr.value = _adToken;
				vastNode.setAttributeNode(attr);
			}

	        var inLine = _helper.getSubNode(_xmlDoc, 'InLine');
	        if (!inLine) {
	            return null;	// VAST xml has no InLine node
	        }

	        var i;
	        if (_parserData.extImpressionUrls && typeof _parserData.extImpressionUrls === 'string') {
			var impTrackers = JSON.parse(_parserData.extImpressionUrls);
			if (Array.isArray(impTrackers) && impTrackers.length > 0) {
				for (i = 0; i < impTrackers.length; i++) {
				var impNode = _xmlDoc.createElement('Impression');
				//impNode.textContent = impTrackers[i];
				addCdataBlock(impNode, impTrackers[i]);
				inLine.appendChild(impNode);
				}
			}
				delete _parserData.extImpressionUrls;
	        }

	        if (_parserData.extErrorUrls && typeof _parserData.extErrorUrls === 'string') {
			var errTrackers = JSON.parse(_parserData.extErrorUrls);
			if (Array.isArray(errTrackers) && errTrackers.length > 0) {
				for (i = 0; i < errTrackers.length; i++) {
				var errNode = _xmlDoc.createElement('Error');
				//errNode.textContent = errTrackers[i];
				addCdataBlock(errNode, errTrackers[i]);
				inLine.appendChild(errNode);
				}
			}
				delete _parserData.extErrorUrls;
	        }

	        if (_parserData.extExtensions && typeof _parserData.extExtensions === 'string') {
			var extensions = _parserData.extExtensions;
			if (extensions.length > 0) {
				var extensionsNode = _helper.getSubNode(inLine, 'Extensions');
				if (!extensionsNode) {
					extensionsNode = _xmlDoc.createElement('Extensions');
					inLine.appendChild(extensionsNode);
				extensionsNode.innerHTML = extensions;
				}
				else {
				extensionsNode.innerHTML = extensionsNode.innerHTML.toString() + extensions;
				}
			}
				delete _parserData.extExtensions;
	        }

	        _creativesNode = _helper.getSubNode(inLine, 'Creatives');
			if (!_creativesNode) {
				_creativesNode = _xmlDoc.createElement('Creatives');
				inLine.appendChild(_creativesNode);
			}
			var linearNode = _helper.getSubNode(_creativesNode, 'Linear');
			if (!linearNode) {
				var creativeNode = _xmlDoc.createElement('Creative');
				_creativesNode.appendChild(creativeNode);
				linearNode = _xmlDoc.createElement('Linear');
				creativeNode.appendChild(linearNode);
			}
			return linearNode;
		}

		function iconAlreadyExist(iconsNode, program) {
			var icons = _helper.getSubNodes(iconsNode, 'Icon');
			if (icons && icons.length > 0) {
				for (var i = 0; i < icons.length; i++) {
				var programAttr = _helper.getNodeAttributeValue(icons[i], 'program');
				if (programAttr.toLowerCase() === program.toLowerCase()) {
					return true;
				}
				}
			}
			return false;
		}

		function appendTrackings(linearNode) {
			var i;
	        if (_parserData.extTrackingUrls && typeof _parserData.extTrackingUrls === 'string' &&
				_parserData.extTrackingUrls.length > 5) {
			var videoTrackers = JSON.parse(_parserData.extTrackingUrls);
				var trackersNode = _helper.getSubNode(linearNode, 'TrackingEvents');
				if (!trackersNode) {
					trackersNode =  _xmlDoc.createElement('TrackingEvents');
					linearNode.appendChild(trackersNode);
				}
				// enumerate video trackers
				for (var name in videoTrackers) {
					var urls = videoTrackers[name];
					for (i = 0; i < urls.length; i++) {
						var trackerNode = _xmlDoc.createElement('Tracking');
						var attr = _xmlDoc.createAttribute('event');
						attr.value = name;
						trackerNode.setAttributeNode(attr);
						//trackerNode.textContent = urls[i];
				addCdataBlock(trackerNode, urls[i]);
						trackersNode.appendChild(trackerNode);
					}
				}
				delete _parserData.extTrackingUrls;
	        }

	        var videoClicksNode;
	        if (_parserData.extClickUrls && typeof _parserData.extClickUrls === 'string') {
			var videoClicks = JSON.parse(_parserData.extClickUrls);
			if (Array.isArray(videoClicks) && videoClicks.length > 0) {
				videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
				if (!videoClicksNode) {
					videoClicksNode =  _xmlDoc.createElement('TrackingEvents');
					linearNode.appendChild(videoClicksNode);
				}
				if (!_helper.getSubNode(videoClicksNode, 'ClickThrough')) {
					var clickNode =  _xmlDoc.createElement('ClickThrough');
					//clickNode.textContent = videoClicks[0];
				addCdataBlock(clickNode, videoClicks[0]);
					videoClicksNode.appendChild(clickNode);
				}
			}
				delete _parserData.extClickUrls;
	        }

	        if (_parserData.extClickTrackingUrls && typeof _parserData.extClickTrackingUrls === 'string') {
			var clickTrackings = JSON.parse(_parserData.extClickTrackingUrls);
			if (Array.isArray(clickTrackings) && clickTrackings.length > 0) {
				videoClicksNode = _helper.getSubNode(linearNode, 'VideoClicks');
				if (!videoClicksNode) {
					videoClicksNode =  _xmlDoc.createElement('VideoClicks');
					linearNode.appendChild(videoClicksNode);
				}
				for (i = 0; i < clickTrackings.length; i++) {
					var clickTrackingNode =  _xmlDoc.createElement('ClickTracking');
					//clickTrackingNode.textContent = clickTrackings[i];
				addCdataBlock(clickTrackingNode, clickTrackings[i]);
					videoClicksNode.appendChild(clickTrackingNode);
				}
			}
				delete _parserData.extClickTrackingUrls;
	        }

			if (_parserData.extIcons && typeof _parserData.extIcons === 'string') {
				var icons = JSON.parse(_parserData.extIcons);
				if (Array.isArray(icons) && icons.length > 0) {
					var iconsNode = _helper.getSubNode(linearNode, 'Icons');
					if (!iconsNode) {
						iconsNode = _xmlDoc.createElement('Icons');
						linearNode.appendChild(iconsNode);
					}
					for (i = 0; i < icons.length; i++) {
						// avoid duplicate icons with same program
						if (!iconAlreadyExist(iconsNode, icons[i].program)) {
							var iconNode = APN_Icons.createIconNode(_xmlDoc, icons[i]);
							if (iconNode) {
								iconsNode.appendChild(iconNode);
							}
						}
					}
				}
				delete _parserData.extIcons;
			}
		}

		function appendNewCompanion(companionAdsNode, newCompanion) {
			// get companions with resources
			var companionNode, j;
			var companionAdsObj = {companions: []};
			APN_CompanionAds.parse(companionAdsObj, companionAdsNode, _helper);
			var resCompanions = companionAdsObj.companions;
			if (newCompanion.StaticResource || newCompanion.IFrameResource || newCompanion.HTMLResource) {
				var sameSize = false;
				for (j = 0; j < resCompanions.length; j++) {
					if (newCompanion.width === resCompanions[j].width &&
							newCompanion.height === resCompanions[j].height) {
						sameSize = true;
						break;
					}
				}
				if (!sameSize) {
					companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, newCompanion);
					companionAdsNode.appendChild(companionNode);
				}
			}
			else {
				// aggregate companion without resorces into companions with resources
				var needUpdate = false;
				for (j = 0; j < resCompanions.length; j++) {
					if (newCompanion.width === resCompanions[j].width && newCompanion.height === resCompanions[j].height) {
						if ((newCompanion.id && newCompanion.id === resCompanions[j].id) ||	(!newCompanion.id)) {
							// add click trackings
							if (newCompanion.CompanionClickTracking) {
								if (!resCompanions[j].CompanionClickTracking) {
									resCompanions[j].CompanionClickTracking = [];
								}
								resCompanions[j].CompanionClickTracking = resCompanions[j].CompanionClickTracking.concat(newCompanion.CompanionClickTracking);
							}
							// add view trackings
							if (newCompanion.TrackingEvents) {
								if (!resCompanions[j].TrackingEvents) {
									resCompanions[j].TrackingEvents = [];
								}
								resCompanions[j].TrackingEvents = resCompanions[j].TrackingEvents.concat(newCompanion.TrackingEvents);
							}
							needUpdate = true;
							break;
						}
					}
				}
				if (needUpdate) {
					while (companionAdsNode.firstChild) {
						companionAdsNode.removeChild(companionAdsNode.firstChild);
					}
					for (var i = 0; i < resCompanions.length; i++) {
						companionNode = APN_CompanionAds.createCompanionNode(_xmlDoc, resCompanions[i]);
						companionAdsNode.appendChild(companionNode);
					}
				}
			}
		}

		function appendCompanions() {
			if (_parserData.extCompanions && typeof _parserData.extCompanions === 'string') {
				var companions = JSON.parse(_parserData.extCompanions);
				if (Array.isArray(companions.companions) && companions.companions.length > 0) {
					var companionAdsNode = _helper.getSubNode(_creativesNode, 'CompanionAds');
					if (!companionAdsNode) {
						companionAdsNode = _xmlDoc.createElement('CompanionAds');
						_creativesNode.appendChild(companionAdsNode);
					}
					var attr;
					if (companions.required !== 'unknown') {
						attr = _xmlDoc.createAttribute('required');
						attr.value = companions.required;
						companionAdsNode.setAttributeNode(attr);
					}
					for (var i = 0; i < companions.companions.length; i++) {
						appendNewCompanion(companionAdsNode, companions.companions[i]);
					}
				}
			}
		}

		this.addTrackers = function() {
			if (!_xmlDoc) {
				return '';
			}
			var linearNode = getLinearNode();
			if (!linearNode) {
				return '';
			}
			appendTrackings(linearNode);
			if (_creativesNode) {
				appendCompanions();
			}
			var strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
			return strOut;
		};
	};

	var VastMerger = function(xmlList) {

		var _logger = __webpack_require__(2);
		var _prefix = 'VAST Parser';

		var _xmls = xmlList;
		var _helper = new VastXMLParserHelper();

		function trimXml(strVastXml) {
			var nPos = strVastXml.indexOf('<');
			var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
			nPos = strXml.lastIndexOf('>');
			if (nPos !== -1) {
				strXml = strXml.substr(0, nPos + 1);
			}
			return strXml;
		}

		function prepareDocObject(strVastXml) {
		    var strXml = trimXml(strVastXml);
		    var xmlDoc = null;
		    if (typeof window.DOMParser !== 'undefined') {
			xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
			if (xmlDoc.documentElement.nodeName === 'parsererror') {
				try {
					_logger.error(_prefix, 'Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
				}
				catch(e) {}
			        return null;
			}
		    }
		    else if (typeof window.ActiveXObject !== 'undefined') {
			try {
				xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.loadXML(strXml);
				    if (xmlDoc.parseError.errorCode !== 0) {
					_logger.error(_prefix, xmlDoc.parseError);
				        return null;
				    }
			}
			catch (ex) {
				_logger.error(_prefix, 'Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
			        return null;
			}
		    }
		    else {
			_logger.error(_prefix, 'Failed to get vast xml parser');
		        return null;
		    }
		    return xmlDoc;
		}

		var _xmlDoc = prepareDocObject(_xmls[0]);
		if (!_xmlDoc) {
			return;
		}

	    var _vastNode = _helper.getSubNode(_xmlDoc, 'VAST');
		var attr = _xmlDoc.createAttribute('apn_waterfall');
		attr.value = true;
		_vastNode.setAttributeNode(attr);

		var adNodes = [];
		for (var i = 0; i < _xmls.length; i++) {
			var doc = prepareDocObject(_xmls[i]);
		    var vastNode = _helper.getSubNode(doc, 'VAST');
			var ads = _helper.getSubNodes(vastNode, 'Ad');
			if (ads && ads.length > 0) {
				for (var j = 0; j < ads.length; j++) {
					adNodes.push(ads[j]);
				}
			}
		}

		adNodes.sort(function(a, b) {
			return _helper.getNodeAttributeNumberValue(a, 'sequence') - _helper.getNodeAttributeNumberValue(b, 'sequence');
		});

		_vastNode.innerHTML = '';
		for (i = 0; i < adNodes.length; i++) {
			_vastNode.appendChild(adNodes[i]);
		}

		this.getVastXml = function() {
			if (!_xmlDoc) {
				return '';
			}
			var strOut = (new XMLSerializer()).serializeToString(_xmlDoc);
			return strOut;
		};
	};

	module.exports = {
		    /** Describe Parser Main Entry Point Here.
		     * @param {string} strVastXml - VAST xml.
		     * @param {function} fnCallback - Callback function.
		     * 		Callback parameters:
		     * 			succ: true if success, false otherwise
		     * 			sourceId: mediation element identificator
		     * 			data: object is success, error code otherwise
		     * 			arrErrorUrl: null if success, list of tracking url parsed from vast xml untill parsing has failed
		     * @param {object} id - mediation element identificator.
		     * @param {number} nMsecTimeout - time out in miliseconds.
		     * @param {object} videoTrackers - video_trackings field from impbus request.
		     * @param {string} videoTrackers - imp_tracking_url field from impbus request.
		     * @param {object} options - publisher options.
		     */
			parse: function(strVastXml, fnCallback, id, nMsecTimeout, videoTrackers, impTracker, options) {
				var parserObj = new VastParser(id, nMsecTimeout, options);
				parserObj.parse(strVastXml, videoTrackers, impTracker,
					function(succ, sourceId, data, arrErrorUrls) {
						if (fnCallback) {
							fnCallback(succ, sourceId, data, arrErrorUrls);
						}
						parserObj = null;
					});
				return parserObj;
			},

			/** Describe Vast Unwrapping Entry Point Here.
			 * @param {object} parserData - object returned after successful parsing.
			 * @param {string} adToken - optional ad identificator used for debug mode
			 * @return {string} - unwrapped VAST xml.
			 */
			getUnwrappedVastTag: function(parserData, adToken, notifyUrl, contentSource, buyerMemberId) {
				if (!parserData || !parserData.vastXml) {
					return null;
				}
				var obj = new VastModifier(parserData, adToken, notifyUrl, contentSource, buyerMemberId);
				var xml = obj.addTrackers();
				obj = null;
				return xml;
			},

			/** Describe Vast Merging VAST XMLs Entry Point Here.
			 * @param {object} xmlListData - object containes XMLs and additional data:
			 * 					xml: VAST XML
			 * 					notifyUrl: notification url from impbus response
			 * 					buyerMemberId: buyer member idenfificator from impbus response
			 * @return {string} - merged VAST xml.
			 */
			getMergedVastTag: function(xmlList) {
				if (!xmlList || xmlList.length === 0) {
					return null;
				}
				var obj = new VastMerger(xmlList);
				var xml = obj.getVastXml();
				obj = null;
				return xml;
			}
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	var CompanionAds = {

	    parse: function (companionAdsDest, companionAdsNode, helper) {
		var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
		if (req && req.length > 0) {
			companionAdsDest.required = req;
		}

	        var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
			//var companion = JSON.parse(JSON.stringify(APN_Companion));
			var companion = {};

			// required attributes
			var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
			var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
			if (width <= 0 || height <= 0) {
				continue;
			}
			companion.width = width;
			companion.height = height;

			// optional attributes and subnodes
			var val = helper.getNodeAttributeValue(node, 'id');
			if (val) {
				companion.id = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
			if (val > 0) {
				companion.assetWidth = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
			if (val > 0) {
				companion.assetHeight = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
			if (val > 0) {
				companion.expandedWidth = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
			if (val > 0) {
				companion.expandedHeight = val;
			}

			val = helper.getNodeAttributeValue(node, 'apiFramework');
			if (val) {
				companion.apiFramework = val;
			}

			val = helper.getNodeAttributeValue(node, 'adSlotID');
			if (val) {
				companion.adSlotID = val;
			}

			val = helper.getNodeAttributeValue(node, 'required');
			if (val) {
				companion.required = val;
			}

			val = helper.getSubNodeValue(node, 'AltText');
			if (val) {
				companion.AltText = val;
			}

			val = helper.getSubNodeValue(node, 'AdParameters');
			if (val) {
				companion.AdParameters = val;
			}

			var resource = helper.getSubNode(node, 'StaticResource');
			if (resource) {
				val = helper.getNodeAttributeValue(resource, 'creativeType');
				if (val) {
					// validate capability
					var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
					var isMobile = false;
					if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
						isMobile = true;
					}
					if (isMobile && flashOnlyType) {
						// ignore this companion
						continue;
					}

					var staticResource = {type: val};
					val = helper.getNodeValues(resource);
					if (val) {
						staticResource.src = val;
					companion.StaticResource = staticResource;
					}
				}
			}

			val = helper.getSubNodeWholeValue(node, 'IFrameResource');
			if (val) {
				companion.IFrameResource = val;
			}

			val = helper.getSubNodeWholeValue(node, 'HTMLResource');
			if (val) {
				companion.HTMLResource = val;
			}

			val = helper.getSubNodeValue(node, 'CompanionClickThrough');
			if (val) {
				companion.CompanionClickThrough = val;
			}

			var j;
			var trackingNode;
			var url;
	                var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
	                if (clickTrackinEvents) {
				companion.CompanionClickTracking = [];
				for (j = 0; j < clickTrackinEvents.length; j++) {
					trackingNode = clickTrackinEvents[j];
				url = helper.getNodeValues(trackingNode);
				if (url) {
					companion.CompanionClickTracking.push(url);
				}
				}
	                }

	                var trackinEvents = helper.getSubNodes(node, 'Tracking');
	                if (trackinEvents) {
				companion.TrackingEvents = [];
				for (j = 0; j < trackinEvents.length; j++) {
					trackingNode = trackinEvents[j];
				var event = helper.getNodeAttributeValue(trackingNode, 'event');
				url = helper.getNodeValues(trackingNode);
				if (event && url) {
					companion.TrackingEvents.push({eventType: event, url: url});
				}
				}
	                }

	                companionAdsDest.companions.push(companion);
	            }
	        }
	    },

	    mergeCompanions: function(companionAdsDest, companionAds) {
		if (companionAdsDest.required === 'unknown') {
			companionAdsDest.required = companionAds.required;
		}
		companionAdsDest.companions = companionAdsDest.companions.concat(companionAds.companions);
	    },

	    createCompanionNode: function (xmlDoc, data) {
		var companion = xmlDoc.createElement('Companion');
		var i;
		var elem;
		var attr;
		var cdata;

		var arrAttrs = ['id', 'width', 'height', 'assetWidth', 'assetHeight', 'expandedWidth', 'expandedHeight',
		                'apiFramework', 'adSlotID', 'required'];
		for (i = 0; i < arrAttrs.length; i++) {
			if (data.hasOwnProperty(arrAttrs[i])) {
				attr = xmlDoc.createAttribute(arrAttrs[i]);
				attr.value = data[arrAttrs[i]];
				companion.setAttributeNode(attr);
			}
		}

			if (data.hasOwnProperty('StaticResource')) {
			elem = xmlDoc.createElement('StaticResource');
				attr = xmlDoc.createAttribute('creativeType');
				attr.value = data.StaticResource.type;
				elem.setAttributeNode(attr);
				cdata = xmlDoc.createCDATASection(data.StaticResource.src);
				elem.appendChild(cdata);
			companion.appendChild(elem);
			}

		var arrNodes = ['AdParameters', 'IFrameResource', 'HTMLResource', 'CompanionClickThrough'];
		for (i = 0; i < arrNodes.length; i++) {
			if (data.hasOwnProperty(arrNodes[i])) {
			elem = xmlDoc.createElement(arrNodes[i]);
				cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
				elem.appendChild(cdata);
			companion.appendChild(elem);
			}
		}

			if (data.hasOwnProperty('AltText')) {
			elem = xmlDoc.createElement('AltText');
			try {
				elem.innerHTML = data.AltText;
			}
			catch(ex) {
				// IE 11 does not allow set innerHTML property
				try {
					elem.textContent = data.AltText;
				}
				catch(ex2) {

				}
			}
			companion.appendChild(elem);
			}

			if (data.hasOwnProperty('CompanionClickTracking')) {
			for (i = 0; i < data.CompanionClickTracking.length; i++) {
				var tracking = xmlDoc.createElement('CompanionClickTracking');
				cdata = xmlDoc.createCDATASection(data.CompanionClickTracking[i]);
				tracking.appendChild(cdata);
				companion.appendChild(tracking);
			}
			}

			if (data.hasOwnProperty('TrackingEvents')) {
			elem = xmlDoc.createElement('TrackingEvents');
				// enumerate trackers
			for (i = 0; i < data.TrackingEvents.length; i++) {
				var event = xmlDoc.createElement('Tracking');
					attr = xmlDoc.createAttribute('event');
					attr.value = data.TrackingEvents[i].eventType;
					event.setAttributeNode(attr);
				cdata = xmlDoc.createCDATASection(data.TrackingEvents[i].url);
				event.appendChild(cdata);
				elem.appendChild(event);
			}
			companion.appendChild(elem);
			}

		return companion;
	    }
	};

	module.exports = CompanionAds;

/***/ },
/* 31 */
/***/ function(module, exports) {

	var Icons = {

	    parse: function (IconsDest, IconsNode, helper) {
	        var nodes = helper.getSubNodes(IconsNode, 'Icon');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
			var icon = {};

			// required attributes
			var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
			var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
			var program = helper.getNodeAttributeValue(node, 'program');
			var xPosition = helper.getNodeAttributeValue(node, 'xPosition');
			var yPosition = helper.getNodeAttributeValue(node, 'yPosition');
			if (width <= 0 || height <= 0 || program.length === 0 || xPosition.length === 0 || yPosition.length === 0) {
				continue;
			}
			icon.width = width;
			icon.height = height;
			icon.program = program;
			icon.xPosition = xPosition;
			icon.yPosition = yPosition;

			// optional attributes and subnodes
			var val = helper.getNodeAttributeValue(node, 'apiFramework');
			if (val) {
				icon.apiFramework = val;
			}

			val = helper.getNodeAttributeValue(node, 'offset');
			if (val) {
				// validate
				if (isNaN(Date.parse('January 1, 1970 ' + val))) {
					// invalid time format
					continue;
				}
				icon.offset = val;
			}

			val = helper.getNodeAttributeValue(node, 'duration');
			if (val) {
				// validate
				if (isNaN(Date.parse('January 1, 1970 ' + val))) {
					// invalid time format
					continue;
				}
				icon.duration = val;
			}

			var resource = helper.getSubNode(node, 'StaticResource');
			if (resource) {
				val = helper.getNodeAttributeValue(resource, 'creativeType');
				if (val) {
					// validate capability
					var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
					var isMobile = false;
					if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
						isMobile = true;
					}
					if (isMobile && flashOnlyType) {
						// ignore this companion
						continue;
					}

					var staticResource = {type: val};
					val = helper.getNodeValues(resource);
					if (val) {
						staticResource.src = val;
						icon.StaticResource = staticResource;
					}
				}
			}

			val = helper.getSubNodeWholeValue(node, 'IFrameResource');
			if (val) {
				icon.IFrameResource = val;
			}

			val = helper.getSubNodeWholeValue(node, 'HTMLResource');
			if (val) {
				icon.HTMLResource = val;
			}

			var iconClicks = helper.getSubNode(node, 'IconClicks');
			if (iconClicks) {
				val = helper.getSubNodeValue(node, 'IconClickThrough');
				if (val) {
					icon.IconClickThrough = val;
				}

				val = helper.getSubNodeValue(node, 'IconClickTracking');
				if (val) {
					icon.IconClickTracking = val;
				}
			}

			val = helper.getSubNodeValue(node, 'IconViewTracking');
			if (val) {
				icon.IconViewTracking = val;
			}

			IconsDest.push(icon);
	            }
	        }
	    },

	    createIconNode: function (xmlDoc, data) {
		var icon = xmlDoc.createElement('Icon');
		var i;
		var elem;
		var attr;
		var cdata;

		var arrAttrs = ['width', 'height', 'program', 'xPosition', 'yPosition', 'apiFramework', 'offset', 'duration'];
		for (i = 0; i < arrAttrs.length; i++) {
			if (data.hasOwnProperty(arrAttrs[i])) {
				attr = xmlDoc.createAttribute(arrAttrs[i]);
				attr.value = data[arrAttrs[i]];
				icon.setAttributeNode(attr);
			}
		}

			if (data.hasOwnProperty('StaticResource')) {
			elem = xmlDoc.createElement('StaticResource');
				attr = xmlDoc.createAttribute('creativeType');
				attr.value = data.StaticResource.type;
				elem.setAttributeNode(attr);
				cdata = xmlDoc.createCDATASection(data.StaticResource.src);
				elem.appendChild(cdata);
			icon.appendChild(elem);
			}

		var arrNodes = ['IFrameResource', 'HTMLResource', 'IconViewTracking'];
		for (i = 0; i < arrNodes.length; i++) {
			if (data.hasOwnProperty(arrNodes[i])) {
			elem = xmlDoc.createElement(arrNodes[i]);
				cdata = xmlDoc.createCDATASection(data[arrNodes[i]]);
				elem.appendChild(cdata);
			icon.appendChild(elem);
			}
		}

			if (data.hasOwnProperty('IconClickThrough') || data.hasOwnProperty('IconClickTracking')) {
			var iconClicks = xmlDoc.createElement('IconClicks');
			if (data.hasOwnProperty('IconClickThrough')) {
			elem = xmlDoc.createElement('IconClickThrough');
				cdata = xmlDoc.createCDATASection(data.IconClickThrough);
				elem.appendChild(cdata);
				iconClicks.appendChild(elem);
			}
			if (data.hasOwnProperty('IconClickTracking')) {
			elem = xmlDoc.createElement('IconClickTracking');
				cdata = xmlDoc.createCDATASection(data.IconClickTracking);
				elem.appendChild(cdata);
				iconClicks.appendChild(elem);
			}
			icon.appendChild(iconClicks);
			}

		return icon;
	    }
	};

	module.exports = Icons;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "CapabilityDetection";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.debug(prefixOfLog,message);
	};


	/**
	 * Capability Detection module.
	 * @module CapabilityDetection
	 */

	function isMobile(){
	    if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
	        return true;
	    }
	    return false;
	}

	function hasFlashPlugin(){
	    var flash_installed = typeof navigator.plugins !== 'undefined' && typeof navigator.plugins['Shockwave Flash'] === 'object';
	    if (!flash_installed) {
	        flash_installed = window.ActiveXObject && (new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
	    }
	    return flash_installed;
	}

	function isFlashOnlyType(type) {
	    return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
	        type === 'application/x-shockwave-flash';
	}

	function isHtml5VpaidType(type) {
	    return type === 'application/javascript' || type === 'application/x-javascript';
	}

	function isIphone() {
	    var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	}

	function isIos() {
	    var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	}

	function isAndroid() {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	}

	module.exports = {
	    /** Checks for Flash support.
	     * @returns {boolean} True is flash is supported, false otherwise.
	     */
	    supportsFlash: function() {
	        return !isMobile() && hasFlashPlugin();
	    },

	    /** Detects browser on mobile devices.
	     * @returns {boolean} True is browser on mobile, false otherwise.
	     */
	    isBrowserOnMobile: function() {
	        return isMobile();
	    },

	    /** Detects browser.
	     * @returns {string} browser name.
	     */
	    getBrowserName: function() {
	        var ua = navigator.userAgent,
	            tem,
	            M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

	        if (/trident/i.test(M[1])) {
	            tem =/\brv[ :]+(\d+)/g.exec(ua) || [];
	            return 'IE';
	        }
	        if (M[1] === 'Chrome') {
	            tem = ua.match(/\bOPR\/(\d+)/);
	            if (tem !== null) {
	                return 'Opera';
	            }
	        }
	        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
	        if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
	            M.splice(1,1,tem[1]);
	        }
	        return M[0];
	    },

	    /** Detects is video type playable for particular browser.
	     * @param {string} mimeType - media type from VAST xml.
	     * @param {string} codec - codec from VAST xml if present.
	     * @returns {boolean} True if playable, false otherwise.
	     */
	    canPlay: function(mimeType, codec) {

	        //VIDLA-139
	        //Edge browser can have error when calling canPlayType method in video element - this is suggested safe way for all browsers reffered by https://developer.microsoft.com/en-us/microsoft-edge/platform/documentation/dev-guide/html5/video/
	        var wrapperOfCanPlayType = function(vid, type, codec) {
	            debug("invoke canPlayType with video(" + vid + ") and type(" + type + ") and codec(" + codec + ")");
	            if (vid && vid.canPlayType) {
	                var result = vid.canPlayType(type + ';codecs="' + codec + '"');
	                debug("result : " + result);
	                return result;
	            } else {
	                debug("result : failed to invoke canPlayType with " + vid);
	                return "";
	            }
	        };

	        var alternativeCodec = null;
	        if (isFlashOnlyType(mimeType.toLowerCase())) {
	            return !isMobile() && hasFlashPlugin();
	        }
	        else if (isHtml5VpaidType(mimeType.toLowerCase())) {
	            return true;		// always allow to play html5 vpaid
	        }
	        else {
	            var type = mimeType.toLowerCase();
	            if (!codec || codec === '') {
	                if (type === 'video/mp4') {
	                    codec = 'avc1.42E01E,mp4a.40.2';
	                    //only test with video codec for alternativeCodec
	                    alternativeCodec = 'avc1.42E01E';//iphone7 + iOS10GM will return "maybe" for the "mp4a.40.2", so alternative codecs should be tested more to provide extra opportunity to be choosen by canPlayType
	                    //vid.canPlayType("video/mp4;codecs=avc1.42E01E,mp4a.40.2");
	                    //iphone 7 + iOS10GM : maybe
	                    //iphone 6 + iOS10GM : probably
	                }
	                else if (type === 'video/webm') {
	                    codec = 'vp8,vorbis';
	                }
	                else if (type === 'video/ogg') {
	                    codec = 'theora,vorbis';
	                }
	                else {
	                    return false;	// unknown video mime type
	                }
	            }
	            var vid = document.createElement('video');
	            //var response = vid.canPlayType(type + ';codecs="' + codec + '"');//VIDLA-139
	            var response = wrapperOfCanPlayType(vid, type, codec);



	            if (response === 'probably') {
	                return true;
	            }
	            if (response === 'maybe') {
	                if (type === 'video/webm') {
	                    return true;
	                }
	                //if alternativeCodec exists, do a test once again to give additoinal opportunity to be tested
	                //if (alternativeCodec && vid.canPlayType(type + ';codecs="' + alternativeCodec + '"') === "probably") {
	                //VIDLA-139
	                if (alternativeCodec && wrapperOfCanPlayType(vid, type, alternativeCodec) === "probably") {
	                    return true;
	                }
	            }
	            return false;
	        }
	    },

	    /** Returns information about device where ad is running.
	     * @returns {string} One of the following: desktop-flash, desktop-no-flash, mobile-Android, mobile-iOS, mobile-unknown.
	     */
	    getPlatformType: function() {
	        if (isMobile()) {
	            if (isAndroid()) {
	                return 'mobile-Android';
	            }
	            if (isIos()) {
	                return 'mobile-iOS';
	            }
	            return 'mobile-unknown';
	        }
	        else {
	            if (hasFlashPlugin()) {
	                return 'desktop-flash';
	            }
	            return 'desktop-no-flash';
	        }
	    }
	};


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * URL Loader module.
	 * @module UrlLoader
	 */



	var _logger = __webpack_require__(2);

	function ajaxLoad(url, callback, timeout, options) {

	    var httpRequest;
	    var startTime = 0;
	    var duration = 0;
	    var calcDuration = false;
	    var logger = __webpack_require__(34);
	    var cacheManager = __webpack_require__(35);

	    var useWithCredentials = true;

		var debug = function(message) {
		    logger.logDebug(message, 'URL Loader');
		};

	    if (options &&  typeof options.withCredentials !== 'undefined') {
	        useWithCredentials = options.withCredentials;
	    }

	    if (window.XMLHttpRequest) { // Mozilla, Safari, ...
	        httpRequest = new XMLHttpRequest();
	    } else if (window.ActiveXObject) { // IE
	        try {
	            httpRequest = new ActiveXObject('Msxml2.XMLHTTP');
	        } catch (msxmlErr) {
	            try {
	                httpRequest = new ActiveXObject('Microsoft.XMLHTTP');
	            } catch (msErr) {}
	        }
	    }


	    if (!httpRequest) {
	        if (callback) {
	            callback.call(this, '406', ''); // request is not acceptable
	        }
	        return;
	    }

	    httpRequest.onreadystatechange = function() {
	        if (httpRequest.readyState === 4) {

	            if (httpRequest.status === 200) {
	                if (callback) {
	                    callback.call(this, undefined, httpRequest.responseText, httpRequest);
	                }
	                debug('duration: ' + duration + ', response length: ' + httpRequest.responseText.length);
	                if (calcDuration && httpRequest.responseText && httpRequest.responseText.length > 2048) {
				var nBandWidth = (httpRequest.responseText.length * 8.0 * 1000.0) / (Math.max(1.0, duration) * 1024.0);
				var intBandwidth = parseInt(nBandWidth.toString());
	                    debug('Bandwidth: ' + intBandwidth);
				try {
					cacheManager.setGenericData('anxBandwidth', intBandwidth);
					//localStorage.setItem('anxBandwidth', intBandwidth);
				}
				catch(ex) {
				}
	                }
	            } else {
	                if (httpRequest.status >= 400 && httpRequest.status < 600) {
	                    if (callback) {
	                        callback.call(this, httpRequest.status, '', httpRequest);
	                    }
	                }
	            }

	        }
	        else if (httpRequest.readyState === 2) {
			startTime = (new Date()).getTime();
	        }
	        else if (httpRequest.readyState === 3) {
			if (startTime > 0) {
				calcDuration = true;
				duration = (new Date()).getTime() - startTime;
			}
	        }
	    };

	    httpRequest.onerror = function() {
	        //if there is an error, it might be becase we are using withCredentials
	        //let's try one more time without that flag set.
	        //this won't send cookies, but it's better than no ad at all
	        if(useWithCredentials) {
	            var newOpts = options ? options : {};
	            newOpts.withCredentials = false;
	            ajaxLoad(url, callback, timeout, newOpts);
	        } else {
	            if (callback) {
	                var errorStatus = httpRequest.status === 0 ? '404' : httpRequest.status.toString();
	                callback.call(this, errorStatus, '', httpRequest);
	            }
	        }
	    };


	    httpRequest.ontimeout = function() {
	        //_logger.log('Server Timeout');
	        if (callback) {
	            callback.call(this, 'Timeout', '', httpRequest);
	        }
	    };

	    httpRequest.open('GET', url);
	    if (timeout) {
	        httpRequest.timeout = timeout;
	    }
	    httpRequest.withCredentials = useWithCredentials;
	    startTime = 0;
	    httpRequest.send();
	}

	function createTrackingPixel(url, eventName) {
	    _logger.log('Logging Event: ' + eventName + ' at url:' + url);
	    new Image(1, 1).src = url;

	}



	module.exports = {
	    /** Load a URL.
	     * @param {string} url - Target URL to load.
	     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
	     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
	     */
	    load: function(url, callback, timeout) {
	        ajaxLoad(url, callback, timeout, {withCredentials:true});
	    },


	    /** Track Pixel.
	     * @param {String} url - Url of traking pixel to track.
	     * @param {String} eventName - Name of event being tracked.
	     */
	    trackPixel: function(url, eventName) {
	        createTrackingPixel(url, eventName);
	    }
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * General Utilities module.
	 * @module GeneralUtilities
	 */

	var _logger = __webpack_require__(2);


	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var MAX_OBJ_TO_STRING_RECURSION = 9;




	//////////////////////////////////////////////////////////////////////
	// VARIABLES


	//////////////////////////////////////////////////////////////////////
	// FUNCTIONS
	function getXmlResponseFromXhrObject(responseObj) {
	    if (responseObj) {
	        //if the response has parsed XML, trace it as an XML object
	        //otherwise, trace it as a string
	        if (responseObj.responseXML) {
	            return responseObj.responseXML;
	        } else {
	            return responseObj.responseText;
	        }
	    }
	}

	//////////////////////////////////////////////////////////////////////
	// EXPORTS
	module.exports = {
	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *      - example 2:  debug("hello", "TM") ==> <timestamp> TM>hello
	     */
	    debug: function() {
	        _logger.handleLogDebugLegacySupport.apply(this, arguments);

	    },

	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Writes an entry to the console log if the current debug level is set to "Error", "Warn" or Debug"
	     * @param (string) message = text to be written to the log
	     * @param (string) source = optional string which identifies the source of the debug statement
	     *      - if present, then it will be prepended to front of the string
	     *      - example 1:  debug("hello") ==> <timestamp> hello
	     *
	     */
	    logDebug: function() {
	        _logger.handleLogDebugLegacySupport.apply(this, arguments);

	    },

	    /**
	     * @deprecated - use @appnexus/videoads-util-logging
	     * Sets debug level for logger
	     * @param (string) level = Debug level to use
	     */
	    setDebugLevel: function(level) {
	        _logger.setDebugLevel(level);
	    },

	    /**
	     * Checks to see if a string or an array is not empty:
	     *  @param (object) arg = string or array which is being evaluated
	     *  @returns (boolean)
	     *      - true = arg is defined and the length > 0
	     *      - false = arg is null, undefined or has a length of zero
	     */
	    isNotEmpty: function(arg) {
	        var answer = false;
	        if (arg !== null && arg) {
	            answer = (arg.length > 0);
	        }

	        return answer;
	    },

	    /**
	     * @deprecated - since we now have the abilility to directly pass objects to our debug statements, we no longer need this
	     * returns a string version of an object
	     * if the value of a field is itself an object, then will stringify that object as well
	     */
	    objectToString: function(obj, recursionCount) {
	        /*
	                try{
	                    return JSON.stringify(obj);
	                }catch(ex){
	                    return "null"
	                }
	             */
	        var answer = "null";

	        //set default recurisonCount if it's not specified
	        recursionCount = typeof recursionCount !== 'undefined' ? recursionCount : 0;

	        if (obj !== null) {
	            answer = "OBJ[";
	            var props = "";
	            for (var key in obj) {
	                var val = obj[key];
	                if (typeof val === 'object') {
	                    recursionCount++;
	                    if (recursionCount < MAX_OBJ_TO_STRING_RECURSION) {
	                        try {
	                            val = this.objectToString(val);
	                        } catch (ex) {
	                            val = "err:" + ex;
	                        }
	                    } else {
	                        val = "err: max recursion hit";
	                    }
	                }
	                if (props.length > 0) {
	                    props += ",";
	                }
	                props += (key + "=" + val);
	            }
	            answer += props;
	            answer += "]";
	        }


	        return answer;

	    },

	    /**
	     *  Generates a alphanueric random string, up to 16 characters long containing the set [0-9,a-z].
	     *  Note: It is not guaranteed that this will start with a letter.
	     *  Note: These are not UUIDs/GUIDs, do not use as such in critcial situaitons.
	     *  Note: This is not guaranteed to be crypogtaphically secure.
	     *  @param (object) arg = string or array which is being evaluated
	     *  @returns (String)
	     *      - random character string
	     */
	    getRandomString: function() {
	        return Math.random().toString(36).substring(2);
	    },

	    /**
	     *  Trace a XML response in a XHR object at the "info" trace level (if enabled)
	     *  @param (Object) responseObjects = Single XHR Response object, or Array of XHR Response Objects to trace.
	     *  @param (String) tracePrefix = Text to print as part of trace statement.
	     *
	     */
	    traceVastFromXhr: function(responseObjects, tracePrefix) {
	        try {
	            if (responseObjects) {
	                //if we are passed an array, treat each item in array as a XHR Response
	                if (Array.isArray(responseObjects)) {
	                    if (responseObjects.length > 0) {
	                        // var responsesToTrace = [];
	                        var xmlUrlLoadingChain = [];

	                        //parse URL and payload out of each object
	                        for (var curResponseArrayPos in responseObjects) {
	                            // var curResponsePayload = {};
	                            // curResponsePayload.url = responseObjects[curResponseArrayPos].responseURL;
	                            // curResponsePayload.payloadObj = getXmlResponseFromXhrObject(responseObjects[curResponseArrayPos]);
	                            // responsesToTrace.push(curResponsePayload);

	                            xmlUrlLoadingChain.push(responseObjects[curResponseArrayPos].responseURL);
	                        }

	                        var finalXhrObject = responseObjects[responseObjects.length - 1];
	                        if (finalXhrObject) {
	                            var finalXmlTag = getXmlResponseFromXhrObject(finalXhrObject);
	                            var finalXmlTagUrl = finalXhrObject.responseURL;

	                            _logger.info(tracePrefix, "Tag load chain:", xmlUrlLoadingChain, "\n",
	                                "Final Tag URL: ", finalXmlTagUrl, "\n", "Final Tag: ", finalXmlTag);
	                        }
	                    }
	                } else {
	                    //if we didn't get an array, treat responseObjects as a single XHR responsw
	                    var responsePayloadToTrace = getXmlResponseFromXhrObject(responseObjects);
	                    _logger.info(tracePrefix, "Tag URL:", responseObjects.responseURL, "\n", "Tag:", responsePayloadToTrace);

	                }
	            }
	        }catch (e) {}
	    }



	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Cache Manager module.
	 * @module CacheManager
	 */

	var utils = __webpack_require__(34);


	var prefix = "Cache Manager";

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
	var MSEC_PER_MINUTE = 60 * 1000;
	var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var _ttlMsec = TTL_DEFAULT_MSEC;

	var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
	var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

	var backupInMemoryStorageObj = {};

	//storage types:
	//0 - localStorage
	//1 - cookie
	//2 - in memory
	var storageTypeToUse;

	if (isLocalStorageSupported()) {
	    storageTypeToUse = 0;
	} else {
	    if (isCookieStorageSupported()) {
	        storageTypeToUse = 1;
	    } else {
	        storageTypeToUse = 2;
	    }

	}

	utils.debug("Using Cache Method " + storageTypeToUse, prefix);

	//docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	var docCookies = {
	    getItem: function(sKey) {
	        if (!sKey) {
	            return null;
	        }
	        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	    },
	    setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	            return false;
	        }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    },
	    removeItem: function(sKey, sPath, sDomain) {
	        if (!this.hasItem(sKey)) {
	            return false;
	        }
	        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	        return true;
	    },
	    hasItem: function(sKey) {
	        if (!sKey) {
	            return false;
	        }
	        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
	    },
	    keys: function() {
	        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	        }
	        return aKeys;
	    }
	};

	//write object to whatever storage method we are using, with specified key
	function writeToStorage(key, obj, dontExpire) {
	    switch (storageTypeToUse) {
	        case 0:
	            writeToLocalStorage(key, obj);
	            break;
	        case 1:
	            writeToCookieStorage(key, obj, dontExpire);
	            break;
	        default:
	        case 2:
	            writeToInMemoryStorage(key, obj);
	            break;
	    }
	}

	//get a object from the storage method we are using, that has the specified key
	function getFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            return getFromLocalStorage(key);
	        case 1:
	            return getFromCookieStorage(key);
	        default:
	        case 2:
	            return getFromInMemoryStorage(key);
	    }

	}

	//delete an object in the storaege method we are using,
	function deleteFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            deleteFromLocalStorage(key);
	            break;
	        case 1:
	            deleteFromCookieStorage(key);
	            break;
	        default:
	        case 2:
	            deleteFromInMemoryStorage(key);
	            break;
	    }
	}

	function writeToLocalStorage(key, obj) {
	    if (localStorage) {
	        localStorage.setItem(key, obj);
	    }
	}

	function getFromLocalStorage(key) {
	    if (localStorage) {
	        return localStorage.getItem(key);
	    }
	}

	function deleteFromLocalStorage(key) {
	    if (localStorage) {
	        localStorage.removeItem(key);
	    }
	}

	function writeToCookieStorage(key, obj, dontExpire) {
	    docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
	}

	function getFromCookieStorage(key) {
	    return docCookies.getItem(key);
	}

	function deleteFromCookieStorage(key) {
	    docCookies.removeItem(key);
	}

	function writeToInMemoryStorage(key, obj) {
	    if (backupInMemoryStorageObj) {
	        backupInMemoryStorageObj[key] = obj;
	    }
	}

	function getFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        return backupInMemoryStorageObj[key];
	    }
	}

	function deleteFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        delete backupInMemoryStorageObj[key];
	    }
	}

	//return true if localStorage is supported, false otherwise
	function isLocalStorageSupported() {

	    //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
	    try {
	        if (localStorage) {
	            var testValue = "apntestls" + Math.random();
	            try {
	                //try writing and reading something
	                localStorage.setItem(testValue, testValue);
	                localStorage.removeItem(testValue);
	                return true;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}


	//return true if localStorage is supported, false otherwise
	function isCookieStorageSupported() {
	    try {
	        if (document && document.cookie) {
	            var testValue = "apntestcookie" + Math.random();
	            try {
	                docCookies.setItem(testValue, testValue, Infinity);
	                var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
	                docCookies.removeItem(testValue);
	                return cookieWorked;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}

	// caches the adObject - this will overwrite any existing cached ad
	// the cache will also be timestamp with the current time in milliseconds
	// for calculating time to live
	function addAdToCache(adObject, adId) {
	    var cacheObject = {};
	    cacheObject.timestamp = new Date().getTime();
	    cacheObject.ad = adObject;

	    try {
	        writeToStorage(adId, JSON.stringify(cacheObject));
	    } catch (e) {

	    }
	}

	// returns the ad stored in the cache if the cache has not expired
	// returns null if the cache has expired (based on the configured time-to-live)
	// OR if there is no ad in the cache
	// NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function getCachedAd(adId) {
	    var ts = new Date().getTime();

	    var retrievedCacheItem;

	    try {
	        var itemFromCache = getFromStorage(adId);
	        retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
	        // clear the cache, setting it back to default (or empty)
	        deleteFromStorage(adId);
	    } catch (e) {

	    }

	    // check to see if the ad cache exists and if the cache has not expired
	    if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
	        var cacheAge = ts - retrievedCacheItem.timestamp;
	        //if we have expired, return nothing
	        if (cacheAge <= _ttlMsec) {
	            return retrievedCacheItem.ad;
	        }
	    }

	    return null;
	}

	// clear the ad cache by creating a default ad cache object
	//NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function clearAdCache(adId) {
	    try {
	        deleteFromStorage(adId);
	    } catch (e) {

	    }
	}

	// converts the time-to-live argument from minutes to milliseconds
	// to make it easier to compare timestamps
	function setTTL(ttlMinutes) {
	    _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
	}

	// gets the current token from the cache
	function getAdToken() {
	    var tokenToReturn;
	    var tokenFromCache;
	    tokenFromCache = getFromStorage(adTokenStorageKey);

	    if (tokenFromCache) {
	        tokenToReturn = parseInt(tokenFromCache);
	    } else {
	        //no token found, use default
	        tokenToReturn = 0;
	    }

	    //store new token in localStorage or local memory
	    writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


	    return tokenToReturn;
	}

	function prependAppnexusIdToKey(incomingKey) {
	    return "apn_" + incomingKey;
	}

	module.exports = {

	    /**
	     * Set generic data in cache
	     * @param (string) key = key under which to store data
	     * @param (object) value = value to store.
	     * @return (boolean) true if value was succesfully stored, false otherwise
	     */
	    setGenericData: function(key, value) {
	        if (typeof key !== "undefined" && typeof value !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            try {
	                writeToStorage(key, value);
	                return true;
	            } catch (e) {

	            }
	        }
	        return false;
	    },

	    /**
	     * Get generic data from cache
	     * @param (string) key = key to retrive from data
	     * @return (object) object contaninig data from cache with given key, undefined if key not found.
	     */
	    getGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            return getFromStorage(key);
	        }
	    },

	    /**
	     * Delete generic data from cache
	     * @param (string) key = key to delete from cache
	     */
	    deleteGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            deleteFromStorage(key);
	        }
	    },

	    /**
	     * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
	     * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
	     */
	    forceStorageMethod: function(storageType) {
	        storageTypeToUse = storageType;
	        utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
	    },

	    /**
	     * add the ad data to the cache
	     * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
	     *      - this will become the input into the ad rendering logic
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    addAd: function(adObject, adId) {
	        if (adObject) {
	            addAdToCache(adObject, prependAppnexusIdToKey(adId));
	        }
	    },

	    /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
	     * @param (integer) adId = unique identifier for a specific ad cache
	     * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
	     */
	    getAd: function(adId) {
	        return getCachedAd(prependAppnexusIdToKey(adId));
	    },

	    /**
	     * Clears the cache, removing any cached ad
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    clearAd: function(adId) {
	        clearAdCache(prependAppnexusIdToKey(adId));
	    },

	    /** Sets the time-to-live settings for the ad cache
	     * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
	     */
	    setTimeToLive: function(timeToLiveMinutes) {
	        setTTL(timeToLiveMinutes);
	    },

	    /**
	     * Returns a token unique to this page which is used to identify an ad request.
	     */
	    getNextAdToken: function() {
	        // Remove unnecessary additional characters.
	        // return chars.substring(0, len);
	        return getAdToken();
	    }
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Rendition Manager module.
	 * @module RenditionManager
	 */

	//var _mimeTypes = ['video/x-flv', 'video/mp4', 'video/x-m4v', 'video/x-f4v', 'video/m4v', 'video/f4v', 'video/webm',
	//                  'application/x-shockwave-flash', 'application/javascript', 'application/x-javascript'];
	var _mimeTypes = ['video/x-flv', 'video/x-f4v', 'video/f4v', 'video/mp4', 'video/webm', 'video/ogg',
	                  'application/x-shockwave-flash', 'application/javascript', 'application/x-javascript'];
	var _arrRenditions = [];
	var _priority = 0;	// 0-no priority, 1-html5 only, 2-html5 first, 3-flash only, 4-flash first
	var _cacheManager = __webpack_require__(37);

	var _logger = __webpack_require__(2);
	var _prefix = 'Rendition Manager > ';

	function normalizeRenditions(arrRenditions) {
	    var arr = [];
	    for (var i = 0; i < arrRenditions.length; i++) {
	        var rend = arrRenditions[i];
	        if (!rend.hasOwnProperty('type')) {
			// type is required for rendition
			continue;
	        }

	        if (!rend.hasOwnProperty('width')) {
	            rend.width = 0;
	        }
	        if (!rend.hasOwnProperty('height')) {
	            rend.height = 0;
	        }
	        if (!rend.hasOwnProperty('bitrate')) {
	            rend.bitrate = 0x7FFFFFFF;
	        }
	        arr.push(rend);
	    }
	    return arr;
	}

	function isFlashOnlyType(type) {
		return type === 'video/x-flv' || type === 'video/x-f4v' || type === 'video/f4v' ||
			type === 'application/x-shockwave-flash';
	}

	function isHtml5OnlyType(type) {
		return type === 'video/webm' || type === 'video/ogg' || type === 'application/javascript' ||
			type === 'application/x-javascript';
	}

	function isCompatibleType(type) {
	    if (_priority === 1 && isFlashOnlyType(type)) {
		return false;
	    }
	    if (_priority === 3 && isHtml5OnlyType(type)) {
		return false;
	    }
	    for (var i = 0; i < _mimeTypes.length; i++) {
	        if (type === _mimeTypes[i]) {
	            return true;
	        }
	    }
	    return false;
	}

	function removeNotCompatibleVideoTypes() {
	    for (var i = 0; i < _arrRenditions.length; ) {
	        if (isCompatibleType(_arrRenditions[i].type.toLowerCase())) {
			i++;
	        }
	        else {
			_arrRenditions.splice(i, 1);
	        }
	    }
	}

	function getCloserSizes(width, height) {
	    var arrRend = [];
	    var desr = -1;
	    for (var i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].width >= width && (desr === -1 || desr >= (_arrRenditions[i].width - width))) {
	            if (desr > (_arrRenditions[i].width - width)) {
	                arrRend.length = 0;
	            }
	            arrRend.push(_arrRenditions[i]);
	            desr = _arrRenditions[i].width - width;
	        }
	    }

	    if (arrRend.length > 0) {
	        _arrRenditions.length = 0;
	        _arrRenditions = arrRend.slice();
	    } else {
	        for (i = 0; i < _arrRenditions.length; i++) {
	            if (_arrRenditions[i].width < width && (desr === -1 || desr >= (width - _arrRenditions[i].width))) {
	                if (desr > (width - _arrRenditions[i].width)) {
	                    arrRend.length = 0;
	                }
	                arrRend.push(_arrRenditions[i]);
	                desr = width - _arrRenditions[i].width;
	            }
	        }
	        if (arrRend.length > 0) {
	            _arrRenditions.length = 0;
	            _arrRenditions = arrRend.slice();
	        }
	    }
	    if (_arrRenditions.length === 1) {
	        return;
	    }

	    arrRend.length = 0;
	    desr = -1;
	    // height
	    for (i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].height >= height && (desr === -1 || desr >= (_arrRenditions[i].height - height))) {
	            if (desr > (_arrRenditions[i].height - height)) {
	                arrRend.length = 0;
	            }
	            arrRend.push(_arrRenditions[i]);
	            desr = _arrRenditions[i].height - height;
	        }
	    }

	    if (arrRend.length > 0) {
	        _arrRenditions.length = 0;
	        _arrRenditions = arrRend.slice();
	    } else {
	        for (i = 0; i < _arrRenditions.length; i++) {
	            if (_arrRenditions[i].height < height && (desr === -1 || desr >= (height - _arrRenditions[i].height))) {
	                if (desr > (height - _arrRenditions[i].height)) {
	                    arrRend.length = 0;
	                }
	                arrRend.push(_arrRenditions[i]);
	                desr = height - _arrRenditions[i].height;
	            }
	        }
	        if (arrRend.length > 0) {
	            _arrRenditions.length = 0;
	            _arrRenditions = arrRend.slice();
	        }
	    }
	}

	function matchPriority(type) {
		if (_priority === 0) {
			return true;
		}
		if (_priority === 1 && isFlashOnlyType(type)) {
			return false;
		}
		if (_priority === 3 && isHtml5OnlyType(type)) {
			return false;
		}
		return true;
	}

	function getCloserBitrates(bitrate) {
	    var arrRend = [];
	    var desr = -1;
	    // get the lower closer bitrate rendition
	    for (var i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].bitrate <= bitrate && (desr === -1 || desr >= (bitrate - _arrRenditions[i].bitrate))) {
	            if (desr > (bitrate - _arrRenditions[i].bitrate)) {
	                arrRend.length = 0;
	            }
	            desr = bitrate - _arrRenditions[i].bitrate;
	            arrRend.push(_arrRenditions[i]);
	        }
	    }
	    if (arrRend.length > 0) {
	        _arrRenditions.length = 0;
	        _arrRenditions = arrRend.slice();
	    } else {
	        // get the higher closer bitrate rendition
	        for (i = 0; i < _arrRenditions.length; i++) {
	            if (_arrRenditions[i].bitrate >= bitrate && (desr === -1 || desr >= (_arrRenditions[i].bitrate - bitrate))) {
	                if (desr > (_arrRenditions[i].bitrate - bitrate)) {
	                    arrRend.length = 0;
	                }
	                desr = _arrRenditions[i].bitrate - bitrate;
	                arrRend.push(_arrRenditions[i]);
	            }
	        }
	    }
	    if (arrRend.length === 1 || _priority === 0) {
		return arrRend[0];
	    }
	    else {
		if (_priority === 1 || _priority === 3) {
	            for (i = 0; i < arrRend.length; i++) {
			if (matchPriority(arrRend[i].type.toLowerCase())) {
				return arrRend[i];
			}
	            }
	            return null;
		}
		else {
	            for (i = 0; i < arrRend.length; i++) {
			if (_priority === 2 && !isFlashOnlyType(arrRend[i].type.toLowerCase())) {
				return arrRend[i];
			}
			if (_priority === 4 && isFlashOnlyType(arrRend[i].type.toLowerCase())) {
				return arrRend[i];
			}
	            }
			return arrRend[0];
		}
	     }
	}

	function getVpaidRendition(width, height, bitrate) {
		var rend = null;
		var arrNotVpaidRend = [];
	    for (var i = 0; i < _arrRenditions.length;) {
		if (!_arrRenditions[i].apiFramework || _arrRenditions[i].apiFramework.toLowerCase().indexOf('vpaid') < 0) {
			// not vpaid
			arrNotVpaidRend.push(_arrRenditions[i]);
			_arrRenditions.splice(i, 1);
		}
		else {
			i++;
		}
	    }
	    if (_arrRenditions.length > 0) {
	        if (_arrRenditions.length === 1) {
	            return _arrRenditions[0];
	        }

	        // sizes
	        getCloserSizes(width, height);
	        if (_arrRenditions.length === 1) {
			rend = _arrRenditions[0];
	        }
	        else {
		         // bitrates
		        rend = getCloserBitrates(bitrate);
		   }
	    }
	    if (rend === null) {
		// restore not vpaid renditions
		_arrRenditions = arrNotVpaidRend.slice();
	    }
	    return rend;
	}

	function setPriority(options) {
		_priority = 2;	// default priority to html5,flash order
		if (options && options.playerTechnology && Array.isArray(options.playerTechnology) && options.playerTechnology.length > 0) {
			if (options.playerTechnology.length === 1) {
				if (options.playerTechnology[0] === 'html5') {
					_priority = 1;
				}
				else {
					_priority = 3;
				}
			}
			else {
				if (options.playerTechnology[0] === 'flash') {
					_priority = 4;
				}
			}
		}
	}

	function setNotVpaidPriority(options) {
		_priority = 2;	// default priority to html5,flash order
		if (options && options.playerTechnology && Array.isArray(options.playerTechnology) && options.playerTechnology.length > 0) {
			if (options.playerTechnology.length === 1) {
				if (options.playerTechnology[0] === 'html5') {
					_priority = 1;
				}
				else {
					_priority = 3;
				}
			}
		}
	}

	function addPlayerPriority(rend) {
		if (!rend) {
		    _logger.error(_prefix, 'Failed to select rendition');
			return {success: false, errorCode: 403};
		}

		if (_priority === 1) {
			rend['requiredPlayer'] = 1;
		}
		else if (_priority === 3) {
			rend['requiredPlayer'] = 2;
		}
		else {
			if (isFlashOnlyType(rend.type.toLowerCase())) {
				rend['requiredPlayer'] = 2;
			}
			else if (isHtml5OnlyType(rend.type.toLowerCase())) {
				rend['requiredPlayer'] = 1;
			}
			else {
				rend['requiredPlayer'] = 0;
			}
		}
		rend['success'] = true;
		_logger.info(_prefix, 'Selected rendition: ', rend);
		return rend;
	}

	function getBitrate(bitrate) {
		if (bitrate && bitrate > 0) {
			_logger.info(_prefix, 'Selected bitrate (not from cache): ' + bitrate);
			return bitrate;
		}
		var newBitrate = 1;		// take a lowest bitrate
		try {
			var temp = _cacheManager.getGenericData('anxBandwidth');
			//var temp = localStorage.getItem("anxBandwidth");
			if (temp) {
				newBitrate = temp;
				_logger.info(_prefix, 'Selected bitrate (from cache): ' + newBitrate);
			}
			else {
				_logger.info(_prefix, 'No bitrate data present in cache (use bitrate 1)');
			}
		}
		catch (ex) {
			_logger.warn(_prefix, 'Exception during getting bitrate from cache (use bitrate 1)');
		}
		return newBitrate;
	}

	//this will switch an order of playerTechnology if it has both flash and html5 and if the first is flash.
	function makeHtml5Preferable(_options) {
	    if (_options && _options.playerTechnology && Array.isArray(_options.playerTechnology) &&
		_options.playerTechnology.length === 2 && _options.playerTechnology[0] === 'flash' && _options.playerTechnology[1] === 'html5') {
	        _options.playerTechnology = ['html5','flash'];
	    }
	    return _options;
	}

	function isMobile() {
	    return navigator.appVersion.indexOf('Mobile') > -1 || navigator.appVersion.indexOf('Android') > -1;
	}

	function getRenditionForTechnology(width, height, newBitrate, options) {

	    // first try to select vpaid
	    var rend = getVpaidRendition(width, height, newBitrate);
	    if (rend) {
		if (matchPriority(rend.type.toLowerCase())) {
			_logger.info(_prefix, 'VPAID selected');
			return rend;
		}
	    }

	    setNotVpaidPriority(options);

	    if (_arrRenditions.length === 0) {
	        return null;
	    }
	    if (_arrRenditions.length === 1) {
		if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
			return _arrRenditions[0];
		}
		else {
			return null;
		}
	    }

	    // sizes
	    getCloserSizes(width, height);
	    if (_arrRenditions.length === 1) {
		_logger.log(_prefix, 'Rendition selected by size');
		if (matchPriority(_arrRenditions[0].type.toLowerCase())) {
			return _arrRenditions[0];
		}
		else {
			return null;
		}
	    }

	    // bitrates
	    _logger.log(_prefix, 'Try select rendition by bitrate');
	    return getCloserBitrates(newBitrate);
	}

	function getUrl(width, height, bitrate, options) {

		options = makeHtml5Preferable(options);

		// set priority
		setPriority(options);

	    // types
	    removeNotCompatibleVideoTypes();

	    var newBitrate = getBitrate(bitrate);

	    var allRenditions = _arrRenditions.slice();

	    // get HTML5 renditions
	    _arrRenditions.length = 0;
	    for (var i = 0; i < allRenditions.length; i++) {
		if (!isFlashOnlyType(allRenditions[i].type.toLowerCase())) {
			_arrRenditions.push(allRenditions[i]);
		}
	    }
	    _logger.log(_prefix, 'HTML5 rendition count = ' + _arrRenditions.length);
	    var rend;
	    if (_arrRenditions.length > 0) {
		rend = getRenditionForTechnology(width, height, newBitrate, options);
		if (rend) {
			return addPlayerPriority(rend);
		}
	    }

	    if (isMobile()) {
		addPlayerPriority(null);
	    }

	    // get Flash renditions
	    _arrRenditions.length = 0;
	    for (i = 0; i < allRenditions.length; i++) {
		if (isFlashOnlyType(allRenditions[i].type.toLowerCase())) {
			_arrRenditions.push(allRenditions[i]);
		}
	    }
	    _logger.log(_prefix, 'Flash rendition count = ' + _arrRenditions.length);
	    if (_arrRenditions.length > 0) {
		rend = getRenditionForTechnology(width, height, newBitrate, options);
		if (rend) {
			return addPlayerPriority(rend);
		}
	    }
	    return addPlayerPriority(null);
	}

	function getExactSizes(width, height) {
	    var arrRend = [];
	    for (var i = 0; i < _arrRenditions.length; i++) {
	        if (_arrRenditions[i].width === width && _arrRenditions[i].height === height) {
	            arrRend.push(_arrRenditions[i]);
	        }
	    }

	    _arrRenditions.length = 0;
	    if (arrRend.length > 0) {
	        _arrRenditions = arrRend.slice();
	    }
	}

	function removeSelectedCompanionFromArray(arrCompanions, id) {
		for (var i = 0; i < arrCompanions.length; i++) {
			if (arrCompanions[i].id === id) {
				arrCompanions.splice(i, 1);
				break;
			}
		}
	}

	function selectCompanions(companionAds, containers) {
		// validation
		if (!companionAds || companionAds.companions.length === 0 ||
			!containers || containers.length === 0) {
			return;
		}

		// generate rendition array from companionAds
		_arrRenditions = [];
		for (var i = 0; i < companionAds.companions.length; i++) {
			var companion = companionAds.companions[i];
			var rendition;
			try {
				rendition = Object.assign({}, companion);
			}
			catch(ex) {
				try {
					var str = JSON.stringify(companion);
					rendition = JSON.parse(str);
				}
				catch(ex) {
					continue;
				}
			}
	        rendition.id = i;
	        rendition.type = 'unknown';
	        if (companion.hasOwnProperty('StaticResource')) {
			rendition.type = companion.StaticResource.type;
	        }

	        _arrRenditions.push(rendition);
		}

		if (_arrRenditions.length === 0) {
			return;
		}

		var saveRenditions = _arrRenditions.slice();
		for (i = 0; i < containers.length && saveRenditions.length > 0; i++) {
			var container = containers[i];

			_arrRenditions.length = 0;
			_arrRenditions = saveRenditions.slice();

		    // sizes
		    getExactSizes(container.width, container.height);
		    if (_arrRenditions.length === 1) {
			_logger.log(_prefix, 'Companion rendition selected by size');
			    container.companion = _arrRenditions[0];
			    // make sure we will not select same companions from different containers
			    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
			    continue;
		    }
		    if (_arrRenditions.length === 0) {
			_logger.log(_prefix, 'Companion rendition not selected for container');
			container.companion = null;
			continue;
		    }

		    // check for vpaid
		    var bFound = false;
		    for (var j = 0; j < _arrRenditions.length; j++) {
			if (_arrRenditions[j].apiFramework && _arrRenditions[j].apiFramework.toLowerCase().indexOf('vpaid') < 0) {
				_logger.log(_prefix, 'Companion rendition selected by apiFramework');
				    container.companion = _arrRenditions[j];
				    // make sure we will not select same companions from different containers
				    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
				    bFound = true;
				break;
			}
		    }

		    if (!bFound) {
			// select the first one
			_logger.log(_prefix, 'First companion rendition selected');
			    container.companion = _arrRenditions[0];
			    // make sure we will not select same companions from different containers
			    removeSelectedCompanionFromArray(saveRenditions, container.companion.id);
		    }
		}
	}


	module.exports = {
		    /** Describe Rendition manager Initialization.
		     * @param {array} arrRenditions - array of available renditions.
		     */
			init: function(arrRenditions) {
				_arrRenditions = normalizeRenditions(arrRenditions);
			},

		    /** Describe Rendition manager Main Entry Point Here.
		     * @param {number} width - video player width in pixels.
		     * @param {number} height - video player height in pixels.
		     * @param {number} bitrate - bitrate in Kbps.
		     * @param {object} options - options from impbus request.
		     * @return {object} return rendition object with all vast information for media file.
		     * 		Additionally the property requiredPlayer, success, and errorCode added to the output object.
		     * 		requiredPlayer value: 0 - any, 1 - html5, 2 - flash
		     * 		success value: true is success, false otherwise (if false errorCode is added)
		     * 		errorCode value: VAST error code
		     */
			getUrl: function(width, height, bitrate, options) {
				return getUrl(width, height, bitrate, options);
		    },

		    /** Describe Rendition manager companions selection.
		     * @param {object} companionAds - video player width in pixels.
		     * 		required - 'required' property from CompanionAds node if present
		     * 		companions - array of objects represents Companion nodes
		     * @param {array} containers - array of objects represents containers for companions on page.
		     * 		each of container object has to have the following properties:
		     * 		id - internal identificator
		     * 		width - widthy of container
		     * 		height - height of container
		     * 		companion - pointer to companion object in companionAds.companions (generated by current call)
		     */
			selectCompanionsForContainers: function(companionAds, containers) {
				selectCompanions(companionAds, containers);
		    }
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Cache Manager module.
	 * @module CacheManager
	 */

	var utils = __webpack_require__(34);


	var prefix = "Cache Manager";

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
	var MSEC_PER_MINUTE = 60 * 1000;
	var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var _ttlMsec = TTL_DEFAULT_MSEC;

	var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
	var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

	var backupInMemoryStorageObj = {};

	//storage types:
	//0 - localStorage
	//1 - cookie
	//2 - in memory
	var storageTypeToUse;

	if (isLocalStorageSupported()) {
	    storageTypeToUse = 0;
	} else {
	    if (isCookieStorageSupported()) {
	        storageTypeToUse = 1;
	    } else {
	        storageTypeToUse = 2;
	    }

	}

	utils.debug("Using Cache Method " + storageTypeToUse, prefix);

	//docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	var docCookies = {
	    getItem: function(sKey) {
	        if (!sKey) {
	            return null;
	        }
	        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	    },
	    setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	            return false;
	        }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    },
	    removeItem: function(sKey, sPath, sDomain) {
	        if (!this.hasItem(sKey)) {
	            return false;
	        }
	        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	        return true;
	    },
	    hasItem: function(sKey) {
	        if (!sKey) {
	            return false;
	        }
	        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
	    },
	    keys: function() {
	        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	        }
	        return aKeys;
	    }
	};

	//write object to whatever storage method we are using, with specified key
	function writeToStorage(key, obj, dontExpire) {
	    switch (storageTypeToUse) {
	        case 0:
	            writeToLocalStorage(key, obj);
	            break;
	        case 1:
	            writeToCookieStorage(key, obj, dontExpire);
	            break;
	        default:
	        case 2:
	            writeToInMemoryStorage(key, obj);
	            break;
	    }
	}

	//get a object from the storage method we are using, that has the specified key
	function getFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            return getFromLocalStorage(key);
	        case 1:
	            return getFromCookieStorage(key);
	        default:
	        case 2:
	            return getFromInMemoryStorage(key);
	    }

	}

	//delete an object in the storaege method we are using,
	function deleteFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            deleteFromLocalStorage(key);
	            break;
	        case 1:
	            deleteFromCookieStorage(key);
	            break;
	        default:
	        case 2:
	            deleteFromInMemoryStorage(key);
	            break;
	    }
	}

	function writeToLocalStorage(key, obj) {
	    if (localStorage) {
	        localStorage.setItem(key, obj);
	    }
	}

	function getFromLocalStorage(key) {
	    if (localStorage) {
	        return localStorage.getItem(key);
	    }
	}

	function deleteFromLocalStorage(key) {
	    if (localStorage) {
	        localStorage.removeItem(key);
	    }
	}

	function writeToCookieStorage(key, obj, dontExpire) {
	    docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
	}

	function getFromCookieStorage(key) {
	    return docCookies.getItem(key);
	}

	function deleteFromCookieStorage(key) {
	    docCookies.removeItem(key);
	}

	function writeToInMemoryStorage(key, obj) {
	    if (backupInMemoryStorageObj) {
	        backupInMemoryStorageObj[key] = obj;
	    }
	}

	function getFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        return backupInMemoryStorageObj[key];
	    }
	}

	function deleteFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        delete backupInMemoryStorageObj[key];
	    }
	}

	//return true if localStorage is supported, false otherwise
	function isLocalStorageSupported() {

	    //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
	    try {
	        if (localStorage) {
	            var testValue = "apntestls" + Math.random();
	            try {
	                //try writing and reading something
	                localStorage.setItem(testValue, testValue);
	                localStorage.removeItem(testValue);
	                return true;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}


	//return true if localStorage is supported, false otherwise
	function isCookieStorageSupported() {
	    try {
	        if (document && document.cookie) {
	            var testValue = "apntestcookie" + Math.random();
	            try {
	                docCookies.setItem(testValue, testValue, Infinity);
	                var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
	                docCookies.removeItem(testValue);
	                return cookieWorked;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}

	// caches the adObject - this will overwrite any existing cached ad
	// the cache will also be timestamp with the current time in milliseconds
	// for calculating time to live
	function addAdToCache(adObject, adId) {
	    var cacheObject = {};
	    cacheObject.timestamp = new Date().getTime();
	    cacheObject.ad = adObject;

	    try {
	        writeToStorage(adId, JSON.stringify(cacheObject));
	    } catch (e) {

	    }
	}

	// returns the ad stored in the cache if the cache has not expired
	// returns null if the cache has expired (based on the configured time-to-live)
	// OR if there is no ad in the cache
	// NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function getCachedAd(adId) {
	    var ts = new Date().getTime();

	    var retrievedCacheItem;

	    try {
	        var itemFromCache = getFromStorage(adId);
	        retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
	        // clear the cache, setting it back to default (or empty)
	        deleteFromStorage(adId);
	    } catch (e) {

	    }

	    // check to see if the ad cache exists and if the cache has not expired
	    if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
	        var cacheAge = ts - retrievedCacheItem.timestamp;
	        //if we have expired, return nothing
	        if (cacheAge <= _ttlMsec) {
	            return retrievedCacheItem.ad;
	        }
	    }

	    return null;
	}

	// clear the ad cache by creating a default ad cache object
	//NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function clearAdCache(adId) {
	    try {
	        deleteFromStorage(adId);
	    } catch (e) {

	    }
	}

	// converts the time-to-live argument from minutes to milliseconds
	// to make it easier to compare timestamps
	function setTTL(ttlMinutes) {
	    _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
	}

	// gets the current token from the cache
	function getAdToken() {
	    var tokenToReturn;
	    var tokenFromCache;
	    tokenFromCache = getFromStorage(adTokenStorageKey);

	    if (tokenFromCache) {
	        tokenToReturn = parseInt(tokenFromCache);
	    } else {
	        //no token found, use default
	        tokenToReturn = 0;
	    }

	    //store new token in localStorage or local memory
	    writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


	    return tokenToReturn;
	}

	function prependAppnexusIdToKey(incomingKey) {
	    return "apn_" + incomingKey;
	}

	module.exports = {

	    /**
	     * Set generic data in cache
	     * @param (string) key = key under which to store data
	     * @param (object) value = value to store.
	     * @return (boolean) true if value was succesfully stored, false otherwise
	     */
	    setGenericData: function(key, value) {
	        if (typeof key !== "undefined" && typeof value !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            try {
	                writeToStorage(key, value);
	                return true;
	            } catch (e) {

	            }
	        }
	        return false;
	    },

	    /**
	     * Get generic data from cache
	     * @param (string) key = key to retrive from data
	     * @return (object) object contaninig data from cache with given key, undefined if key not found.
	     */
	    getGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            return getFromStorage(key);
	        }
	    },

	    /**
	     * Delete generic data from cache
	     * @param (string) key = key to delete from cache
	     */
	    deleteGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            deleteFromStorage(key);
	        }
	    },

	    /**
	     * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
	     * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
	     */
	    forceStorageMethod: function(storageType) {
	        storageTypeToUse = storageType;
	        utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
	    },

	    /**
	     * add the ad data to the cache
	     * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
	     *      - this will become the input into the ad rendering logic
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    addAd: function(adObject, adId) {
	        if (adObject) {
	            addAdToCache(adObject, prependAppnexusIdToKey(adId));
	        }
	    },

	    /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
	     * @param (integer) adId = unique identifier for a specific ad cache
	     * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
	     */
	    getAd: function(adId) {
	        return getCachedAd(prependAppnexusIdToKey(adId));
	    },

	    /**
	     * Clears the cache, removing any cached ad
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    clearAd: function(adId) {
	        clearAdCache(prependAppnexusIdToKey(adId));
	    },

	    /** Sets the time-to-live settings for the ad cache
	     * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
	     */
	    setTimeToLive: function(timeToLiveMinutes) {
	        setTTL(timeToLiveMinutes);
	    },

	    /**
	     * Returns a token unique to this page which is used to identify an ad request.
	     */
	    getNextAdToken: function() {
	        // Remove unnecessary additional characters.
	        // return chars.substring(0, len);
	        return getAdToken();
	    }
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Tracking Manager module.
	 * @module TrackingManager
	 */

	/**
	 * @description Unified Tracking Event Names
	 * Tracking events will be stored under the following names.
	 * These are the names that should be used when requesting tracking for an event
	 * Names being passed in from parsing or other structures will be mapped to these events.
	 * 	- bid-impression
	 *  - network-request
	 *  - network-response
	 * 	- impression
	 * 	- video-start
	 *  - video-first-quartile
	 *  - video-mid
	 *  - video-third-quartile
	 *  - video-complete
	 *  - ad-click
	 *  - video-pause
	 *  - video-rewind
	 *  - video-resume
	 *  - audio-mute
	 *  - audio-unmute
	 *  - video-fullscreen
	 *  - video-exit-fullscreen
	 *  - creative-view
	 *  - ad-expand
	 *  - ad-collapse
	 *  - user-accept-invitation
	 *  - user-close
	 *  - ad-progress
	 *  - error
	 * If an eventName cannot be mapped (for custom cases), then the name passed in will be used to store the set of video urls.
	 */
	/////////////////////////////////////////
	// VARIABLES
	/////////////////////////////////////////
	// CONSTANTS
	//var ERROR_TYPE_GENERAL = 0;
	var ERROR_TYPE_VAST = 1;
	//var ERROR_TYPE_HTTP = 2;
	var VAST_ERROR_MACRO = "[ERRORCODE]";
	var DEFAULT_KEY = "AN_DEFAULT";

	/////////////////////////////////////////
	// VARIABLES
	 var tracker = __webpack_require__(39);
	 var utils = __webpack_require__(34);

	 var prefix = "TM";
	 var trackingEvents = {};


	//////////////////////////////////////////
	// Log methods as following https://corpwiki.appnexus.com/pages/viewpage.action?spaceKey=SSV&title=Client+Side+JS+Browser+Console+Logging+Proposal
	var APN_Logger = __webpack_require__(2);
	// var always = function (message) {
	//     //log level 1
	//     APN_Logger.always(prefix, message);
	// };
	// var error = function (message) {
	//     //log level 2
	//     APN_Logger.error(prefix, message);
	// };
	var warn = function (message) {
	    //log level 3
	    APN_Logger.warn(prefix, message);//for such a case of network related like "url not found"
	};
	var info = function (message) {//for only initial tracking request
	    //log level 4
	    APN_Logger.info(prefix, message);
	};
	var log = function (message) {//for additional tracking request following intial trackings if it's required
	    //log level 5
	    APN_Logger.log(prefix, message);
	};
	// var debug = function (message) {
	//     //log level 6
	//     APN_Logger.debug(prefix, message);
	// };
	var verbose = function (message) {
	    //log level 7
	    APN_Logger.verbose(prefix, message);//for a registration part
	};






	/////////////////////////////////////////
	// CREATING TRACKING EVENTS DATA STRUCTURE
	// reset the trackingEvents object
	 function initTrackingEventsObject(){
		 trackingEvents = {};
	 }

	 // create a default tracking event object for a particular event
	 // this function assumes that that eventName has been normalized
	 // default setting for reportOnce is true
	 function createTrackingEventObject(eventName, adId){
		 if (!trackingEvents) {
			 trackingEvents = {};
		 }

		 adId = adId || DEFAULT_KEY;

		 if (!trackingEvents[adId]) {
			trackingEvents[adId] = {};
		 }

		 var obj = {};
		 obj.isImpression = false;
		 obj.reportOnce = true;
		 obj.reported = false;
		 obj.urls = [];

		 trackingEvents[adId][eventName] = obj;
		 verbose("tracking data created, adId=" + adId + ", event=" + eventName);
	 }

	 // normalize all tracking events into standard names
	 // unknown names will use the eventName passed in
	 function normalizeTrackingEventName(eventName) {
		 var answer = eventName;

		 // map eventnames found in VAST tags or appnexus structure to standard tracking event name
		 switch (eventName) {
		 case "impressionUrls" :
			 answer = "impression";
			 break;

		 case "clickTrackingUrls" :
		 case "click" :
			 answer = "ad-click";
			 break;

		 case "errorUrls" :
			 //answer = "vast-error";
			 answer = "error";
			 break;

		 case "imp_tracking_url" :
			 answer = "bid-impression";
			 break;

		 case "init_cb" :
			 answer = "ad-request";
			 break;

		 case "result_cb" :
			 answer = "ad-response";
			 break;

		 case "start" :
			 answer = "video-start";
			 break;

		 case "firstQuartile" :
			 answer = "video-first-quartile";
			 break;

		 case "midpoint" :
			 answer = "video-mid";
			 break;

		 case "thirdQuartile" :
			 answer = "video-third-quartile";
			 break;

		 case "thirdQuartile" :
			 answer = "video-third-quartile";
			 break;

		 case "complete" :
			 answer = "video-complete";
			 break;

		 case "unmute" :
			 answer = "audio-unmute";
			 break;

	     case "mute" :
	         answer = "audio-mute";
	         break;

		 case "pause" :
			 answer = "video-pause";
			 break;

		 case "rewind" :
			 answer = "video-rewind";
			 break;

		 case "resume" :
			 answer = "video-resume";
			 break;


		 case "fullscreen" :
			 answer = "video-fullscreen";
			 break;

		 case "exitFullscreen" :
			 answer = "video-exit-fullscreen";
			 break;

		 case "creativeView" :
			 answer = "creative-view";
			 break;

		 case "expand" :
			 answer = "ad-expand";
			 break;

		 case "collapse" :
			 answer = "ad-collapse";
			 break;

		 case "acceptInvitation" :
			 answer = "user-accept-invitation";
			 break;

		 case "close" :
			 answer = "user-close";
			 break;

		 case "progress" :
			 answer = "ad-progress";
			 break;

	     case "skip" :
	         answer = "video-skip";
	         break;
		 }

		 return answer;
	 }

	/////////////////////////////////////////
	// ADDING TRACKING EVENTS TO TRACKING MANAGER
	 // adds a tracking url for the specified eventName
	 // if an event object for that eventName does not already exist,
	 // it will be created with default values
	 function addTrackingUrlForEvent(eventName, trackingUrl, adId) {
		 adId = adId || DEFAULT_KEY;

		 eventName = normalizeTrackingEventName(eventName);

		 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
			 createTrackingEventObject(eventName, adId);
		 }

		 trackingEvents[adId][eventName].urls.push(trackingUrl);
		 verbose("Tracking added, adId=" + adId + ", event=" + eventName + ", url=" + trackingUrl);
	 }

	 // create a mediation event name for a specific network
	 // this will be the key where the tracking urls are stored
	 // as well as the key for looking up the tracking urls for a mediation event for a network
	 function createMediationEventName(eventName, networkName) {
		 var answer = "";

		 if (utils.isNotEmpty(eventName) && utils.isNotEmpty(networkName)) {
			 eventName = normalizeTrackingEventName(eventName);
			 answer = eventName + "_" + networkName;
		 }

		 return answer;
	 }

	 ////////////////////////////////////////////////////////////////////////////
	// CONTROLLING TRACKING
	//returns true if the event name is considered an impression tracker
	//otherwise returns false
	function isImpressionEvent(eventName, adId) {
		adId = adId || DEFAULT_KEY;

		var answer = false;

		var eventObj = trackingEvents[adId][eventName];
		if (eventObj && eventObj.hasOwnProperty("isImpression")) {
			answer = (eventObj.isImpression === true);
		}

		return answer;
	}

	// sets property to control whether an event can be reported only once
	// if it is a mediation tracking event - you need to also pass in the networkName
	// and the eventName will be a combination of the event name and the network name
	 // true = report only once, false = may be reported multiple times
	 function setReportOnlyOnce(eventName, restricted, adId) {
		adId = adId || DEFAULT_KEY;

		 if (utils.isNotEmpty(eventName)) {
			 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
				 createTrackingEventObject(eventName, adId);
			 }

			 var eventObj = trackingEvents[adId][eventName];
			 eventObj.reportOnce = restricted;
			 verbose("setting report once, adId=" + adId + ", event=" + eventName + ", setting=" + restricted);
		 }
	 }

	// sets property to control whether an event can be reported only once
	// if it is a mediation tracking event - you need to also pass in the networkName
	// and the eventName will be a combination of the event name and the network name
	 // true = report only once, false = may be reported multiple times
	 function setReportOnlyOnceMediation(eventName, restricted, networkName, adId) {
		 adId = adId || DEFAULT_KEY;

		 if (utils.isNotEmpty(eventName)) {
			 // normalize the event name, adding in the network name if specified
			 eventName = normalizeTrackingEventName(eventName);
			 if (utils.isNotEmpty(networkName)) {
				 eventName = createMediationEventName(eventName, networkName);
			 }

			 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
				 createTrackingEventObject(eventName, adId);
			 }

			 var eventObj = trackingEvents[adId][eventName];
			 eventObj.reportOnce = restricted;
			 verbose("setting report once, adId=" + adId + ", event=" + eventName + ", setting=" + restricted);
		 }
	 }

	 // resets the reported flag back to false for all the events with the exception of impression events
	 // if the resetImpression arg is true, then impression events will also be reset to false
	function resetTrackingEventReported(resetImpression, adId) {
		adId = adId || DEFAULT_KEY;

		if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
			var adObject = trackingEvents[adId];
			for (var eventName in adObject) {
				if (isImpressionEvent(eventName, adId) && !resetImpression) {
					verbose("reset history skipping impression event=" + eventName + ", adId=" + adId);
				}
				else {
					 var eventObj = trackingEvents[adId][eventName];
					 eventObj.reported = false;
					 verbose("reset history for adId= " + adId + ", event=" + eventName);
				}
			}
		}
	}

	// marks an event as an impression type
	// used when resetting reporting history -
	// you may or may not want to also reset impression events
	function setEventAsImpression(eventName, isImpression, adId){
		adId = adId || DEFAULT_KEY;

		 eventName = normalizeTrackingEventName(eventName);

		 if (!trackingEvents.hasOwnProperty(adId) || !trackingEvents[adId].hasOwnProperty(eventName)) {
			 createTrackingEventObject(eventName, adId);
		 }

		 trackingEvents[adId][eventName].isImpression = isImpression;
	}


	/////////////////////////////////////////
	// EXECUTING TRACKING EVENTS

	//passes the url over to the module that will actually hit the tracking pixel
	//defined for a particular event
	function hitTrackingUrl(url, eventName){
	    log("requesting tracking for " + eventName + ", url=" + url);
	    tracker.trackPixel(url, eventName);
	}

	//add a param value at the end of a url as a query string value
	//e.g. ?error=123
	//if the url already contains some query string parameters
	//meaning that the ? is already there
	//append the parameter using the &
	function addParameterAsQueryString(url, paramValue) {
	    var answer = url;

	    var delimiter = "?";
	    if (url.indexOf("?") > -1) {
	        delimiter = "&";
	    }

	    answer = url + delimiter + paramValue;

	    return answer;
	}


	//replace the macro with the param value
	//this function assumes that you have already checked to make sure
	//that the macro is present
	//if the macro is not found, then the url will be unchanged
	function addParameterAsMacro(url, paramValue, macroValue) {
	    var answer = url;

	    if (url.indexOf(macroValue) > -1){
	        answer = url.replace(macroValue, paramValue);
	    }

	    return answer;
	}



	//adds a specified parameter to a stored tracking url
	//param is an object which may contain two fields:
	//		- value (required) = value should be added to the tracking url
	//		= macro (optional) = macro which will be replaced with the value
	//if a macro is not specified or if the macro is not found in the url,
	//then the param will be added at the end as a query string parameter
	function addParameterToTrackingUrl(url, param) {
	    if (param) {
	        // get the value to add to the url
	        var val = param.value;
	        val = (val && typeof(val) === "number") ? val.toString() : val;//work-around of a bug of isNotEmpty function, isNotEmpty could return false if parameter is integrer and it will be a consequence to not perform the macro substition for VID-2120
	        if (utils.isNotEmpty(val)) {
	            // check to see if there if a macro
	            var macro = param.macro;
	            if (utils.isNotEmpty(macro)) {
	                // check to see if the url contains the macro
	                // if so add the parameter as a macro replacement
	                if (url.indexOf(macro) > -1) {
	                    url = addParameterAsMacro(url, val, macro);
	                }
	            }
	            else {
	                // a macro was not specified
	                // so add the parameter as a query string parameter
	                url = addParameterAsQueryString(url, val);
	            }
	        }
	    }

	    return url;
	}

	// Reports all tracking urls associated with a particular tracking event name
	function trackEvent(eventName, param, adId){
		adId = adId || DEFAULT_KEY;

		var fnd = false;
		if (trackingEvents.hasOwnProperty(adId) && trackingEvents[adId].hasOwnProperty(eventName)) {
			var eventObj = trackingEvents[adId][eventName];
			if (eventObj){
				// check to make sure that the event may be reported more than once
				// or, if it can be reported only once, that it has not already been reported
				if ((eventObj.reportOnce) && (eventObj.reported)) {
					info("Cannot report event - event has already been reported: " + eventName + " for adId=" + adId);
					fnd = true;
				}
				else {
					var urls = eventObj.urls;
					if (urls) {
						eventObj.reported = true;
						for (var i = 0; i < urls.length; i++) {
							var url = urls[i];
							if (utils.isNotEmpty(url)) {
								fnd = true;
								if (param) {
									url = addParameterToTrackingUrl(url, param);
								}
								hitTrackingUrl(url, eventName);
							}
						}
					}
				}
			}
		}

		if (!fnd) {
			warn("No tracking urls found for adId=" + adId + ", event = " + eventName);
		}
	}


	/////////////////////////////////////////
	// ADDING PARAMETERS TO TRACKING URLS
	// creates a param object for mediation events
	// each field in the object will be a key and the value of the field will be the value
	// the resulting string
	function createMediationTrackingParams (params){
	    verbose("Creating params for mediation tracking from obj: " + utils.objectToString(params));
	    var answer = {};
	    var paramString = "";

	    if (params) {
	        for (var key in params) {
	            if (params[key] !== null && params[key] !== 'undefined'){
	                if (paramString.length > 0) {
	                    paramString += "&";
	                }
	                var str = key + "=" + params[key];
	                paramString += str;
	            }
	        }
	    }

	    answer.value = paramString;
	    return answer;
	}


	// reports all tracking urls for a specific event and network
	// params will be added ot the tracking urls
	function trackMediationEvent(eventName, networkName, params, adId) {
		var ename =  createMediationEventName(eventName, networkName);
		var paramObj = createMediationTrackingParams(params);
		trackEvent(ename, paramObj, adId);
	}






	// create an event name for a progress event for a particular offset
	function createProgressEventName(offset) {
		return ("progress>" + offset);
	}
	/////////////////////////////////////////////////////////////////
	// CLEAN UP
	function removeEventsForKey(key, adId) {
		adId = adId || DEFAULT_KEY;
		if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
			var eventList = trackingEvents[adId];
			for (var field in eventList) {
				// data.substring(0, input.length) === input
				if (field.indexOf(key) > -1) {
					delete trackingEvents[adId][field];
					verbose("Removing event: " + field + " for key=" + key + " and adId=" + adId);
				}
			}
			if (trackingEvents[adId].length === 0) {
				delete trackingEvents[adId];
			}
		}
	}

	function removeEvents(adId) {
		adId = adId || DEFAULT_KEY;
		if (trackingEvents && trackingEvents.hasOwnProperty(adId)) {
			var eventList = trackingEvents[adId];
			delete trackingEvents[adId];
			for (var event in eventList) {
				verbose("Removing event: " + event + " for adId=" + adId);
			}
		}
	}

	////////////////////////////////////////////////////////////////
	// EXPORTS
	module.exports = {
		/**
		 * Resets all the data structures for the Tracking Manager
		 * @param(array) unrestrictedEventsList - an array of eventNames for events that may be reported more than once
		 * 	by default, tracking events are reported only once
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		init : function(unrestrictedEventsList, adId){
			removeEvents(adId);
			if (unrestrictedEventsList) {
				for (var i = 0; i < unrestrictedEventsList.length; i++) {
					setReportOnlyOnce(unrestrictedEventsList[i], false, adId);
				}
			}
		},

		/**
		 * Add a tracking event to the set of tracking events
		 * being managed by the Tracking Manager
		 * @param (string) eventName - name of the event to be tracked
		 * @param (string) trackingUrl - tracking url to "hit" whenever this event is reported
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addTrackingEvent: function(eventName, trackingUrl, adId){
			addTrackingUrlForEvent(eventName, trackingUrl, adId);
		},

		/**
		 * Merge the tracking events provided in the argument with
		 * the set of tracking events being managed by the Tracking Manager
		 * @param (json) trackingObject - object which contains a set of tracking events with associated tracking urls
		 * 		- each field name in trackingObject is the name of a tracking event (e.g. "video-start")
		 * 		- the value of each field is an array of tracking urls - even if there is only one tracking url
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addTrackingEvents: function(trackingObject, adId){
			if (trackingObject) {
				for (var eventName in trackingObject) {
					var urls = trackingObject[eventName];
					if (utils.isNotEmpty(urls)){
						for (var i = 0; i < urls.length; i++) {
							addTrackingUrlForEvent(eventName, urls[i], adId);
						}
					}
				}
			}
		},

		/**
		 * Add tracking events that are used when running client side mediation
		 * each url is network dependent so the event name stored in Tracking Manager
		 * will contain both the event name and the network name
		 * @param (string) eventName = name of tracking event that will be requested
		 * 		- eventName will be normalized to a standardized name if needed
		 * @param (string) networkName = identifier which uniquely identifies a network to hit for mediation
		 * 		- initially this name will be internally generated
		 * @param (string) trackingUrl = tracking url to "hit" whenever this event is reported
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addMediationTrackingEvent : function(eventName, networkName, trackingUrl, adId) {
			var ename = createMediationEventName(eventName, networkName);
			verbose("creating event name for adId=" + (adId ? adId : DEFAULT_KEY) + ", event=" + eventName + ", networkName=" + networkName + " =>" + ename);
			addTrackingUrlForEvent(ename, trackingUrl, adId);
		},

		/**
		 * adds a tracking url for a progress event for a particular offset (as defined in the VAST xml)
		 * @param (string) offset = some time when this event should be reported
		 * 	- this can be a elapsed time in HH:MM:SS or HH:MM:SS.mmm or a %
		 * @param (string) trackingUrl = url that is to be hit when this event is to be tracked
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		addProgressTrackingEvent : function (offset, trackingUrl, adId) {
			var eventName = createProgressEventName(offset);
			addTrackingUrlForEvent(eventName, trackingUrl, adId);
		},

		/**
		 * Marks an event as an "impression event" - this is used when resetting the reporting history
		 * @param (string) eventName = name of event - this name will be normalized
		 * @param (boolean) isImpression
		 * 		- true = event is an impression event
		 * 		- false = event is NOT an impression event
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		markAsImpressionEvent : function(eventName, isImpression, adId) {
			verbose("marking event as impression: " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY) + ", value=" + isImpression);
			setEventAsImpression(eventName, isImpression, adId);
		},

		/**
		 * Marks an event as an "impression event" - this is used when resetting the reporting history
		 * @param (string) eventName = name of event - this name will be normalized
		 * @param (boolean) isImpression
		 * 		- true = event is an impression event
		 * 		- false = event is NOT an impression event
		 * @param (string) networkName = name of a network that is involved in mediation events
		 * 		- use only when the event is conisdered to be a mediation event
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		markAsMediationImpressionEvent : function(eventName, isImpression, networkName, adId) {
			if (utils.isNotEmpty(networkName)) {
				eventName = createMediationEventName(eventName, networkName);
			}

			verbose("marking event as impression: " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY) + ", value=" + isImpression);
			setEventAsImpression(eventName, isImpression, adId);
		},

		/**
		 * Mark a tracking event as being "report-only-once", meaning that if the event has already been
		 * reported, do not report it again.
		 * There will be another method that will reset all the reporting settings, if needed
		 * @param (string) eventName - the name of the tracking event
		 * @param (boolean) restricted - indicates whether the event may only be reported once
		 * 		- true = event will only be reported once (default)
		 * 		- false = event will be reported every time it is requested
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		reportOnlyOnce : function(eventName, restricted, adId) {
			setReportOnlyOnce(eventName, restricted, adId);
		},

		/**
		 * Mark a tracking event as being "report-only-once", meaning that if the event has already been
		 * reported, do not report it again.
		 * There will be another method that will reset all the reporting settings, if needed
		 * @param (string) eventName - the name of the tracking event
		 * @param (boolean) restricted - indicates whether the event may only be reported once
		 * 		- true = event will only be reported once (default)
		 * 		- false = event will be reported every time it is requested
		 * @param (string) networkName = name of network
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		reportMediationOnlyOnce : function(eventName, restricted, networkName, adId) {
			setReportOnlyOnceMediation(eventName, restricted, networkName, adId);
		},

		/**
		 * Clears tracking reporting history - used in the case where the ad is being re-played
		 * and the ad unit wants to be able to re-report video events and other events
		 * or the player is being used for another ad
		 * @param (boolean) resetImpression - indicates whether impression events should also be reset
		 * 		- true = also reset the impression events
		 * 		- false = do NOT reset the impression events
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		resetTrackingHistory : function(resetImpression, adId) {
			resetTrackingEventReported(resetImpression, adId);
		},

		/**
		 * request tracking for a tracking event
		 * @param(string) eventName - name of the event being tracked
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestTracking : function(eventName, adId){
			info("tracking requested for " + eventName + ", adId=" + (adId ? adId : DEFAULT_KEY));
			trackEvent(eventName, null, adId);
		},

		/**
		 * request tracking for a tracking event that requires a parameter (such as error reporting)
		 * @param (string) eventName - name of event being tracked
		 * @param (object) param - object containing information about parameters to add to tracking url
		 * 		- value = field in object identifying the value to add to the tracking url
		 * 		- macro = (optional) field in object identifying a macro present in the tracking url where to place
		 * 					the value
		 * 		- if macro field is missing or empty, then the param will be added at the end as a query string param
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestParamTracking : function(eventName, param, adId){

			info("tracking requested for " + eventName + " with param=" + utils.objectToString(param) + ", adId=" + (adId ? adId : DEFAULT_KEY));
			trackEvent(eventName, param, adId);
		},

		/**
		 * request tracking for a mediation related event for a specific network
		 * parameters may also be optionally passed in to add to the tracking url
		 * @param (string) eventName = name of the event being tracked
		 * @param (string) networkName = name identifying the network for whom the event is being tracked
		 * @param (json) params = optional object containing parameters that need to be added to the tracking url
		 * 		- will contain fields which will be used to create query string params that will
		 * 			be added to the end of a mediation tracking url
		 * 			example: reason: 0, latency_type: 1, latency: 1500}
		 * @param(string) adId - a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestMediationTracking : function(eventName, networkName, params, adId) {
			info("tracking requested for mediation event: " + eventName + ", network=" + networkName + " , params=" + utils.objectToString(params) + ", adId=" + (adId ? adId : DEFAULT_KEY));
			trackMediationEvent(eventName, networkName, params, adId);
		},

		/**
		 * request tracking for an error condition
		 * @param (integer) errorCode = error code identifying the error condition
		 * @param (integer) errorType = identifies the type of error (this controls how this is reported); can be one of the following
		 * 		0 = general appnexus error
		 * 		1 = vast-error (one of the error codes specified in the VAST spec)
		 * 		2 = http error
		 * @param (string) errorDescription = string used primarily for logging the error
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestErrorTracking : function (errorCode, errorType, errorDescription, adId) {
			info("error reported: " + errorCode + ", type=" + errorType + ", desc=" + errorDescription, + ", adId=" + (adId ? adId : DEFAULT_KEY));
			var paramObj = {};
			var eventName = "";

			// check to see if it is a VAST error (which requires macro substitution)
			switch (errorType) {
			case ERROR_TYPE_VAST :
				paramObj.macro = VAST_ERROR_MACRO;
				paramObj.value = errorCode;
				//eventName = "vast-error";	// note we have to collapse vast errors and errors into errors because impbus also returns error tracking url
				eventName = "error";
				break;

			default :
				paramObj.value = ("error=" + errorCode);
				eventName = "error";
			}

			this.requestParamTracking(eventName, paramObj, adId);
		},

		/**
		 * request tracking for a progress event for a particular offset
		 * @param (string) offset = some time when this event should be reported
		 * 	- this can be a elapsed time in HH:MM:SS or HH:MM:SS.mmm or a %
		 *  - NOTE: the offset being passed must be exact same format as how the event was created
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		requestProgressTracking : function (offset, adId) {
			var eventName = createProgressEventName(offset);

			info("Tracking requested for progress event, adId=" + (adId ? adId : DEFAULT_KEY) + ", offset=" + offset);
			this.requestTracking(eventName, adId);
		},

		/**
		 * clears all the events from the tracking events data structure with adId=adId (or default)
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 *      - if an adId is passes into the function, will remove all events associated with the adId
		 *      - if no adId is passed, will remove all events associated with the default adId
		 */
		removeEvents : function(adId) {
			removeEvents(adId);
		},

		/**
		 * clears all the events from the tracking events data structure with an eventName starting with 'key'
		 * optional adId parameter to search through ads associated with a particular adId
		 * @param (string) key = string to identify a set of tracking data for a particular set
		 * @param(string) adId - (optional) a unique identifier under which tracking events are stored (default=AN_DEFAULT)
		 */
		removeEventsForKey : function(key, adId) {
			removeEventsForKey(key, adId);
		},

		/**
		 * clears all events from tracking events data structure
		 * only use if you are sure you want to remove all events regardless of adId
		 */
		removeAllEvents : function() {
			initTrackingEventsObject();
		}
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * URL Loader module.
	 * @module UrlLoader
	 */



	var _logger = __webpack_require__(2);

	function ajaxLoad(url, callback, timeout, options) {

	    var httpRequest;
	    var startTime = 0;
	    var duration = 0;
	    var calcDuration = false;
	    var logger = __webpack_require__(34);
	    var cacheManager = __webpack_require__(40);

	    var useWithCredentials = true;

		var debug = function(message) {
		    logger.logDebug(message, 'URL Loader');
		};

	    if (options &&  typeof options.withCredentials !== 'undefined') {
	        useWithCredentials = options.withCredentials;
	    }

	    if (window.XMLHttpRequest) { // Mozilla, Safari, ...
	        httpRequest = new XMLHttpRequest();
	    } else if (window.ActiveXObject) { // IE
	        try {
	            httpRequest = new ActiveXObject('Msxml2.XMLHTTP');
	        } catch (msxmlErr) {
	            try {
	                httpRequest = new ActiveXObject('Microsoft.XMLHTTP');
	            } catch (msErr) {}
	        }
	    }


	    if (!httpRequest) {
	        if (callback) {
	            callback.call(this, '406', ''); // request is not acceptable
	        }
	        return;
	    }

	    httpRequest.onreadystatechange = function() {
	        if (httpRequest.readyState === 4) {

	            if (httpRequest.status === 200) {
	                if (callback) {
	                    callback.call(this, undefined, httpRequest.responseText, httpRequest);
	                }
	                debug('duration: ' + duration + ', response length: ' + httpRequest.responseText.length);
	                if (calcDuration && httpRequest.responseText && httpRequest.responseText.length > 2048) {
				var nBandWidth = (httpRequest.responseText.length * 8.0 * 1000.0) / (Math.max(1.0, duration) * 1024.0);
				var intBandwidth = parseInt(nBandWidth.toString());
	                    debug('Bandwidth: ' + intBandwidth);
				try {
					cacheManager.setGenericData('anxBandwidth', intBandwidth);
					//localStorage.setItem('anxBandwidth', intBandwidth);
				}
				catch(ex) {
				}
	                }
	            } else {
	                if (httpRequest.status >= 400 && httpRequest.status < 600) {
	                    if (callback) {
	                        callback.call(this, httpRequest.status, '', httpRequest);
	                    }
	                }
	            }

	        }
	        else if (httpRequest.readyState === 2) {
			startTime = (new Date()).getTime();
	        }
	        else if (httpRequest.readyState === 3) {
			if (startTime > 0) {
				calcDuration = true;
				duration = (new Date()).getTime() - startTime;
			}
	        }
	    };

	    httpRequest.onerror = function() {
	        //if there is an error, it might be becase we are using withCredentials
	        //let's try one more time without that flag set.
	        //this won't send cookies, but it's better than no ad at all
	        if(useWithCredentials) {
	            var newOpts = options ? options : {};
	            newOpts.withCredentials = false;
	            ajaxLoad(url, callback, timeout, newOpts);
	        } else {
	            if (callback) {
	                var errorStatus = httpRequest.status === 0 ? '404' : httpRequest.status.toString();
	                callback.call(this, errorStatus, '', httpRequest);
	            }
	        }
	    };


	    httpRequest.ontimeout = function() {
	        //_logger.log('Server Timeout');
	        if (callback) {
	            callback.call(this, 'Timeout', '', httpRequest);
	        }
	    };

	    httpRequest.open('GET', url);
	    if (timeout) {
	        httpRequest.timeout = timeout;
	    }
	    httpRequest.withCredentials = useWithCredentials;
	    startTime = 0;
	    httpRequest.send();
	}

	function createTrackingPixel(url, eventName) {
	    _logger.log('Logging Event: ' + eventName + ' at url:' + url);
	    new Image(1, 1).src = url;

	}



	module.exports = {
	    /** Load a URL.
	     * @param {string} url - Target URL to load.
	     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
	     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
	     */
	    load: function(url, callback, timeout) {
	        ajaxLoad(url, callback, timeout, {withCredentials:true});
	    },


	    /** Track Pixel.
	     * @param {String} url - Url of traking pixel to track.
	     * @param {String} eventName - Name of event being tracked.
	     */
	    trackPixel: function(url, eventName) {
	        createTrackingPixel(url, eventName);
	    }
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Cache Manager module.
	 * @module CacheManager
	 */

	var utils = __webpack_require__(34);


	var prefix = "Cache Manager";

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
	var MSEC_PER_MINUTE = 60 * 1000;
	var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var _ttlMsec = TTL_DEFAULT_MSEC;

	var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
	var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

	var backupInMemoryStorageObj = {};

	//storage types:
	//0 - localStorage
	//1 - cookie
	//2 - in memory
	var storageTypeToUse;

	if (isLocalStorageSupported()) {
	    storageTypeToUse = 0;
	} else {
	    if (isCookieStorageSupported()) {
	        storageTypeToUse = 1;
	    } else {
	        storageTypeToUse = 2;
	    }

	}

	utils.debug("Using Cache Method " + storageTypeToUse, prefix);

	//docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	var docCookies = {
	    getItem: function(sKey) {
	        if (!sKey) {
	            return null;
	        }
	        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	    },
	    setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	            return false;
	        }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    },
	    removeItem: function(sKey, sPath, sDomain) {
	        if (!this.hasItem(sKey)) {
	            return false;
	        }
	        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	        return true;
	    },
	    hasItem: function(sKey) {
	        if (!sKey) {
	            return false;
	        }
	        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
	    },
	    keys: function() {
	        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	        }
	        return aKeys;
	    }
	};

	//write object to whatever storage method we are using, with specified key
	function writeToStorage(key, obj, dontExpire) {
	    switch (storageTypeToUse) {
	        case 0:
	            writeToLocalStorage(key, obj);
	            break;
	        case 1:
	            writeToCookieStorage(key, obj, dontExpire);
	            break;
	        default:
	        case 2:
	            writeToInMemoryStorage(key, obj);
	            break;
	    }
	}

	//get a object from the storage method we are using, that has the specified key
	function getFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            return getFromLocalStorage(key);
	        case 1:
	            return getFromCookieStorage(key);
	        default:
	        case 2:
	            return getFromInMemoryStorage(key);
	    }

	}

	//delete an object in the storaege method we are using,
	function deleteFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            deleteFromLocalStorage(key);
	            break;
	        case 1:
	            deleteFromCookieStorage(key);
	            break;
	        default:
	        case 2:
	            deleteFromInMemoryStorage(key);
	            break;
	    }
	}

	function writeToLocalStorage(key, obj) {
	    if (localStorage) {
	        localStorage.setItem(key, obj);
	    }
	}

	function getFromLocalStorage(key) {
	    if (localStorage) {
	        return localStorage.getItem(key);
	    }
	}

	function deleteFromLocalStorage(key) {
	    if (localStorage) {
	        localStorage.removeItem(key);
	    }
	}

	function writeToCookieStorage(key, obj, dontExpire) {
	    docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
	}

	function getFromCookieStorage(key) {
	    return docCookies.getItem(key);
	}

	function deleteFromCookieStorage(key) {
	    docCookies.removeItem(key);
	}

	function writeToInMemoryStorage(key, obj) {
	    if (backupInMemoryStorageObj) {
	        backupInMemoryStorageObj[key] = obj;
	    }
	}

	function getFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        return backupInMemoryStorageObj[key];
	    }
	}

	function deleteFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        delete backupInMemoryStorageObj[key];
	    }
	}

	//return true if localStorage is supported, false otherwise
	function isLocalStorageSupported() {

	    //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
	    try {
	        if (localStorage) {
	            var testValue = "apntestls" + Math.random();
	            try {
	                //try writing and reading something
	                localStorage.setItem(testValue, testValue);
	                localStorage.removeItem(testValue);
	                return true;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}


	//return true if localStorage is supported, false otherwise
	function isCookieStorageSupported() {
	    try {
	        if (document && document.cookie) {
	            var testValue = "apntestcookie" + Math.random();
	            try {
	                docCookies.setItem(testValue, testValue, Infinity);
	                var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
	                docCookies.removeItem(testValue);
	                return cookieWorked;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}

	// caches the adObject - this will overwrite any existing cached ad
	// the cache will also be timestamp with the current time in milliseconds
	// for calculating time to live
	function addAdToCache(adObject, adId) {
	    var cacheObject = {};
	    cacheObject.timestamp = new Date().getTime();
	    cacheObject.ad = adObject;

	    try {
	        writeToStorage(adId, JSON.stringify(cacheObject));
	    } catch (e) {

	    }
	}

	// returns the ad stored in the cache if the cache has not expired
	// returns null if the cache has expired (based on the configured time-to-live)
	// OR if there is no ad in the cache
	// NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function getCachedAd(adId) {
	    var ts = new Date().getTime();

	    var retrievedCacheItem;

	    try {
	        var itemFromCache = getFromStorage(adId);
	        retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
	        // clear the cache, setting it back to default (or empty)
	        deleteFromStorage(adId);
	    } catch (e) {

	    }

	    // check to see if the ad cache exists and if the cache has not expired
	    if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
	        var cacheAge = ts - retrievedCacheItem.timestamp;
	        //if we have expired, return nothing
	        if (cacheAge <= _ttlMsec) {
	            return retrievedCacheItem.ad;
	        }
	    }

	    return null;
	}

	// clear the ad cache by creating a default ad cache object
	//NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function clearAdCache(adId) {
	    try {
	        deleteFromStorage(adId);
	    } catch (e) {

	    }
	}

	// converts the time-to-live argument from minutes to milliseconds
	// to make it easier to compare timestamps
	function setTTL(ttlMinutes) {
	    _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
	}

	// gets the current token from the cache
	function getAdToken() {
	    var tokenToReturn;
	    var tokenFromCache;
	    tokenFromCache = getFromStorage(adTokenStorageKey);

	    if (tokenFromCache) {
	        tokenToReturn = parseInt(tokenFromCache);
	    } else {
	        //no token found, use default
	        tokenToReturn = 0;
	    }

	    //store new token in localStorage or local memory
	    writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


	    return tokenToReturn;
	}

	function prependAppnexusIdToKey(incomingKey) {
	    return "apn_" + incomingKey;
	}

	module.exports = {

	    /**
	     * Set generic data in cache
	     * @param (string) key = key under which to store data
	     * @param (object) value = value to store.
	     * @return (boolean) true if value was succesfully stored, false otherwise
	     */
	    setGenericData: function(key, value) {
	        if (typeof key !== "undefined" && typeof value !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            try {
	                writeToStorage(key, value);
	                return true;
	            } catch (e) {

	            }
	        }
	        return false;
	    },

	    /**
	     * Get generic data from cache
	     * @param (string) key = key to retrive from data
	     * @return (object) object contaninig data from cache with given key, undefined if key not found.
	     */
	    getGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            return getFromStorage(key);
	        }
	    },

	    /**
	     * Delete generic data from cache
	     * @param (string) key = key to delete from cache
	     */
	    deleteGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            deleteFromStorage(key);
	        }
	    },

	    /**
	     * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
	     * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
	     */
	    forceStorageMethod: function(storageType) {
	        storageTypeToUse = storageType;
	        utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
	    },

	    /**
	     * add the ad data to the cache
	     * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
	     *      - this will become the input into the ad rendering logic
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    addAd: function(adObject, adId) {
	        if (adObject) {
	            addAdToCache(adObject, prependAppnexusIdToKey(adId));
	        }
	    },

	    /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
	     * @param (integer) adId = unique identifier for a specific ad cache
	     * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
	     */
	    getAd: function(adId) {
	        return getCachedAd(prependAppnexusIdToKey(adId));
	    },

	    /**
	     * Clears the cache, removing any cached ad
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    clearAd: function(adId) {
	        clearAdCache(prependAppnexusIdToKey(adId));
	    },

	    /** Sets the time-to-live settings for the ad cache
	     * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
	     */
	    setTimeToLive: function(timeToLiveMinutes) {
	        setTTL(timeToLiveMinutes);
	    },

	    /**
	     * Returns a token unique to this page which is used to identify an ad request.
	     */
	    getNextAdToken: function() {
	        // Remove unnecessary additional characters.
	        // return chars.substring(0, len);
	        return getAdToken();
	    }
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var APN_RenditionManager = __webpack_require__(36);
	var APN_Logger = __webpack_require__(2);
	var _prefix = "CompanionsHandler > ";

	var CompanionHandler = function(containerElement, width, height, companionData, notifCallback) {
		var _containerElement = containerElement;
		var _companionData = companionData;
		var _notificationCallback = notifCallback;
		var _containerSize = {width: width, height: height};

		var _uniqueId = new Date().getTime() + Math.floor(Math.random() * 10000);

		// register companion trackings
		_notificationCallback({command: 'addTrackingEvents', uniqueId: _uniqueId, data: _companionData});

		var onClick = function() {
			if (_companionData.CompanionClickTracking) {
				_notificationCallback({command: 'requestTracking', uniqueId: _uniqueId, data: 'companion-click'});
			}
			if (_companionData.hasOwnProperty('StaticResource') && _companionData.CompanionClickThrough) {
				window.open(_companionData.CompanionClickThrough);
			}
		};

		var onLoad = function() {
			if (_companionData.TrackingEvents && _companionData.TrackingEvents.length > 0) {
				_notificationCallback({command: 'requestTracking', uniqueId: _uniqueId, data: 'creative-view'});
			}
		};

		var _needClickHandler = true;
		if (_companionData.hasOwnProperty('StaticResource')) {
			var type = _companionData.StaticResource.type;
			if (type === 'application/x-javascript') {
				var script = document.createElement('script');
				script.src = _companionData.StaticResource.src;
				script.onload = onLoad();
				_containerElement.appendChild(script);
			}
			else if (type === 'application/x-shockwave-flash') {
			    var flashObj = document.createElement("object");
			    flashObj.type = 'application/x-shockwave-flash';
			    flashObj.data = _companionData.StaticResource.src;
			    flashObj.width = _containerSize.width;
			    flashObj.height = _containerSize.height;
			    flashObj.style.top = '0';
			    flashObj.style.left = '0';
			    flashObj.style.width = _containerSize.width + "px";
			    flashObj.style.height = _containerSize.height + "px";

			    var par1 = document.createElement('param');
			    par1.name = 'allowNetworking';
			    par1.value = 'all';
			    flashObj.appendChild(par1);
			    var par2 = document.createElement('param');
			    par2.name = 'wmode';
			    par2.value = 'opaque';
			    flashObj.appendChild(par2);
			    flashObj.onload = onLoad();
				_needClickHandler = false;
				_containerElement.appendChild(flashObj);
			}
			else if (type.indexOf('image') === 0) {
				// image
				var img = document.createElement('img');
				img.src = _companionData.StaticResource.src;
				img.style.maxWidth = '100%';
				img.style.maxHeight = '100%';
				img.style.width = 'auto';
				img.style.height = 'auto';
				img.style.margin = 'auto';
				img.style.display = 'block';
				img.style.top = 0;
				img.style.bottom = 0;
				img.style.left = 0;
				img.style.right = 0;
				img.style.position = 'absolute';
				img.onload = onLoad();
				img.onclick = onClick;
				_needClickHandler = false;
				img.style.cursor = 'pointer';
				_containerElement.style.display = 'inline-block';
				_containerElement.style.position = 'relative';
				_containerElement.appendChild(img);
			}
		}
		else if (_companionData.hasOwnProperty('IFrameResource')) {
			var iframe = document.createElement('iframe');
			iframe.src = _companionData.IFrameResource;
			iframe.scrolling = 'no';
			iframe.style.width = '100%';
			iframe.style.height = '100%';
			iframe.style.border = 'none';
			iframe.style.overflow = 'hidden';
			iframe.onload = onLoad();
			_needClickHandler = false;
			_containerElement.appendChild(iframe);
		}
		else if (_companionData.hasOwnProperty('HTMLResource')) {
			if (_companionData.HTMLResource.indexOf('http') === 0) {
			    var UrlLoader = __webpack_require__(42);
			    UrlLoader.load(_companionData.HTMLResource,
			        function(error, responseText) {
					if (error || responseText.length === 0) {
						// _notificationCallback
					}
					else {
						_containerElement.style.display = 'inline-block';
						_containerElement.style.position = 'relative';
						_containerElement.innerHTML = responseText;
						onLoad();
					}
			        });
			}
			else {
				_containerElement.style.display = 'inline-block';
				_containerElement.style.position = 'relative';
				_containerElement.innerHTML = _companionData.HTMLResource;
				onLoad();
			}
		}
		if (_needClickHandler) {
			if (_companionData.hasOwnProperty('StaticResource') && _companionData.CompanionClickThrough) {
				_containerElement.style.cursor = 'pointer';
			}
			_containerElement.onclick = onClick;
		}

		this.stop = function() {
			_containerElement.innerHTML = '';
		};
	};

	var CompanionsHandler = function(companionAds, options, notifCallback) {
		var _companionAds = companionAds;
		var _options = options;
		var _notificationCallback = notifCallback;

		var _companions = [];

		APN_Logger.always(_prefix, 'Version: 0.1.7');

		var containersData = [];
		for (var i = 0; i < _options.companionContainers.length; i++) {
			try {
				var styles = window.getComputedStyle(_options.companionContainers[i], null);
				var obj = {id:i, width: parseInt(styles.width), height: parseInt(styles.height), companion: null};
				containersData.push(obj);
			}
			catch(ex) {}
		}
		APN_RenditionManager.selectCompanionsForContainers(_companionAds, containersData);
		for (i = 0; i < containersData.length; i++) {
			if (containersData[i].companion) {
				var companion = new CompanionHandler(_options.companionContainers[i], containersData[i].width, containersData[i].height,
						containersData[i].companion, _notificationCallback);
				_companions.push(companion);
			}
		}

		this.stop = function() {
			for (i = 0; i < _companions.length; i++) {
				_companions[i].stop();
			}
			_companions.length = 0;
		};
	};

	var trimXml = function(strVastXml) {
		var nPos = strVastXml.indexOf('<');
		var strXml = strVastXml.substr(nPos === -1 ? 0 : nPos);
		nPos = strXml.lastIndexOf('>');
		if (nPos !== -1) {
			strXml = strXml.substr(0, nPos + 1);
		}
		return strXml.trim();
	};

	var parseCompanions = function(strXml) {
	    if (strXml.length === 0) {
		APN_Logger.warn(_prefix, 'parseCompanions > empty companions xml');
			return null;
	    }
	    strXml = trimXml(strXml);
	    if (strXml.substr(0,13) !== '<CompanionAds') {
		strXml = '<CompanionAds>' + strXml + '</CompanionAds>';
	    }
	    var xmlDoc = null;
	    if (typeof window.DOMParser !== 'undefined') {
		xmlDoc = (new DOMParser()).parseFromString(strXml, 'text/xml');
		if (xmlDoc.documentElement.nodeName === 'parsererror') {
			try{
				APN_Logger.error(_prefix, 'parseCompanions > Error reason = ' + xmlDoc.documentElement.childNodes[0].nodeValue);
			}
			catch(e) {}
			APN_Logger.warn(_prefix, 'parseCompanions > invalide xml structure');
		        return null;
		}
	    }
	    else if (typeof window.ActiveXObject !== 'undefined') {
		try {
			xmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');
			xmlDoc.loadXML(strXml);
			    if (xmlDoc.parseError.errorCode !== 0) {
				APN_Logger.error(_prefix, xmlDoc.parseError);
			        return null;
			    }
		}
		catch (ex) {
			APN_Logger.error(_prefix, 'parseCompanions > Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)', ex);
		        return null;
		}
	    }
	    else {
		APN_Logger.error(_prefix, 'parseCompanions > Failed to parse vast xml by window.ActiveXObject(Microsoft.XMLDOM)');
	        return null;
	    }
	    if (!xmlDoc) {
		APN_Logger.error(_prefix, 'parseCompanions > invalid xml structure');
	        return null;
	    }

	    var APN_CompanionAdsParser = __webpack_require__(44);
	    var companionsObj = APN_CompanionAdsParser.parse(xmlDoc);
	    return companionsObj;
	};

	module.exports = {
		renderCompanions: function(companionAds, options, fnCallback) {
			APN_Logger.log(_prefix, 'renderCompanions called.');
			var companions = new CompanionsHandler(companionAds, options, fnCallback);
			return companions;
		},

		stopCompanions: function(companionsObj) {
			if (companionsObj) {
				companionsObj.stop();
			}
		},

		parse: function(strCompanions) {
			return parseCompanions(strCompanions);
		}
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * URL Loader module.
	 * @module UrlLoader
	 */



	var _logger = __webpack_require__(2);

	function ajaxLoad(url, callback, timeout, options) {

	    var httpRequest;
	    var startTime = 0;
	    var duration = 0;
	    var calcDuration = false;
	    var logger = __webpack_require__(34);
	    var cacheManager = __webpack_require__(43);

	    var useWithCredentials = true;

		var debug = function(message) {
		    logger.logDebug(message, 'URL Loader');
		};

	    if (options &&  typeof options.withCredentials !== 'undefined') {
	        useWithCredentials = options.withCredentials;
	    }

	    if (window.XMLHttpRequest) { // Mozilla, Safari, ...
	        httpRequest = new XMLHttpRequest();
	    } else if (window.ActiveXObject) { // IE
	        try {
	            httpRequest = new ActiveXObject('Msxml2.XMLHTTP');
	        } catch (msxmlErr) {
	            try {
	                httpRequest = new ActiveXObject('Microsoft.XMLHTTP');
	            } catch (msErr) {}
	        }
	    }


	    if (!httpRequest) {
	        if (callback) {
	            callback.call(this, '406', ''); // request is not acceptable
	        }
	        return;
	    }

	    httpRequest.onreadystatechange = function() {
	        if (httpRequest.readyState === 4) {

	            if (httpRequest.status === 200) {
	                if (callback) {
	                    callback.call(this, undefined, httpRequest.responseText, httpRequest);
	                }
	                debug('duration: ' + duration + ', response length: ' + httpRequest.responseText.length);
	                if (calcDuration && httpRequest.responseText && httpRequest.responseText.length > 2048) {
				var nBandWidth = (httpRequest.responseText.length * 8.0 * 1000.0) / (Math.max(1.0, duration) * 1024.0);
				var intBandwidth = parseInt(nBandWidth.toString());
	                    debug('Bandwidth: ' + intBandwidth);
				try {
					cacheManager.setGenericData('anxBandwidth', intBandwidth);
					//localStorage.setItem('anxBandwidth', intBandwidth);
				}
				catch(ex) {
				}
	                }
	            } else {
	                if (httpRequest.status >= 400 && httpRequest.status < 600) {
	                    if (callback) {
	                        callback.call(this, httpRequest.status, '', httpRequest);
	                    }
	                }
	            }

	        }
	        else if (httpRequest.readyState === 2) {
			startTime = (new Date()).getTime();
	        }
	        else if (httpRequest.readyState === 3) {
			if (startTime > 0) {
				calcDuration = true;
				duration = (new Date()).getTime() - startTime;
			}
	        }
	    };

	    httpRequest.onerror = function() {
	        //if there is an error, it might be becase we are using withCredentials
	        //let's try one more time without that flag set.
	        //this won't send cookies, but it's better than no ad at all
	        if(useWithCredentials) {
	            var newOpts = options ? options : {};
	            newOpts.withCredentials = false;
	            ajaxLoad(url, callback, timeout, newOpts);
	        } else {
	            if (callback) {
	                var errorStatus = httpRequest.status === 0 ? '404' : httpRequest.status.toString();
	                callback.call(this, errorStatus, '', httpRequest);
	            }
	        }
	    };


	    httpRequest.ontimeout = function() {
	        //_logger.log('Server Timeout');
	        if (callback) {
	            callback.call(this, 'Timeout', '', httpRequest);
	        }
	    };

	    httpRequest.open('GET', url);
	    if (timeout) {
	        httpRequest.timeout = timeout;
	    }
	    httpRequest.withCredentials = useWithCredentials;
	    startTime = 0;
	    httpRequest.send();
	}

	function createTrackingPixel(url, eventName) {
	    _logger.log('Logging Event: ' + eventName + ' at url:' + url);
	    new Image(1, 1).src = url;

	}



	module.exports = {
	    /** Load a URL.
	     * @param {string} url - Target URL to load.
	     * @param {Function} callback - Function to call back once loading has either completed or encountered an error.
	     * @param {number} timeout - Timeout (in ms) to use for this URL Load.
	     */
	    load: function(url, callback, timeout) {
	        ajaxLoad(url, callback, timeout, {withCredentials:true});
	    },


	    /** Track Pixel.
	     * @param {String} url - Url of traking pixel to track.
	     * @param {String} eventName - Name of event being tracked.
	     */
	    trackPixel: function(url, eventName) {
	        createTrackingPixel(url, eventName);
	    }
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Cache Manager module.
	 * @module CacheManager
	 */

	var utils = __webpack_require__(34);


	var prefix = "Cache Manager";

	//////////////////////////////////////////////////////////////////////
	// CONSTANTS
	var TTL_DEFAULT_MIN = 2 * 20; // 2 hours expressed in minutes
	var MSEC_PER_MINUTE = 60 * 1000;
	var TTL_DEFAULT_MSEC = TTL_DEFAULT_MIN * MSEC_PER_MINUTE; // expressed in seconds

	//////////////////////////////////////////////////////////////////////
	// VARIABLES
	var _ttlMsec = TTL_DEFAULT_MSEC;

	var _genericDataStotagePrefix = "___appnexus_video_cachemanager_generic_data___";
	var adTokenStorageKey = "___appnexus_video_cachemanager_ad_token___";

	var backupInMemoryStorageObj = {};

	//storage types:
	//0 - localStorage
	//1 - cookie
	//2 - in memory
	var storageTypeToUse;

	if (isLocalStorageSupported()) {
	    storageTypeToUse = 0;
	} else {
	    if (isCookieStorageSupported()) {
	        storageTypeToUse = 1;
	    } else {
	        storageTypeToUse = 2;
	    }

	}

	utils.debug("Using Cache Method " + storageTypeToUse, prefix);

	//docCookies library from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
	var docCookies = {
	    getItem: function(sKey) {
	        if (!sKey) {
	            return null;
	        }
	        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	    },
	    setItem: function(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	            return false;
	        }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    },
	    removeItem: function(sKey, sPath, sDomain) {
	        if (!this.hasItem(sKey)) {
	            return false;
	        }
	        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	        return true;
	    },
	    hasItem: function(sKey) {
	        if (!sKey) {
	            return false;
	        }
	        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
	    },
	    keys: function() {
	        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	        }
	        return aKeys;
	    }
	};

	//write object to whatever storage method we are using, with specified key
	function writeToStorage(key, obj, dontExpire) {
	    switch (storageTypeToUse) {
	        case 0:
	            writeToLocalStorage(key, obj);
	            break;
	        case 1:
	            writeToCookieStorage(key, obj, dontExpire);
	            break;
	        default:
	        case 2:
	            writeToInMemoryStorage(key, obj);
	            break;
	    }
	}

	//get a object from the storage method we are using, that has the specified key
	function getFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            return getFromLocalStorage(key);
	        case 1:
	            return getFromCookieStorage(key);
	        default:
	        case 2:
	            return getFromInMemoryStorage(key);
	    }

	}

	//delete an object in the storaege method we are using,
	function deleteFromStorage(key) {
	    switch (storageTypeToUse) {
	        case 0:
	            deleteFromLocalStorage(key);
	            break;
	        case 1:
	            deleteFromCookieStorage(key);
	            break;
	        default:
	        case 2:
	            deleteFromInMemoryStorage(key);
	            break;
	    }
	}

	function writeToLocalStorage(key, obj) {
	    if (localStorage) {
	        localStorage.setItem(key, obj);
	    }
	}

	function getFromLocalStorage(key) {
	    if (localStorage) {
	        return localStorage.getItem(key);
	    }
	}

	function deleteFromLocalStorage(key) {
	    if (localStorage) {
	        localStorage.removeItem(key);
	    }
	}

	function writeToCookieStorage(key, obj, dontExpire) {
	    docCookies.setItem(key, obj, (dontExpire ? Infinity : new Date((Date.now() + _ttlMsec)).toUTCString()));
	}

	function getFromCookieStorage(key) {
	    return docCookies.getItem(key);
	}

	function deleteFromCookieStorage(key) {
	    docCookies.removeItem(key);
	}

	function writeToInMemoryStorage(key, obj) {
	    if (backupInMemoryStorageObj) {
	        backupInMemoryStorageObj[key] = obj;
	    }
	}

	function getFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        return backupInMemoryStorageObj[key];
	    }
	}

	function deleteFromInMemoryStorage(key) {
	    if (backupInMemoryStorageObj) {
	        delete backupInMemoryStorageObj[key];
	    }
	}

	//return true if localStorage is supported, false otherwise
	function isLocalStorageSupported() {

	    //if the browser is blocking 3rd party storage, accessing localStorage might throw an exception (VID-2089)
	    try {
	        if (localStorage) {
	            var testValue = "apntestls" + Math.random();
	            try {
	                //try writing and reading something
	                localStorage.setItem(testValue, testValue);
	                localStorage.removeItem(testValue);
	                return true;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}


	//return true if localStorage is supported, false otherwise
	function isCookieStorageSupported() {
	    try {
	        if (document && document.cookie) {
	            var testValue = "apntestcookie" + Math.random();
	            try {
	                docCookies.setItem(testValue, testValue, Infinity);
	                var cookieWorked = docCookies.hasItem(testValue) && (docCookies.getItem(testValue) === testValue);
	                docCookies.removeItem(testValue);
	                return cookieWorked;
	            } catch (e) {}
	        }
	    } catch (e) {}

	    return false;
	}

	// caches the adObject - this will overwrite any existing cached ad
	// the cache will also be timestamp with the current time in milliseconds
	// for calculating time to live
	function addAdToCache(adObject, adId) {
	    var cacheObject = {};
	    cacheObject.timestamp = new Date().getTime();
	    cacheObject.ad = adObject;

	    try {
	        writeToStorage(adId, JSON.stringify(cacheObject));
	    } catch (e) {

	    }
	}

	// returns the ad stored in the cache if the cache has not expired
	// returns null if the cache has expired (based on the configured time-to-live)
	// OR if there is no ad in the cache
	// NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function getCachedAd(adId) {
	    var ts = new Date().getTime();

	    var retrievedCacheItem;

	    try {
	        var itemFromCache = getFromStorage(adId);
	        retrievedCacheItem = (itemFromCache && JSON.parse(itemFromCache));
	        // clear the cache, setting it back to default (or empty)
	        deleteFromStorage(adId);
	    } catch (e) {

	    }

	    // check to see if the ad cache exists and if the cache has not expired
	    if (retrievedCacheItem && retrievedCacheItem.timestamp && retrievedCacheItem.timestamp > 0) {
	        var cacheAge = ts - retrievedCacheItem.timestamp;
	        //if we have expired, return nothing
	        if (cacheAge <= _ttlMsec) {
	            return retrievedCacheItem.ad;
	        }
	    }

	    return null;
	}

	// clear the ad cache by creating a default ad cache object
	//NOTE:  It is not clear yet what to do with placement id - ignore it for now
	function clearAdCache(adId) {
	    try {
	        deleteFromStorage(adId);
	    } catch (e) {

	    }
	}

	// converts the time-to-live argument from minutes to milliseconds
	// to make it easier to compare timestamps
	function setTTL(ttlMinutes) {
	    _ttlMsec = ttlMinutes * MSEC_PER_MINUTE;
	}

	// gets the current token from the cache
	function getAdToken() {
	    var tokenToReturn;
	    var tokenFromCache;
	    tokenFromCache = getFromStorage(adTokenStorageKey);

	    if (tokenFromCache) {
	        tokenToReturn = parseInt(tokenFromCache);
	    } else {
	        //no token found, use default
	        tokenToReturn = 0;
	    }

	    //store new token in localStorage or local memory
	    writeToStorage(adTokenStorageKey, (tokenToReturn += 1), true);


	    return tokenToReturn;
	}

	function prependAppnexusIdToKey(incomingKey) {
	    return "apn_" + incomingKey;
	}

	module.exports = {

	    /**
	     * Set generic data in cache
	     * @param (string) key = key under which to store data
	     * @param (object) value = value to store.
	     * @return (boolean) true if value was succesfully stored, false otherwise
	     */
	    setGenericData: function(key, value) {
	        if (typeof key !== "undefined" && typeof value !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            try {
	                writeToStorage(key, value);
	                return true;
	            } catch (e) {

	            }
	        }
	        return false;
	    },

	    /**
	     * Get generic data from cache
	     * @param (string) key = key to retrive from data
	     * @return (object) object contaninig data from cache with given key, undefined if key not found.
	     */
	    getGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            return getFromStorage(key);
	        }
	    },

	    /**
	     * Delete generic data from cache
	     * @param (string) key = key to delete from cache
	     */
	    deleteGenericData: function(key) {
	        if (typeof key !== "undefined") {
	            key = _genericDataStotagePrefix + key;
	            deleteFromStorage(key);
	        }
	    },

	    /**
	     * Force usage of a specifc cache storage method, This is an optional function, if it is not called we will attempt to use
	     * localStorage, with a in-memory object as backup. 0= use localStorage.  1 = use cookie.  2 = use in-memory storage
	     */
	    forceStorageMethod: function(storageType) {
	        storageTypeToUse = storageType;
	        utils.debug("Forced usage of cache method " + storageTypeToUse, prefix);
	    },

	    /**
	     * add the ad data to the cache
	     * @param (object) adObject = JSON object describing the contents of the VAST tag after it has been parsed and unwrapped
	     *      - this will become the input into the ad rendering logic
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    addAd: function(adObject, adId) {
	        if (adObject) {
	            addAdToCache(adObject, prependAppnexusIdToKey(adId));
	        }
	    },

	    /** Retrieves ad from the ad cache.  If none exists or if the cache has expired, null is returned
	     * @param (integer) adId = unique identifier for a specific ad cache
	     * @return (object) object containing results of VAST parsing if ad is cached; otherwise return null
	     */
	    getAd: function(adId) {
	        return getCachedAd(prependAppnexusIdToKey(adId));
	    },

	    /**
	     * Clears the cache, removing any cached ad
	     * @param (integer) adId = unique identifier for a specific ad cache
	     */
	    clearAd: function(adId) {
	        clearAdCache(prependAppnexusIdToKey(adId));
	    },

	    /** Sets the time-to-live settings for the ad cache
	     * @param (number) timeToLiveMinutes = specifies how long (in minutes) ad ad may remain in the cache before being discarded
	     */
	    setTimeToLive: function(timeToLiveMinutes) {
	        setTTL(timeToLiveMinutes);
	    },

	    /**
	     * Returns a token unique to this page which is used to identify an ad request.
	     */
	    getNextAdToken: function() {
	        // Remove unnecessary additional characters.
	        // return chars.substring(0, len);
	        return getAdToken();
	    }
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	var CompanionAdsParser = {

	    parse: function (xmlDoc) {
		var companionAdsDest = {companions: []};

		var VastXMLParserHelper = function () {
		    this.getSubNodes = function (node, subNodeName) {
		        var nodes = node.getElementsByTagName(subNodeName);
		        if (nodes.length > 0) {
		            return nodes;
		        }
		        return null;
		    };

		    this.getSubNode = function (node, subNodeName, index) {
		        if (!index) {
		            index = 0;
		        }
		        var nodes = node.getElementsByTagName(subNodeName);
		        if (nodes.length > index) {
		            return nodes[index];
		        }
		        return null;
		    };

		    this.getNodeValue = function (node) {
		        if (node.childNodes.length === 0) {
		            return '';
		        }
		        var val = node.childNodes[0].nodeValue;
		        return val.trim();
		    };

		    this.getNodeValues = function (node) {
		        if (node.childNodes.length === 0) {
		            return '';
		        }
		        var wholeVal = '';
		        for (var i = 0; i < node.childNodes.length; i++) {
		            var val = node.childNodes[i].nodeValue;
		            wholeVal += val;
		        }
		        return wholeVal.trim();
		    };

		    this.getNodeAttributeValue = function (node, attributeName) {
		        var val = node.getAttribute(attributeName);
		        if (val === null) {
		            val = '';
		        }
		        return val;
		    };

		    this.getNodeAttributeNumberValue = function (node, attributeName, defaultValue) {
		        if (!defaultValue) {
		            defaultValue = 0;
		        }
		        var answer = defaultValue;
		        var val = this.getNodeAttributeValue(node, attributeName);

		        if (val.length > 0) {
		            if (val.indexOf('.') >= 0) {
		                answer = parseFloat(val);
		            }
		            else {
		                answer = parseInt(val);
		            }
		        }

		        return answer;
		    };

		    this.getNodeAttributeBooleanValue = function (node, attributeName, defaultValue) {
		        if (!defaultValue) {
		            defaultValue = false;
		        }
		        var answer = defaultValue;
		        var val = this.getNodeAttributeValue(node, attributeName);

		        if (val.length > 0) {
		            var char = val.toLowerCase().charAt(0);
		            answer = (char === 't');
		        }

		        return answer;
		    };

		    this.getSubNodeValue = function (parentNode, subNodeName, defaultValue) {
		        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
		        var subnode = this.getSubNode(parentNode, subNodeName);
		        if (subnode !== null) {
		            return this.getNodeValue(subnode);
		        }
		        return defaultValue;
		    };

		    this.getSubNodeWholeValue = function (parentNode, subNodeName, defaultValue) {
		        defaultValue = (typeof defaultValue === 'undefined') ? '' : defaultValue;
		        var subnode = this.getSubNode(parentNode, subNodeName);
		        if (subnode !== null) {
		            return this.getNodeValues(subnode);
		        }
		        return defaultValue;
		    };

		    this.getSubNodeBooleanValue = function (parentNode, subNodeName, defaultValue) {
		        defaultValue = (typeof defaultValue === 'undefined') ? 'false' : defaultValue;

		        var value = this.getSubNodeValue(parentNode, subNodeName);
		        if (value.length > 0 && value.toLowerCase().charAt(0) === 't') {
		            return true;
		        }
		        if (value.length > 0 && value.toLowerCase().charAt(0) === 'f') {
		            return false;
		        }
		        return defaultValue;
		    };
		};
		var helper = new VastXMLParserHelper();

		var companionAdsNode = helper.getSubNode(xmlDoc, 'CompanionAds');
		var req = helper.getNodeAttributeValue(companionAdsNode, 'required');
		if (req && req.length > 0) {
			companionAdsDest.required = req;
		}

	        var nodes = helper.getSubNodes(companionAdsNode, 'Companion');
	        if (nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
			//var companion = JSON.parse(JSON.stringify(APN_Companion));
			var companion = {};

			// required attributes
			var width = helper.getNodeAttributeNumberValue(node, 'width', -1);
			var height = helper.getNodeAttributeNumberValue(node, 'height', -1);
			if (width <= 0 || height <= 0) {
				continue;
			}
			companion.width = width;
			companion.height = height;

			// optional attributes and subnodes
			var val = helper.getNodeAttributeValue(node, 'id');
			if (val) {
				companion.id = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'assetWidth', -1);
			if (val > 0) {
				companion.assetWidth = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'assetHeight', -1);
			if (val > 0) {
				companion.assetHeight = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'expandedWidth', -1);
			if (val > 0) {
				companion.expandedWidth = val;
			}

			val = helper.getNodeAttributeNumberValue(node, 'expandedHeight', -1);
			if (val > 0) {
				companion.expandedHeight = val;
			}

			val = helper.getNodeAttributeValue(node, 'apiFramework');
			if (val) {
				companion.apiFramework = val;
			}

			val = helper.getNodeAttributeValue(node, 'adSlotID');
			if (val) {
				companion.adSlotID = val;
			}

			val = helper.getNodeAttributeValue(node, 'required');
			if (val) {
				companion.required = val;
			}

			val = helper.getSubNodeValue(node, 'AltText');
			if (val) {
				companion.AltText = val;
			}

			val = helper.getSubNodeValue(node, 'AdParameters');
			if (val) {
				companion.AdParameters = val;
			}

			var resource = helper.getSubNode(node, 'StaticResource');
			if (resource) {
				val = helper.getNodeAttributeValue(resource, 'creativeType');
				if (val) {
					// validate capability
					var flashOnlyType = val === 'video/x-flv' || val === 'video/x-f4v' || val === 'video/f4v' || val === 'application/x-shockwave-flash';
					var isMobile = false;
					if (/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
						isMobile = true;
					}
					if (isMobile && flashOnlyType) {
						// ignore this companion
						continue;
					}

					var staticResource = {type: val};
					val = helper.getNodeValues(resource);
					if (val) {
						staticResource.src = val;
					companion.StaticResource = staticResource;
					}
				}
			}

			val = helper.getSubNodeWholeValue(node, 'IFrameResource');
			if (val) {
				companion.IFrameResource = val;
			}

			val = helper.getSubNodeWholeValue(node, 'HTMLResource');
			if (val) {
				companion.HTMLResource = val;
			}

			val = helper.getSubNodeValue(node, 'CompanionClickThrough');
			if (val) {
				companion.CompanionClickThrough = val;
			}

			var j;
			var trackingNode;
			var url;
	                var clickTrackinEvents = helper.getSubNodes(node, 'CompanionClickTracking');
	                if (clickTrackinEvents) {
				companion.CompanionClickTracking = [];
				for (j = 0; j < clickTrackinEvents.length; j++) {
					trackingNode = clickTrackinEvents[j];
				url = helper.getNodeValues(trackingNode);
				if (url) {
					companion.CompanionClickTracking.push(url);
				}
				}
	                }

	                var trackinEvents = helper.getSubNodes(node, 'Tracking');
	                if (trackinEvents) {
				companion.TrackingEvents = [];
				for (j = 0; j < trackinEvents.length; j++) {
					trackingNode = trackinEvents[j];
				var event = helper.getNodeAttributeValue(trackingNode, 'event');
				url = helper.getNodeValues(trackingNode);
				if (event && url) {
					companion.TrackingEvents.push({eventType: event, url: url});
				}
				}
	                }

	                companionAdsDest.companions.push(companion);
	            }
	        }
	        return companionAdsDest;
	    }
	};

	module.exports = CompanionAdsParser;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * DefaultOptions : default options for Outstream - define default option for Outstream which can be overrided if it deosn't exists
	 * @type {{alignment: string, autoInitialSize: boolean, initialPlayback: string, initialAudio: string, playOnMouseover: boolean, audioOnMouseover: boolean, playVideoVisibleThreshold: number, enableExplicitPause: boolean, skippable: {enabled: boolean, videoThreshold: number, videoOffset: number, skipLocation: string, skipText: string, skipButtonText: string}, adText: string, showMute: boolean, showVolume: boolean, showProgressBar: boolean, allowFullscreen: boolean, expandTime: number, enableInlineVideoForIos: boolean, disableCollapse: boolean, topDividerColor: string, bottomDividerColor: string, topDividerWidth: number, bottomDividerWidth: number, delayExpandUntilVPAIDInit: boolean, delayExpandUntilVPAIDImpression: boolean, delayStartUntilNotified: boolean, nonViewableBehavior: string, waterfallTimeout: number, waterfallSteps: number, maxWaterfallIframes: number, adAttempt: number, fixedSizePlayer: boolean, sideStream: {enabled: boolean, position: string, xOffset: number, yOffset: number, space: string}, sideStreamObject: {}}}
	 */
	module.exports = {
	    "alignment": "center",
	    "autoInitialSize": false,
	    "initialPlayback": "auto",
	    "initialAudio": "off",
	    "playOnMouseover": false,
	    "audioOnMouseover": true,
	    "playVideoVisibleThreshold": 50,
	    "enableExplicitPause": true,
	    "skippable": {
	        "enabled": true,
	        "allowOverride": false,
	        "videoThreshold": 15,
	        "videoOffset": 5,
	        "skipLocation": "top-left",
	        "skipText": "Video can be skipped in %%TIME%% seconds",
	        "skipButtonText": "SKIP"
	    },
	    "adText": "Ad",
	    "showMute": true,
	    "showVolume": true,
	    "showProgressBar": false,
	    "allowFullscreen": true,
	    "expandTime": 1000,
	    "enableInlineVideoForIos": true,
	    "disableCollapse": false,
	    "topDividerColor": "#606060",
	    "bottomDividerColor": "#606060",
	    "topDividerWidth": 1,
	    "bottomDividerWidth": 1,
	    "delayExpandUntilVPAIDInit": true,
	    "delayExpandUntilVPAIDImpression": false,
	    "delayStartUntilNotified": false,
	    "nonViewableBehavior": "mute",
	    "waterfallTimeout": 15000,
	    "waterfallSteps": -1,
	    "maxWaterfallIframes": 6,
	    "adAttempt": 0,
	    "fixedSizePlayer": false,
	    "sideStream": {
	        "enabled": false,
	        "position": "bottom-right",
	        "xOffset": 0,
	        "yOffset": 0,
	        "space": "empty"
	    },
	    "sideStreamObject": {},
	    "enableNativeInline": false,
	    "androidDSOverride": false,
	    "topMostViewableCheck": {
	        "enabled": true,
	        "checkVerticalOnly": true,
	        "rateOfBeacons": 10
	    },
	    "intervals" : {
	        "playAndPause":250,
	        "focusAndBlur":500
	    },
	    "cbNotification": function() {},
	    "parentIframeIsModal": false,
	    "playerContextId":"anoutstream",
	    "data":{
	        "skipOffset": "",
	        "durationMsec": null,
	        "skipOffsetMsec": null,
	        "isVastVideoSkippable": false,
	        "vastProgressEvent": {},
	        "vastDurationMsec": null
	    },
	    "test": function() {}
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var Utils = __webpack_require__(47);
	var APN_Logger = __webpack_require__(2);
	var AdHandler = __webpack_require__(28);
	var SideStream = __webpack_require__(48);
	var ViewableDetector = __webpack_require__(49);
	var PlayerManager_object = __webpack_require__(3);
	var AutoplayHandler = __webpack_require__(3).autoplayHandler;
	var debug = function (message) {
	    APN_Logger.debug("[Outstream_Initialize]", message);
	};


	/**
	 * Initialize : initialize routine to work with AdHandler
	 * @param outstreamSelf
	 * @returns {{start: "start", init: "init", setInitialVariable: "setInitialVariable", getTargetWindow: "getTargetWindow", checkTopWindow: "checkTopWindow"}}
	 */
	module.exports = function (outstreamSelf) {
	    return {
	        "start": function () {


	            /**
	             * set animation speed
	             */
	            var setAnimation = function () {

	                if (outstreamSelf.isVideoRendered === true) {
	                    return;
	                }
	                debug("video renderer is about to start");

	                var convertToSeconds = function (ms) {
	                    if (ms < 0) {
	                        return 0;
	                    }
	                    return ms / 1000;
	                };

	                outstreamSelf.animationSpeed = convertToSeconds(outstreamSelf.options.expandTime);
	                outstreamSelf.animationSpeed = (outstreamSelf.animationSpeed <= 0) ? 0.001 : outstreamSelf.animationSpeed;//because if it's under zero, transitionEnd event is not reliable
	                outstreamSelf.targetElement.style.overflow = "hidden";
	                outstreamSelf.targetElement.style.height = "0.1px";//required for detecting a timing to start expanding


	                if (Utils.isAndroid()) {
	                    //for android4
	                    outstreamSelf.targetElement.style.webkitTransition = "height " + outstreamSelf.animationSpeed + "s ease";
	                } else {
	                    //for most of modern browser
	                    outstreamSelf.targetElement.style.transition = "height " + outstreamSelf.animationSpeed + "s ease";
	                }


	            };
	            /**
	             * all object should be prepared before starting to detect right position for expanding
	             */
	            var setWindowEvents = function () {
	                debug("setWindowEvents");
	                debug("start out-stream-ad");

	                setAnimation();


	                if (Utils.isAndroid()) {
	                    outstreamSelf.rWindowForPublisher.addEventListener("touchmove", outstreamSelf.detectAndPlay);
	                    outstreamSelf.intervalIdForDetectAndPlay = setInterval(outstreamSelf.detectAndPlay, outstreamSelf.options.intervals.playAndPause);//if it's in cross domain iframe environment, AST renderer will dispatch an event of top frame by parentIframeGeometryUpdate method
	                } else {
	                    outstreamSelf.intervalIdForDetectAndPlay = setInterval(outstreamSelf.detectAndPlay, outstreamSelf.options.intervals.playAndPause);//if it's in cross domain iframe environment, AST renderer will dispatch an event of top frame by parentIframeGeometryUpdate method
	                }

	                if (Utils.isMobile()) {
	                    outstreamSelf.rWindowForPublisher.addEventListener("resize", outstreamSelf.fnRotationChange);
	                }


	                var isInIframe = (outstreamSelf.rWindowForPublisher === window.self) ? false : true;
	                isInIframe = !outstreamSelf.isWindowTopAccessible ? true : isInIframe;//override isInIframe

	                if (isInIframe) {
	                    //new pause / resume by page view ability API
	                    var hidden, visibilityChange;
	                    if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support
	                        hidden = "hidden";
	                        visibilityChange = "visibilitychange";
	                    } else if (typeof document.mozHidden !== "undefined") {
	                        hidden = "mozHidden";
	                        visibilityChange = "mozvisibilitychange";
	                    } else if (typeof document.msHidden !== "undefined") {
	                        hidden = "msHidden";
	                        visibilityChange = "msvisibilitychange";
	                    } else if (typeof document.webkitHidden !== "undefined") {
	                        hidden = "webkitHidden";
	                        visibilityChange = "webkitvisibilitychange";
	                    }
	                    var handleVisibilityChange = function () {
	                        if (document[hidden]) {
	                            outstreamSelf.listenerBlur();
	                        } else {
	                            outstreamSelf.listenerFocus();
	                        }
	                    };
	                    document.addEventListener("visibilitychange", handleVisibilityChange, false);
	                } else {

	                    var checkFocusFn = function () {
	                        if (document.hasFocus() && outstreamSelf.hasFocus === false) {
	                            outstreamSelf.listenerFocus();
	                            outstreamSelf.hasFocus = true;

	                        } else if (!document.hasFocus() && outstreamSelf.hasFocus === true) {
	                            outstreamSelf.listenerBlur();
	                            outstreamSelf.hasFocus = false;
	                        }
	                    };
	                    outstreamSelf.triggerCheckFocus = outstreamSelf.rWindow.setInterval(checkFocusFn, outstreamSelf.options.intervals.focusAndBlur);
	                }
	            };
	            var initAdHandler = function () {
	                var cbAdunits = {
	                    "cbWhenDestroy": outstreamSelf.terminateAll,
	                    "cbWhenReady": function (VideoFramework) {
	                        //overriding object by instiated video framework
	                        outstreamSelf.playerManager = VideoFramework;
	                        var adVideoPlayer = VideoFramework.adVideoPlayer;

	                        if (VideoFramework.options.vpaid === false) {
	                            if (adVideoPlayer.type === "application/x-shockwave-flash") {
	                                outstreamSelf.videoPlayerObjectElement = adVideoPlayer;
	                                outstreamSelf.isFlash = true;
	                            } else {
	                                outstreamSelf.videoPlayerObjectElement = adVideoPlayer.player().el();
	                            }
	                        }

	                        if (adVideoPlayer.type !== "application/x-shockwave-flash" && outstreamSelf.playerManager.adVideoPlayer.on) {
	                            //catching fullscreen event
	                            outstreamSelf.playerManager.adVideoPlayer.on("fullscreenchange", outstreamSelf.handleFullscreen);
	                        }

	                        outstreamSelf.videoIsreadyToPlay = true;
	                        if (outstreamSelf.firstAdAttempted) {
	                            outstreamSelf.cleanupPreviousFlashElement();
	                        }
	                        if (!Utils.isAndroid()) {
	                            if (outstreamSelf.isWindowTopAccessible) {
	                                outstreamSelf.detectAndPlay();
	                            }
	                        }


	                    },
	                    "cbWhenImpression": function () {
	                        outstreamSelf.options.impressionSent = true;
	                    },
	                    "cbWhenWaterfall": function (waterfallStatusObj) {
	                        outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.waterfall, false, waterfallStatusObj);
	                    },
	                    "cbRenderVideo": function (cbAdunits, _options, _cbTimer) {
	                        //common part to load video player
	                        if (outstreamSelf.firstAdAttempted) {
	                            var attempt = outstreamSelf.options.adAttempt;
	                            outstreamSelf.playerManager = Object.create(PlayerManager_object);

	                            outstreamSelf.videoIsreadyToPlay = false;
	                            _options.isExpanded = outstreamSelf.isExpanded;
	                            // FirstAd already played the consecutive ads should play in a autoplay fashion.
	                            if (outstreamSelf.isExpanded && (_options.initialPlayback === "mouseover" || _options.initialPlayback === "click")) {
	                                _options.initialPlayback = "auto";
	                            }
	                            outstreamSelf.options = outstreamSelf.playerManager.init(_options);
	                            outstreamSelf.options.firstAdAttempted = true;
	                            outstreamSelf.options.adAttempt = ++attempt;
	                            outstreamSelf.cleanupTargetElement();
	                        }
	                        if (_cbTimer && outstreamSelf.isExpanded) {
	                            _cbTimer();
	                        }
	                        outstreamSelf.firstAdAttempted = true;
	                        outstreamSelf.playerManager.buildPlayer(cbAdunits, outstreamSelf.options);

	                        //initialize SideStream
	                        outstreamSelf.sideStream = new SideStream(outstreamSelf, outstreamSelf.playerManager);

	                        outstreamSelf.playerManager.options.sideStreamObject = outstreamSelf.sideStream;//injecting sideStream object
	                    }
	                };
	                AdHandler(outstreamSelf.targetElement, outstreamSelf.options, cbAdunits);
	            };

	            initAdHandler();
	            setWindowEvents();
	        },
	        "init": function (_options) {
	            _options.expandable = true;//to notify core video this will invoke expand / colapse event

	            //ES6 and BABEL test
	            //this.ES6_PROMISE_TEST = require("babel!./moduleTest.js6");
	            //outstreamSelf.ES6_PROMISE_TEST();


	            //initialize playerManager with options extended on adUnit level
	            //uses DEFAULT_OPTIONS_FOR_OUTSTREAM to create defaults for all outstream publisher options
	            outstreamSelf.options = outstreamSelf.playerManager.init(outstreamSelf.playerManager.ExtendDefaultOption(outstreamSelf.DEFAULT_OPTIONS_FOR_OUTSTREAM, _options));

	            outstreamSelf.originalSize.width = outstreamSelf.options.width;
	            outstreamSelf.originalSize.height = outstreamSelf.options.height;

	            outstreamSelf.disableCollapse = outstreamSelf.options.disableCollapse;
	            outstreamSelf.targetElementId = outstreamSelf.options.targetId;
	            outstreamSelf.ASTadId = outstreamSelf.options.ASTadId;
	            //if publisher option `delayStartUntilNotified` is true, we are not ready to play outstream until we get the ok from outside
	            //if its false, isOkToPlayFromPublisher is true, so no extra delay required
	            outstreamSelf.isOkToPlayFromPublisher = !outstreamSelf.options.delayStartUntilNotified;
	            outstreamSelf.isWindowTopAccessible = outstreamSelf.checkTopWindow();
	            outstreamSelf.rWindowForPublisher = outstreamSelf.getTargetWindow();

	            //set isModal falg by options
	            outstreamSelf.parentIframeIsModal = (outstreamSelf.options && outstreamSelf.options.parentIframeIsModal && outstreamSelf.options.parentIframeIsModal === true) ? true : false;

	            outstreamSelf.viewableDetector = ViewableDetector;

	            if (!outstreamSelf.setInitialVariable()) {
	                debug("failed setInitialVariable");
	                return;//TODO should throw an error at this point
	            }


	            if (AutoplayHandler.isMobile()) {
	                //initalize autoplay handler to register starting point of adunit

	                var paramForAutoplayHandler = {
	                    "targetElementId": outstreamSelf.targetElementId,
	                    "windowForPublisher":outstreamSelf.rWindowForPublisher,
	                    "maxWaterfallIframes":outstreamSelf.options.maxWaterfallIframes,
	                    "waterfallSteps":outstreamSelf.options.waterfallSteps,
	                    "initialPlayback":outstreamSelf.options.initialPlayback,
	                    "initialAudio":outstreamSelf.options.initialAudio,
	                    "automatedTestingOnlyAndroidSkipTouchStart":outstreamSelf.options.automatedTestingOnlyAndroidSkipTouchStart,
	                    "androidDSOverride":outstreamSelf.options.androidDSOverride,
	                    "callbackAdUnitEntryPoint": function (shouldOverrideAudioToOff, shouldOverrideAutoplayToOff) {
	                        if (shouldOverrideAudioToOff === true) {
	                            outstreamSelf.options.initialAudio = "off";
	                        }
	                        if (shouldOverrideAutoplayToOff === true) {
	                            outstreamSelf.options.initialPlayback = "click";
	                        }
	                        outstreamSelf.start();
	                    },
	                    "callbackPatchForIOSChrome": function () {
	                        //this is required for iOS-Chrome 53 which has an bug not dispatching "loadedMetaData" event from generic video element
	                        if (outstreamSelf.doneUserActionForInitiateOutstream === false) {
	                            outstreamSelf.playerManager.adVideoPlayer.one("loadedmetadata", function () {
	                                outstreamSelf.doneUserActionForInitiateOutstream = true;
	                                debug("doneUserActionForInitiateOutstream by touchstart event for Chrome on iOS");
	                            });
	                            //this is only for previous version of Chrome (before Chrome 54, iOS10.1.x) which doesn't dispatch "loadedmetadata" event from html5 video element
	                            if (outstreamSelf.videoIsreadyToPlay === false) {//if video is already ready to play (caught loadedmetadata event) then not invoke load() any more
	                                outstreamSelf.playerManager.load();//forcing load and dispatch "loadedmetadata" event to Outstream
	                                debug("forcing load a video to dispatch loadedmetadata event for Chrome on iOS");
	                            }
	                        }
	                    }
	                };

	                AutoplayHandler.initialize(paramForAutoplayHandler);//initialize

	            } else {
	                outstreamSelf.start();
	            }


	        },
	        "setInitialVariable": function () {
	            if (outstreamSelf.targetElementId && typeof outstreamSelf.targetElementId === "string") {
	                var publisherDiv = document.getElementById(outstreamSelf.targetElementId);

	                if (!publisherDiv) {
	                    outstreamSelf.terminateAll(true);
	                    return false;
	                } else {
	                    outstreamSelf.targetElementId = outstreamSelf.targetElementId + "_apn_expandable_" + new Date().getTime() + Math.floor(Math.random() * 10000);
	                    outstreamSelf.targetElement = document.createElement("div");
	                    outstreamSelf.targetElement.id = outstreamSelf.targetElementId;
	                    outstreamSelf.targetElement.style.cssText = "margin: 0;padding: 0;border: 0;font-size: 100%;font: inherit;vertical-align: baseline;";
	                    publisherDiv.appendChild(outstreamSelf.targetElement);
	                }
	            } else {
	                outstreamSelf.terminateAll(true);
	                return false;
	            }

	            //reset margin after rendering document
	            //I'm not sure why we were setting the margin of the main page
	            //body... we should never be doing this.  Removing this code
	            //might cause regression issues, but I'd rather remove it and
	            //deal with that than have this behavior continue.  (-jweiss 12/2/2015)
	            //outstreamSelf.rWindow.document.body.style.margin = "0px";

	            if (outstreamSelf.options.alignment && outstreamSelf.options.alignment !== undefined) {
	                outstreamSelf.targetElement.style.textAlign = outstreamSelf.options.alignment;
	            }

	            return true;

	        },
	        "getTargetWindow": function () {
	            return outstreamSelf.isWindowTopAccessible ? top.window : window.self;
	        },
	        "checkTopWindow": function () {
	            //check if top.window is accessible
	            var result = true;

	            try {
	                var destWindow = top.window;
	                var checkInnerHeight = (destWindow.innerHeight || ((destWindow.documentElement) ? destWindow.documentElement.clientHeight : destWindow.document.documentElement.clientHeight));
	                var fnTest = function () {
	                };
	                destWindow.addEventListener("scroll", fnTest);
	                destWindow.removeEventListener("scroll", fnTest);
	                if (!destWindow || typeof destWindow !== "object" || typeof destWindow.addEventListener !== "function" || typeof checkInnerHeight !== "number") {
	                    result = false;
	                }
	            } catch (ex) {
	                result = false;
	            }

	            return result;

	        },
	    };
	};












/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "Outstream_Utils";
	var APN_Logger = __webpack_require__(2);
	// var debug = function (message) {
	//     APN_Logger.verbose(message, prefixOfLog);
	// };
	var error = function (message) {
	    APN_Logger.error(message, prefixOfLog);
	};
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };




	var isMobile = function () {
	    var index = navigator.appVersion.indexOf("Mobile");
	    var indexForAndroid = navigator.appVersion.indexOf("Android");
	    return (index > -1) || (indexForAndroid > -1);
	};

	var isAndroid = function () {
	    return (/android/i.test(navigator.userAgent.toLowerCase()));
	};

	var isChrome = function () {
	    return (navigator.userAgent.indexOf("Chrome") > -1);
	};

	var isFullScreen = function (playerManager) {

	    if (playerManager.isFullscreen) {
	        return true;
	    }

	    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
	        return (!window.screenTop && !window.screenY);
	    } else {
	        return false;
	    }
	};


	var isValidNumberForHTML = function (str) {
	    if (typeof(str) === "number") {
	        return true;
	    }
	    if (str === undefined) {
	        return false;
	    }
	    str = str.replace(/ /g, '');//remove all empty space
	    return (isNaN(Number(str)) || str === "") ? false : true;
	};

	var fireCustomEvent = function (obj, eventName) {
	    try {
	        var event = new CustomEvent(eventName);
	        obj.dispatchEvent(event);
	    } catch (ex) {
	        error(ex);
	    }

	};

	var isIphone = function () {
	    var isFlag = (/iphone/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	};

	var isIos = function () {
	    var isFlag = isIphone() || (/ipad/i.test(navigator.userAgent.toLowerCase()));
	    return isFlag;
	};


	module.exports = {
	    isMobile: isMobile,
	    isAndroid: isAndroid,
	    isChrome: isChrome,
	    isFullScreen: isFullScreen,
	    isValidNumberForHTML: isValidNumberForHTML,
	    fireCustomEvent: fireCustomEvent,
	    isIos:isIos
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "SideStream";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };

	var Utils = __webpack_require__(47);

	/**
	 * SideStream for AdUnit (currently only support Outstream AdUnit
	 * @param adUnit
	 * @param playerManager
	 * @constructor
	 */
	var SideStream = function (adUnit, playerManager) {

	    var zIndexOfSideStream = 2147483647;//largest positive value of a signed integer on a 32 bit operating systems
	    var sideStreamSelf = this;

	    this.options = adUnit.options;// required variables to be defined by adUnit
	    this.playerManager = playerManager;// required variables to be defined by adUnit
	    var timeIntervalForMoveback = 250;//interval to check when adunit move back to the original position
	    this.isActivated = false;//flag to set sideStream is active
	    this.targetElementForSideStream = sideStreamSelf.options.targetElement;
	    // this.isDoneInitialMove = false;
	    this.emptyDiv = {};//object for emptyDIV, this object will be passed as one of the attributes of plaerManager.options in order to check with resize for VID-1789
	    this.isEmptySpaceInjected = false;//empty space injecting is required not to push/pull contents of publishers
	    this.originalCSS = {
	        position: "",
	        top: "",
	        bottom: "",
	        left: "",
	        right: "",
	        marginLeft: "",
	        marginRight: "",
	        marginTop: "",
	        marginBottom: "",
	        offsetWidth: "",
	        offsetHeight: "",
	        transition: "",
	        webkitTransition: "",
	        height: "",
	        width: ""
	    };//for keeping original CSS of target element, it will be restored when it goes back to Outstream


	    /**
	     * save original css attribute which are related to side stream specific feature
	     * @param element
	     */
	    this.saveOriginalCss = function (element) {
	        var cssOfTargetElement = element.style;

	        //save original css
	        this.originalCSS = {
	            position: cssOfTargetElement.position,
	            top: cssOfTargetElement.top,
	            bottom: cssOfTargetElement.bottom,
	            left: cssOfTargetElement.left,
	            right: cssOfTargetElement.right,
	            marginLeft: cssOfTargetElement.marginLeft,
	            marginRight: cssOfTargetElement.marginRight,
	            marginTop: cssOfTargetElement.marginTop,
	            marginBottom: cssOfTargetElement.marginBottom,
	            offsetWidth: element.offsetWidth,
	            offsetHeight: element.offsetHeight,
	            transition: cssOfTargetElement.transition,
	            webkitTransition: cssOfTargetElement.webkitTransition,
	            height: cssOfTargetElement.height,
	            width: cssOfTargetElement.width
	        };
	    };

	    /**
	     * load original css attrubute from variables
	     * @param element
	     */
	    this.loadOriginalCss = function (element) {


	        var cssOfTargetElement = element.style;

	        //load original css
	        cssOfTargetElement.position = this.originalCSS.position;
	        cssOfTargetElement.top = this.originalCSS.top;
	        cssOfTargetElement.bottom = this.originalCSS.bottom;
	        cssOfTargetElement.left = this.originalCSS.left;
	        cssOfTargetElement.right = this.originalCSS.right;
	        cssOfTargetElement.marginLeft = this.originalCSS.marginLeft;
	        cssOfTargetElement.marginRight = this.originalCSS.marginRight;
	        cssOfTargetElement.marginTop = this.originalCSS.marginTop;
	        cssOfTargetElement.marginBottom = this.originalCSS.marginBottom;

	        cssOfTargetElement.transition = this.originalCSS.transition;
	        cssOfTargetElement.webkitTransition = this.originalCSS.webkitTransition;

	        cssOfTargetElement.height = this.originalCSS.height;
	        cssOfTargetElement.width = this.originalCSS.width;


	    };

	    /**
	     * return true if sideStream should resize
	     * @returns {boolean}
	     */
	    this.shouldCloseAdUnit = function () {
	        var caseForDisableCollapse = playerManager.options.disableCollapse === true && playerManager.isSkipped === true;
	        var caseWhenVideoCompleted = playerManager.options.disableCollapse === false && playerManager.isCompleted === true;

	        return (caseForDisableCollapse || caseWhenVideoCompleted) ? true : false;
	    };

	    /**
	     * move adunit back to the original position and have original css attribute which this module changed
	     */
	    this.moveAdUnitBack = function () {

	        debug("moveAdUnitBack");

	        sideStreamSelf.isActivated = false;

	        //remove object in options
	        if (sideStreamSelf.options.emptyDiv) {
	            delete(sideStreamSelf.options.emptyDiv);
	        }


	        //remove emptyDiv
	        if (sideStreamSelf.isEmptySpaceInjected) {
	            var hasEmptyDivInParentElement = sideStreamSelf.options && sideStreamSelf.options.targetElement && sideStreamSelf.options.targetElement.parentElement && sideStreamSelf.options.targetElement.parentElement.contains(sideStreamSelf.emptyDiv);
	            if (hasEmptyDivInParentElement) {
	                sideStreamSelf.options.targetElement.parentElement.removeChild(sideStreamSelf.emptyDiv);
	            }
	        }


	        //load original css, this should be performed before resetting height, width of targetElementForSideStream to avoid a situation about VID-1914
	        sideStreamSelf.loadOriginalCss(sideStreamSelf.targetElementForSideStream);

	        //now Outstream should have original value of height
	        if (sideStreamSelf.hasSizeForSideStream()) {
	            //ignore hieght, weight for styling
	            sideStreamSelf.targetElementForSideStream.style.height = "";
	            sideStreamSelf.targetElementForSideStream.style.width = "";
	        }

	        //resize canvase for iOS
	        var resizeCallback = function () {
	            Utils.fireCustomEvent(sideStreamSelf.options.targetElement, "IOS_INLINE_RESIZE");
	            //load original css
	            sideStreamSelf.loadOriginalCss(sideStreamSelf.targetElementForSideStream);//this should move to up for VID-1914
	        };

	        sideStreamSelf.playerManager.resizeVideo(false, false, resizeCallback);

	        adUnit.haveVideoThresholdForSideStream = false;

	        if (sideStreamSelf.shouldCloseAdUnit()) {
	            sideStreamSelf.targetElementForSideStream.style.height = "0px";
	        }

	        if (sideStreamSelf.options.autoInitialSize && !Utils.isMobile()) {
	            Utils.fireCustomEvent(window,"resize");//invoke resize event to resize whole area
	        }

	    };

	    /**
	     * move adunit to side position depending on options, if options doesn't have right value it will have default values
	     * and start Detection logic to move back when it's required
	     */
	    this.moveAdUnit = function () {

	        debug("moveAdUnit to sidestream");
	        sideStreamSelf.isActivated = true;

	        var width = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).width;
	        var height = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).height;


	        sideStreamSelf.injectSpace();//this should be invoked at the beginning of this method because the emptySpace should have same height of the targetElement(Div- Outstream)

	        this.saveOriginalCss(sideStreamSelf.targetElementForSideStream);
	        sideStreamSelf.targetElementForSideStream.style.position = "fixed";
	        sideStreamSelf.targetElementForSideStream.style.transition = "";
	        sideStreamSelf.targetElementForSideStream.style.webkitTransition = "";

	        var xOffset = sideStreamSelf.options.sideStream.xOffset;
	        var yOffset = sideStreamSelf.options.sideStream.yOffset;

	        //if offset of options doesn't hava valid number it will have default value as 0px
	        xOffset = (Utils.isValidNumberForHTML(xOffset)) ? xOffset + "px" : "0px";
	        yOffset = (Utils.isValidNumberForHTML(yOffset)) ? yOffset + "px" : "0px";

	        //resize canvase
	        var resizeCallback = function () {
	            if (Utils.isIos()) {
	                Utils.fireCustomEvent(sideStreamSelf.options.targetElement, "IOS_INLINE_RESIZE");
	            }

	        };

	        if (sideStreamSelf.hasSizeForSideStream()) {



	            sideStreamSelf.playerManager.resizeVideoForSideStream(width, height, resizeCallback);
	            //sideStreams could have own height by definiend by options
	            sideStreamSelf.targetElementForSideStream.style.width = width + "px";
	            sideStreamSelf.targetElementForSideStream.style.height = height + "px";


	        } else {
	            sideStreamSelf.playerManager.resizeVideo(false, false, resizeCallback);
	        }


	        sideStreamSelf.targetElementForSideStream.style.zIndex = zIndexOfSideStream;
	        switch (sideStreamSelf.options.sideStream.position.toLowerCase()) {
	            case "top-left" :
	                sideStreamSelf.targetElementForSideStream.style.top = "0px";
	                sideStreamSelf.targetElementForSideStream.style.bottom = "";
	                sideStreamSelf.targetElementForSideStream.style.left = "0px";
	                sideStreamSelf.targetElementForSideStream.style.right = "";
	                sideStreamSelf.targetElementForSideStream.style.marginLeft = xOffset;
	                sideStreamSelf.targetElementForSideStream.style.marginTop = yOffset;
	                break;
	            case "top-right" :
	                sideStreamSelf.targetElementForSideStream.style.top = "0px";
	                sideStreamSelf.targetElementForSideStream.style.bottom = "";
	                sideStreamSelf.targetElementForSideStream.style.left = "";
	                sideStreamSelf.targetElementForSideStream.style.right = "0px";
	                sideStreamSelf.targetElementForSideStream.style.marginRight = xOffset;
	                sideStreamSelf.targetElementForSideStream.style.marginTop = yOffset;
	                break;
	            case "bottom-left" :
	                sideStreamSelf.targetElementForSideStream.style.top = "";
	                sideStreamSelf.targetElementForSideStream.style.bottom = "0px";
	                sideStreamSelf.targetElementForSideStream.style.left = "0px";
	                sideStreamSelf.targetElementForSideStream.style.right = "";
	                sideStreamSelf.targetElementForSideStream.style.marginLeft = xOffset;
	                sideStreamSelf.targetElementForSideStream.style.marginBottom = yOffset;
	                break;
	            case "bottom-right" :
	                sideStreamSelf.targetElementForSideStream.style.top = "";
	                sideStreamSelf.targetElementForSideStream.style.bottom = "0px";
	                sideStreamSelf.targetElementForSideStream.style.left = "";
	                sideStreamSelf.targetElementForSideStream.style.right = "0px";
	                sideStreamSelf.targetElementForSideStream.style.marginRight = xOffset;
	                sideStreamSelf.targetElementForSideStream.style.marginBottom = yOffset;
	                break;
	            default :
	                sideStreamSelf.targetElementForSideStream.style.top = "";
	                sideStreamSelf.targetElementForSideStream.style.bottom = "0px";
	                sideStreamSelf.targetElementForSideStream.style.left = "";
	                sideStreamSelf.targetElementForSideStream.style.right = "0px";
	                sideStreamSelf.targetElementForSideStream.style.marginRight = xOffset;
	                sideStreamSelf.targetElementForSideStream.style.marginBottom = yOffset;
	                break;
	        }


	        sideStreamSelf.startDetection();


	    };

	    this.hasSizeForSideStream = function () {
	        return (Utils.isValidNumberForHTML(sideStreamSelf.options.sideStream.width) || Utils.isValidNumberForHTML(sideStreamSelf.options.sideStream.height)) ? true : false;
	    };


	    /**
	     * injectSpace : will inject empty space into the div with same size of original div
	     */
	    this.injectSpace = function () {
	        debug("injectSpace");

	        var heightOfTargetElement = (sideStreamSelf.options.sideStream.space === "remove") ? "" : sideStreamSelf.targetElementForSideStream.clientHeight + "px";
	        var offsetWidthOfTargetElement = sideStreamSelf.targetElementForSideStream.clientWidth + "px";

	        debug("inject : " + heightOfTargetElement);

	        sideStreamSelf.emptyDiv = document.createElement("div");
	        sideStreamSelf.emptyDiv.style.position = "";
	        sideStreamSelf.emptyDiv.style.left = "";
	        sideStreamSelf.emptyDiv.style.top = "";

	        sideStreamSelf.emptyDiv.style.height = heightOfTargetElement;
	        sideStreamSelf.emptyDiv.style.offsetWidth = offsetWidthOfTargetElement;

	        sideStreamSelf.options.emptyDiv = sideStreamSelf.emptyDiv;//inject emptyDiv into option to share with playerManager in order to check resize for VID-1789

	        //inject empty space into div
	        sideStreamSelf.options.targetElement.parentElement.appendChild(sideStreamSelf.emptyDiv);


	        sideStreamSelf.isEmptySpaceInjected = true;

	    };

	    /**
	     * start elelemt detection logic to get back adUnit to original position
	     */
	    this.startDetection = function () {
	        if (adUnit.isElementVisible(sideStreamSelf.emptyDiv) && sideStreamSelf.playerManager.isFullscreen === false) {
	            sideStreamSelf.moveAdUnitBack();
	        } else {
	            setTimeout(sideStreamSelf.startDetection, timeIntervalForMoveback);
	        }
	    };


	    /**
	     * check page overlay for VID-1805
	     * @returns {boolean}
	     */
	    this.checkPageOverlay = function () {

	        var result = false;
	        var areaOfWindow;
	        var areaOfSideStream;
	        var percentageOfArea;
	        var maxPageOverlay = 100;//default value if it's not defined.

	        if (sideStreamSelf.options.sideStream && sideStreamSelf.options.sideStream.maxPageOverlay) {
	            maxPageOverlay = "" + sideStreamSelf.options.sideStream.maxPageOverlay;
	            maxPageOverlay = Number(maxPageOverlay.replace("%", ""));
	        }

	        areaOfWindow = window.innerWidth * window.innerHeight;
	        if (sideStreamSelf.hasSizeForSideStream()) {

	            var width = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).width;
	            var height = sideStreamSelf.getWidthHeightConsideredByAspectRatio(sideStreamSelf.getAspectRatioByPlayerSize()).height;

	            areaOfSideStream = width * height;


	        } else {
	            areaOfSideStream = (adUnit && adUnit.sizeObj && adUnit.sizeObj.finalSize) ? adUnit.sizeObj.finalSize.width * adUnit.sizeObj.finalSize.height : 0;
	        }

	        percentageOfArea = Math.round(areaOfSideStream / areaOfWindow * 100);

	        if (maxPageOverlay !== null && percentageOfArea <= maxPageOverlay) {
	            result = true;
	        }
	        return result;
	    };


	    this.shouldNotResizeWhenSideStreamActivated = function () {
	        return (playerManager.options.sideStream && playerManager.options.sideStream.enabled && sideStreamSelf.isActivated);
	    };

	    /**
	     * getAspectRatioByPlayerSize to set aspect ratio by Outstream's width and height
	     */
	    this.getAspectRatioByPlayerSize = function () {
	        var aspectRatio_ = 16 / 9;//default will be 16:9

	        var width = (adUnit && adUnit.sizeObj && adUnit.sizeObj.finalSize) ? adUnit.sizeObj.finalSize.width : 0;
	        var height = (adUnit && adUnit.sizeObj && adUnit.sizeObj.finalSize) ? adUnit.sizeObj.finalSize.height : 0;

	        if (height > 0 && width > 0) {
	            aspectRatio_ = width / height;
	        }
	        // log("aspect ratio : " + aspectRatio_);
	        return aspectRatio_;
	    };


	    /**
	     * getWidthHeightConsideredByAspectRatio : this will calculate width, hiehgt by aspect ratio
	     */
	    this.getWidthHeightConsideredByAspectRatio = function (aspectRatio) {

	        var width = 0;
	        var height = 0;

	        if (aspectRatio <= 0) {
	            debug("aspectRatio is inappropriate");
	            return null;
	        }

	        if (sideStreamSelf.options.sideStream.width && sideStreamSelf.options.sideStream.height) {
	            width = sideStreamSelf.options.sideStream.width;
	            height = sideStreamSelf.options.sideStream.height;
	        } else {
	            width = sideStreamSelf.options.sideStream.width ? sideStreamSelf.options.sideStream.width : sideStreamSelf.options.sideStream.height / aspectRatio;
	            height = sideStreamSelf.options.sideStream.height ? sideStreamSelf.options.sideStream.height : sideStreamSelf.options.sideStream.width / aspectRatio;
	        }

	        // log("getWidthHeightConsideredByAspectRatio : " + width + "," + height);
	        return {width: width, height: height};

	    };


	};

	module.exports = SideStream;


/***/ },
/* 49 */
/***/ function(module, exports) {

	/**
	 * ViewableDetector for video adunit
	 *
	 * @param element
	 * @param rWindowForPublisher
	 * @param isExpanded
	 * @param isWindowTopAccessible
	 * @param iframeWindowHeight
	 * @param iframeOffsetTop
	 * @param customVisibleThreshold
	 * @param customHeight
	 * @param elementToCheckTopMost
	 * @param rateOfBeaconsForTopMostCheck
	 * @param videoHeight
	 * @param playVideoVisibleThreshold
	 * @param checkVerticalOnly
	 * @param parentIframeIsModal
	 * @returns {boolean}
	 */
	module.exports = function (element, rWindowForPublisher, isExpanded, isWindowTopAccessible, iframeWindowHeight, iframeOffsetTop, customVisibleThreshold, customHeight, elementToCheckTopMost, rateOfBeaconsForTopMostCheck, videoHeight, playVideoVisibleThreshold, checkVerticalOnly, parentIframeIsModal) {
	    //handle modal iframes - don't care external scroll only focus internal scroll regardless friendly/unfriendly iframe
	    if (parentIframeIsModal === true) {
	        iframeOffsetTop = 0;
	        iframeWindowHeight = window.self.innerHeight || ((window.self.documentElement) ? window.self.documentElement.clientHeight : window.self.document.documentElement.clientHeight);
	    }

	    //internal variables for this method
	    var topWindowInnerHeight;
	    var videoAreaOnIframe;
	    var videoAreaOnIframePositionTop;
	    var remainingDistanceToVideoArea;
	    var remainingDistanceToVideoAreaByThreshold;
	    var remainingDistanceToVideoAreaByThresholdReverse;
	    var videoAreaPositionTop;
	    var heightOfElement = (typeof(customHeight) !== "undefined") ? customHeight : videoHeight;
	    var visibleThreshold = (typeof(customVisibleThreshold) !== "undefined") ? customVisibleThreshold / 100 : playVideoVisibleThreshold / 100;
	    var adjustedPositionYByThreshold = heightOfElement * visibleThreshold;
	    var adjustedPositionYByThresholdReverse = Number(heightOfElement) - (heightOfElement * visibleThreshold);
	    var iframeOnTopWindowPositionTop = 0;
	    var iframeValuebyRecusively = {top: 0};

	    var destIframe;
	    var destWindow;
	    var iframePositionTop;
	    var cnt_i;
	    var isInIframe;
	    var getIframesRecursively;
	    var iframes;

	    if (typeof(element) === "undefined" || element instanceof Element === false) {
	        return false;//for VID-1913
	    }


	    //if there's event from crossdomain it will be used
	    if (!isWindowTopAccessible) {
	        topWindowInnerHeight = iframeWindowHeight;
	    } else {
	        topWindowInnerHeight = rWindowForPublisher.innerHeight || ((rWindowForPublisher.documentElement) ? rWindowForPublisher.documentElement.clientHeight : rWindowForPublisher.document.documentElement.clientHeight);
	    }
	    isInIframe = (rWindowForPublisher === window.self) ? false : true;

	    isInIframe = !isWindowTopAccessible ? true : isInIframe;//override isInIframe

	    if (isInIframe) {//for both crossdomain and friendly iframe cases

	        if (isWindowTopAccessible) {
	            //if adunit is in the iframe
	            getIframesRecursively = function (targetWindow, cntRecursion) {
	                if (targetWindow === rWindowForPublisher || cntRecursion <= 0) {
	                    return;//exit out of this recusive routine
	                }
	                iframes = targetWindow.parent.document.getElementsByTagName("iframe");
	                for (cnt_i = 0; cnt_i < iframes.length; cnt_i++) {
	                    destIframe = iframes[cnt_i];
	                    destWindow = destIframe.contentWindow;
	                    if (destWindow === targetWindow) {
	                        iframePositionTop = destIframe.getBoundingClientRect().top;
	                        iframeValuebyRecusively.top += iframePositionTop;
	                        getIframesRecursively(destWindow.parent, --cntRecursion);
	                    }
	                }
	            };
	            getIframesRecursively(window.self, 100);//limit of recusrsion logic
	        } else {
	            iframeValuebyRecusively.top = iframeOffsetTop;
	        }

	        iframeOnTopWindowPositionTop = iframeValuebyRecusively.top - topWindowInnerHeight;
	        //distnace from iframe to videoArea
	        videoAreaOnIframe = element;
	        videoAreaOnIframePositionTop = videoAreaOnIframe.getBoundingClientRect().top;
	        remainingDistanceToVideoArea = iframeOnTopWindowPositionTop + videoAreaOnIframePositionTop;
	        remainingDistanceToVideoAreaByThreshold = iframeOnTopWindowPositionTop + videoAreaOnIframePositionTop + adjustedPositionYByThreshold;
	        remainingDistanceToVideoAreaByThresholdReverse = iframeOnTopWindowPositionTop + videoAreaOnIframePositionTop + adjustedPositionYByThresholdReverse;
	    } else {
	        //if adunit isn't in the iframe
	        videoAreaPositionTop = element.getBoundingClientRect().top - topWindowInnerHeight;
	        remainingDistanceToVideoArea = videoAreaPositionTop;
	        remainingDistanceToVideoAreaByThreshold = videoAreaPositionTop + adjustedPositionYByThreshold;
	        remainingDistanceToVideoAreaByThresholdReverse = videoAreaPositionTop + adjustedPositionYByThresholdReverse;

	    }


	    var topMostCheck = function () {

	        var result = true;//true won't interfere with existing logic if page doesn't have overlaid html element on the video
	        try {
	            var d = elementToCheckTopMost;//adunit will use iframe instead of target div because of more accutrate calculation - target div can have 0.x value due to a mechanism of browsers
	            var d_top = d.getBoundingClientRect().top;
	            var d_bottom = d.getBoundingClientRect().bottom;
	            var d_left = d.getBoundingClientRect().left;
	            var d_right = d.getBoundingClientRect().right;
	            var d_width = d.getBoundingClientRect().width;
	            var d_height = d.getBoundingClientRect().height;
	            var d_windowHeight = window.self.innerHeight || ((window.self.documentElement) ? window.self.documentElement.clientHeight : window.self.document.documentElement.clientHeight);

	            //use window.height if there's unnesaary minus or undfine vluae when video is out of viewport + add safety value to check hidden area
	            d_top = (d_top && d_top < (-1 * d_height)) ? (-1 * d_height) : d_top;//fix VIDLA-54
	            d_top = (d_top && d_top > d_windowHeight) ? d_windowHeight : d_top;
	            d_bottom = (d_bottom && d_bottom < 0) ? 0 : d_bottom;
	            d_bottom = (d_bottom && d_bottom > (d_windowHeight + d_height)) ? (d_windowHeight + d_height) : d_bottom;//fix VIDLA-54

	            var gapOfBeaconX = d_width * (rateOfBeaconsForTopMostCheck / 100);//code will check % of pixels on width and height in order to check to see if there's overwrapped html element on the video.
	            var gapOfBeaconY = d_height * (rateOfBeaconsForTopMostCheck / 100);//code will check % of pixels on width and height in order to check to see if there's overwrapped html element on the video.
	            var totalBeacons = 0;
	            var countForVisibleBeacons = 0;
	            var y = 0;
	            var x = 0;
	            var checkElement;

	            if (checkVerticalOnly === true) {

	                //check from top line
	                x = (d_left + d_right) / 2;//get center of video
	                for (y = d_top; y <= d_bottom - 1; y = y + gapOfBeaconY) {
	                    checkElement = document.elementFromPoint(x, y);
	                    if (checkElement === d) {//only count if video is top-most
	                        countForVisibleBeacons++;
	                    }
	                    totalBeacons++;
	                }

	                //check bottom line
	                checkElement = document.elementFromPoint(x, d_bottom - 1);
	                totalBeacons++;
	                if (checkElement === d) {//only count if video is top-most
	                    countForVisibleBeacons++;
	                }


	            } else {
	                for (y = d_top; y <= d_bottom - 1; y = y + gapOfBeaconY) {
	                    for (x = d_left; x <= d_right - 1; x = x + gapOfBeaconX) {
	                        checkElement = document.elementFromPoint(x, y);
	                        if (checkElement === d) {//only count if video is top-most
	                            countForVisibleBeacons++;
	                        }
	                        totalBeacons++;
	                    }
	                }
	            }

	            var visibleRateOfBeacons = countForVisibleBeacons / totalBeacons;
	            var visiblePixel = d_height - (d_height * (1 - visibleRateOfBeacons));
	            var visiblePixelRate = visiblePixel / d_height;

	            // console.log("===============================");
	            // console.log("d_top: " + d_top);
	            // console.log("d_bottom: " + d_top);
	            // console.log("d_width: " + d_width);
	            // console.log("d_height: " + d_height);
	            // console.log("gapOfBeaconX: " + gapOfBeaconX);
	            // console.log("gapOfBeaconY: " + gapOfBeaconY);
	            // console.log("totalBeacons:" + totalBeacons);
	            // console.log("countForVisibleBeacons:" + countForVisibleBeacons);
	            // console.log("visibleRateOfBeacons: " + visibleRateOfBeacons);
	            // console.log("visiblePixel:" + visiblePixel);
	            // console.log("visiblePixelRate:" + visiblePixelRate);
	            // console.log("visibleThreshold:" + visibleThreshold);

	            if ((visiblePixelRate <= visibleThreshold) && (visiblePixelRate < 1)) {
	                result = false;
	            }


	        } catch (ex) {
	            console.log("PlayerManager : ViewableDetector : " + ex);
	            result = true;//true won't interfere with existing logic if page doesn't have overlaid html element on the video
	        }

	        return result;
	    };


	    //for a moment to start expanding adunit, only for forward scroll case
	    if (!isExpanded && remainingDistanceToVideoArea < 0 && remainingDistanceToVideoArea > (-1 * heightOfElement)) {
	        return true;//after expanded, "isExpanded" will have true, so this routine wil be one time action in a life cycle of adunit object
	    }

	    //check video is placed on top-most and threshold - only this logic concerns about visible=false case
	    if (elementToCheckTopMost && rateOfBeaconsForTopMostCheck && rateOfBeaconsForTopMostCheck > 0 && isExpanded && topMostCheck() === false) {
	        return false;
	    }

	    //pause case when video is placed on top of page by user scrolling
	    if (remainingDistanceToVideoAreaByThresholdReverse < -1 * topWindowInnerHeight) {
	        return false;
	    }

	    if (!isExpanded && remainingDistanceToVideoAreaByThreshold < 0) {//reverse scroll case
	        return true;//after expanded, "isExpanded" will have true, so this routine wil be one time action in a life cycle of adunit object
	    }

	    //pause case when video is placed on bottom of page
	    //resume case when video is placed on (bottom and top) of page
	    if (remainingDistanceToVideoAreaByThreshold < 0) {
	        return true;
	    } else {
	        return false;
	    }
	};





/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "Outstream_Events";
	var APN_Logger = __webpack_require__(2);
	// var debug = function (message) {
	//     APN_Logger.verbose(message, prefixOfLog);
	// };
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	var info = function (message) {
	    APN_Logger.info(message, prefixOfLog);
	};

	var Utils = __webpack_require__(47);


	/**
	 * Termination : termination logic
	 * @param outstreamSelf
	 * @returns {Function}
	 */
	module.exports = function(outstreamSelf) {

	    return function (isError) {

	        //VID-2146 remove empty space
	        if (outstreamSelf.options.sideStream.enabled === true && outstreamSelf.sideStream && outstreamSelf.sideStream.isActivated === true) {
	            outstreamSelf.sideStream.moveAdUnitBack();
	            outstreamSelf.playerManager.isCompleted = true;
	        }


	        if (outstreamSelf.playerManager.forceToSkip) {//VID-1359 VID-1350
	            outstreamSelf.isAreadyTerminated = false;
	            outstreamSelf.playerManager.forceToSkip = false;
	        }

	        if (outstreamSelf.isAreadyTerminated) {return;}//check a flag to avoid double terminating


	        info("terminate all elements");

	        //remove all event
	        outstreamSelf.rWindow.clearInterval(outstreamSelf.triggerCheckFocus);
	        outstreamSelf.rWindowForPublisher.removeEventListener("resize", outstreamSelf.fnRotationChange);

	        if (outstreamSelf.isWindowTopAccessible) {
	            outstreamSelf.rWindowForPublisher.removeEventListener("scroll", outstreamSelf.detectAndPlay);
	            outstreamSelf.rWindowForPublisher.removeEventListener("touchmove", outstreamSelf.detectAndPlay);
	        }

	        if (outstreamSelf.intervalIdForDetectAndPlay) {
	            outstreamSelf.rWindowForPublisher.clearInterval(outstreamSelf.intervalIdForDetectAndPlay);
	        }


	        //safe termination during change fullscreen state
	        var limitAttemptTermination = 3000;
	        var currentAttemptTermination = 0;

	        outstreamSelf.disableCollapse = (outstreamSelf.disableCollapse && !outstreamSelf.playerManager.isSkipped && !outstreamSelf.isTerminatedByPublisher);//change more standard way


	        var performTermination = function () {

	            if (outstreamSelf.playerManager) {
	                outstreamSelf.playerManager.delayEventHandler.lazyTerminate();//this will push a function to terminate timer into a queue
	            }


	            if (!Utils.isFullScreen(outstreamSelf.playerManager)) {
	                //we might be calling this multiple times, so let's make sure targetElement
	                //still exists before we access it
	                if (outstreamSelf.targetElement) {
	                    outstreamSelf.targetElement.textContent = '';
	                    outstreamSelf.targetElement = undefined;
	                }
	                outstreamSelf.eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);
	            } else {
	                //wait until entirely exit fullscreen
	                if (currentAttemptTermination <= limitAttemptTermination) {
	                    setTimeout(function () {
	                        currentAttemptTermination += 500;
	                        performTermination();
	                    }, 500);
	                } else {
	                    //if player cannot exit from fullscreen, just perform explicitPause and invoke eventCB to AST
	                    //because if it's in fullscreen, then try to remove innerContent then it will cause freeze problem
	                    outstreamSelf.playerManager.isCompleted = true;
	                    outstreamSelf.playerManager.explicitPause();
	                    outstreamSelf.targetElement = null;
	                    outstreamSelf.eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);

	                    return;
	                }

	            }
	        };


	        var fnTerminateImmediately = function () {

	            //move back to outstream from sidestream
	            if (outstreamSelf.options.sideStream.enabled === true && outstreamSelf.sideStream) {
	                outstreamSelf.sideStream.moveAdUnitBack();
	            }


	            // exit full-screen
	            if (document.exitFullscreen) {
	                document.exitFullscreen();
	            } else if (document.webkitExitFullscreen) {
	                document.webkitExitFullscreen();
	            } else if (document.mozCancelFullScreen) {
	                document.mozCancelFullScreen();
	            } else if (document.msExitFullscreen) {
	                document.msExitFullscreen();
	            }

	            if (!outstreamSelf.disableCollapse) {

	                if (outstreamSelf.isExpanded) {
	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseStart);
	                    outstreamSelf.targetElement.style.overflow = "hidden";
	                    //css transition start
	                    outstreamSelf.targetElement.style.height = "0px";

	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseEnd);

	                }
	                performTermination();//terminate and invoke eventCB for AST
	            }
	            else {
	                outstreamSelf.eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);
	            }

	            if (!isError) {
	                outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
	            }




	        };


	        var fnTerminateSmoothly = function () {
	            outstreamSelf.playerManager.isCompleted = true;
	            outstreamSelf.sendPauseSignalToVideoPlayerExplicit();

	            //performTermination will invoke so commented out following lines
	            //eventCB(outstreamSelf.ASTadId, (isError ? outstreamSelf.cbType.error : outstreamSelf.cbType.ended), outstreamSelf.options, isError);

	            if (!outstreamSelf.disableCollapse) {


	                var handleCollapseEnd = function (e) {
	                    /*jshint -W059 */
	                    //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                    e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
	                    /*jshint -W059 */

	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseEnd);

	                    performTermination();

	                    if (!outstreamSelf.isAlreadyCompleted && !isError && !outstreamSelf.isTerminatedByPublisher) {
	                        outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
	                    }
	                };

	                //for modern browser
	                outstreamSelf.targetElement.addEventListener("transitionend", function (e) {
	                    handleCollapseEnd(e);
	                    /*jshint -W059 */
	                    //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                    e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
	                    /*jshint -W059 */
	                });


	                //for old firefox
	                outstreamSelf.targetElement.addEventListener("mozTransitionEnd", function (e) {
	                    handleCollapseEnd(e);
	                    /*jshint -W059 */
	                    //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                    e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
	                    /*jshint -W059 */
	                });

	                //for webkit
	                outstreamSelf.targetElement.addEventListener("webkitTransitionEnd", function (e) {
	                    handleCollapseEnd(e);
	                    /*jshint -W059 */
	                    //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                    e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
	                    /*jshint -W059 */
	                });

	                //for opera
	                outstreamSelf.targetElement.addEventListener("oTransitionEnd", function (e) {
	                    handleCollapseEnd(e);
	                    /*jshint -W059 */
	                    //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                    e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
	                    /*jshint -W059 */
	                });


	                //An event to handle css transition should be defined before starting the transition to make sure it's reliable
	                if (outstreamSelf.isExpanded) {
	                    //start css transition
	                    outstreamSelf.targetElement.style.height = "0px";
	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseStart);
	                }

	            }
	            else {

	                if (!isError && !outstreamSelf.isTerminatedByPublisher) {
	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
	                }
	                outstreamSelf.isAlreadyCompleted = true;
	            }


	        };


	        //exit fullscreen if it's on fullscreen
	        if (Utils.isFullScreen(outstreamSelf.playerManager)) {
	            fnTerminateImmediately();
	        } else {
	            fnTerminateSmoothly();
	        }
	        outstreamSelf.isAreadyTerminated = true;
	        setTimeout(function () {
	            if (!outstreamSelf.isCollapseEnd && outstreamSelf.isCollapseStart) {
	                outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.collapseEnd);
	            }

	            if (!outstreamSelf.isAdComplete && !isError && !outstreamSelf.isTerminatedByPublisher) {
	                outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.adComplete);
	            }
	        }, outstreamSelf.options.expandTime + outstreamSelf.TIME_TO_REVERIFY);//if collapseEnd and adComplete isn't happened until outstream.options.expandTime +(TIME_TO_REVERIFY)  Outstream will regards it's done and send callback notification. this is for when css transition is failed on some devices

	    };



	};



/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "[Outstream_Mobile]";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(prefixOfLog, message);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };


	var Utils = __webpack_require__(47);

	/**
	 * Mobile : mobile related feature like fullscreen, resize
	 * @param outstreamSelf
	 * @returns {{createAndroidIframes: "createAndroidIframes", handleFullscreen: "handleFullscreen", fnRotationChange: "fnRotationChange", resizeOutstreamArea: "resizeOutstreamArea"}}
	 */
	module.exports = function (outstreamSelf) {

	    return {
	        "handleFullscreen": function () {
	            debug("handleFullscreen");
	            if (outstreamSelf.shouldResizeByFullscreenChange) {
	                setTimeout(function () {
	                    outstreamSelf.playerManager.resizeVideo(-1);
	                    outstreamSelf.resizeOutstreamArea();

	                    if (Utils.isAndroid()) {
	                    } else {
	                        outstreamSelf.playerManager.play();
	                    }

	                    outstreamSelf.shouldResizeByFullscreenChange = false;
	                }, 500);
	            }
	        },
	        "fnRotationChange": function () {//this method is a event handler for "window.resize" when Outstream renders in mobile device it will be invoked whenever rotation changes
	            debug("fnRotationChange");
	            //for VID
	            var shouldNotResizeWhenSideStreamActivated = outstreamSelf.playerManager.options.sideStreamObject && typeof(outstreamSelf.playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated) === "function" ? outstreamSelf.playerManager.options.sideStreamObject.shouldNotResizeWhenSideStreamActivated() : false;
	            if (shouldNotResizeWhenSideStreamActivated || outstreamSelf.isExpanded !== true) {
	                return;
	            }


	            if (outstreamSelf.videoIsreadyToPlay) {//this pre-existing flag in Outstream object will be set to true when video player sends callback to notify video is ready to play and default is false

	                if (outstreamSelf.options.autoInitialSize) {
	                    outstreamSelf.options.width = outstreamSelf.options.targetElement.offsetWidth;
	                }

	                if (Utils.isMobile() && !outstreamSelf.playerManager.isIosInlineRequired() && Utils.isFullScreen(outstreamSelf.playerManager)) {//if mobile, ios7, fullscreen
	                    //this is relative with iOS7 mobile safari's bug. if some object has changed behind the fullscreen, it will break the content.show ugly screen
	                    //don't resizeVideo when iOS7 ipad is in fullscreen, resize action should be delayed after exit out of fullscreen
	                    outstreamSelf.shouldResizeByFullscreenChange = true;//if this flag set true, after fullscreen change, event handler(handleFullscreen) will resize video
	                } else {

	                    if (outstreamSelf.playerManager && outstreamSelf.playerManager.isIosInlineRequired && outstreamSelf.playerManager.isIosInlineRequired()) {
	                        //do nothing if it's in iOS inline video player
	                    } else {
	                        outstreamSelf.playerManager.resizeVideo(-1);
	                        outstreamSelf.resizeOutstreamArea();
	                    }

	                }
	            }

	        },
	        "resizeOutstreamArea": function () {
	            debug("resizeOutstreamArea");
	            //for VID-1047
	            if (outstreamSelf.playerManager && outstreamSelf.playerManager.isFullscreen && outstreamSelf.playerManager.isCompleted && Utils.isAndroid()) {
	                return;
	            }

	            //iOS can fire "resize" event during scrolling because of their own address bar appearing/disappearing
	            //so following code should be excuted when video is ready to go (when AdLoaded event came from VPAID creative if it's VPAID case)
	            outstreamSelf.targetElement.style.height = outstreamSelf.options.height + "px";

	            var videoObject = document.getElementById(outstreamSelf.playerManager.videoObjectId);
	            if (videoObject && typeof videoObject !== undefined) {
	                videoObject.style.width = outstreamSelf.options.width;
	                videoObject.style.height = outstreamSelf.options.height;
	            }
	        }
	    };
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "Outstream_Waterfall";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	// var error = function (message) {
	//     APN_Logger.error(message, prefixOfLog);
	// };
	// var info = function (message) {
	//     APN_Logger.info(message, prefixOfLog);
	// };

	var Utils = __webpack_require__(47);
	var AutoplayHandler = __webpack_require__(3).autoplayHandler;

	/**
	 * Waterfall : waterfall related logic
	 * @param outstreamSelf
	 * @returns {{cleanupTargetElement: "cleanupTargetElement", cleanupPreviousFlashElement: "cleanupPreviousFlashElement"}}
	 */
	module.exports = function (outstreamSelf) {

	    return {
	        "cleanupTargetElement": function () {
	            debug("cleanupTargetElement");
	            var elm = outstreamSelf.options.targetElement;
	            if(Utils.isAndroid()){
	                if( elm && elm.hasChildNodes()){
	                    //For Android usecase clear off previous iframes
	                    var iframeList = elm.getElementsByTagName("iframe");
	                    var name = AutoplayHandler.APN_MOBILE_IFRAME_NAME + "_Waterfall_"+outstreamSelf.options.adAttempt;
	                    for (var i=0;i<iframeList.length;i++) {
	                        var iframe = iframeList[i];
	                        if (iframe && iframe.name && iframe.name === name) {
	                            var prevIframe = iframe.parentNode.firstChild;
	                            iframe.parentNode.removeChild(prevIframe);
	                        }
	                    }
	                }
	            }else {
	                if (elm && elm.hasChildNodes()) {
	                    var waterfallMaskElement = document.getElementById("waterfall_mask");
	                    var width = elm.clientWidth;
	                    var height = elm.clientHeight;
	                    for (var cnt = 0; cnt < elm.childNodes.length; cnt++) {
	                        // do not remove Flash immediately
	                        if (elm.childNodes[cnt].type !== "application/x-shockwave-flash" && elm.childNodes[cnt].id !== "waterfall_mask") {
	                            width = elm.childNodes[cnt].clientWidth;
	                            height = elm.childNodes[cnt].clientHeight;
	                            elm.removeChild(elm.childNodes[cnt]);
	                        }
	                    }
	                    //insertMask
	                    if (!waterfallMaskElement) {
	                        waterfallMaskElement = document.createElement("div");
	                        waterfallMaskElement.id = "waterfall_mask";
	                        waterfallMaskElement.style.cssText = "display:inline-block; margin: 0;padding: 0;border: 0; background-color: #000;";
	                        elm.appendChild(waterfallMaskElement);
	                        waterfallMaskElement.style.width = width + "px";
	                        waterfallMaskElement.style.height = height + "px";
	                    }
	                }
	            }
	        },
	        "cleanupPreviousFlashElement": function() {
	            debug("cleanupPreviousFlashElement");
	            var elm = outstreamSelf.options.targetElement;
	            if(elm && elm.hasChildNodes() && elm.childNodes.length >1){
	                var currentElm = null;
	                if (outstreamSelf.playerManager.adVideoPlayer && outstreamSelf.playerManager.adVideoPlayer.type === "application/x-shockwave-flash") {
	                    currentElm = document.getElementById(outstreamSelf.playerManager.adVideoPlayer.id);//elm.lastChild;
	                }
	                var cnt =0;
	                var length = elm.childNodes.length;
	                while(cnt<length){
	                    if(elm.firstChild !== currentElm && elm.firstChild.type === "application/x-shockwave-flash"){
	                        elm.removeChild(elm.firstChild);
	                    } else if(elm.firstChild.id === "waterfall_mask"){
	                        elm.removeChild(elm.firstChild);
	                    }
	                    cnt++;
	                }
	            }
	        },
	    };
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.debug(message, "Outstream_ExternalInterface");
	};

	/**
	 * ExternalInterface : all external interfaces and callback notifications
	 * @param outstreamSelf
	 * @returns {{handleMessage: "handleMessage", parentIframeGeometryUpdate: "parentIframeGeometryUpdate", handleOkToPlayAd: "handleOkToPlayAd", cbNotification: "cbNotification", eventCB: "eventCB", cbNotification_internal: "cbNotification_internal", eventCB_internal: "eventCB_internal", reportFinalSize: "reportFinalSize"}}
	 */
	module.exports = function (outstreamSelf) {
	    return {
	        "handleMessage": function (messageName, messagePayload) {
	            debug("messageName : " + messageName);
	            debug("messagePayload : " + messagePayload);
	            switch (messageName) {
	                case "okToPlayAd":
	                    outstreamSelf.handleOkToPlayAd();
	                    break;
	                case "terminate":
	                    debug("Ad terminated by external AST message");
	                    outstreamSelf.isTerminatedByPublisher = true;
	                    outstreamSelf.terminateAll(false);
	                    break;
	                default:
	                    break;
	            }
	        },
	        "parentIframeGeometryUpdate": function (e) {
	            //Outstream's offsetTop : offsetTop - scrollY;
	            //Outstream's windowHeight : windowHeight

	            if (e && e.isModal && e.isModal === true) {
	                outstreamSelf.parentIframeIsModal = true;
	            }

	            if (e && e.offsetTop && e.scrollY && e.windowHeight) {
	                outstreamSelf.currentEventFromCrossDomainWindow.offsetTop = e.offsetTop - e.scrollY;
	                outstreamSelf.currentEventFromCrossDomainWindow.windowHeight = e.windowHeight;
	            }
	        },
	        "handleOkToPlayAd": function () {
	            outstreamSelf.isOkToPlayFromPublisher = true;
	            outstreamSelf.detectAndPlay();
	        },
	        "cbNotification": function (param, isError, obj) {
	            if (isError) {//all VAST callback should be suppressed until video expended
	                outstreamSelf.playerManager.delayEventHandler.push(function () {
	                    outstreamSelf.cbNotification_internal(param, isError, obj);
	                });
	            } else {
	                outstreamSelf.cbNotification_internal(param, isError, obj);
	            }
	        },
	        "eventCB": function (ASTadId, eventName, options_, errObj) {
	            outstreamSelf.eventCB_internal(ASTadId, eventName, options_, errObj);
	        },
	        "cbNotification_internal": function (param, isError, obj) {

	            //define function to call options.cbNotification
	            if (outstreamSelf.options.hasOwnProperty('cbNotification')) {
	                if (!isError) {
	                    outstreamSelf.options.cbNotification('AdUnit', param, outstreamSelf.options.targetId, obj);
	                    if (param === "collapseStart") {
	                        outstreamSelf.isCollapseStart = true;
	                    }
	                    if (param === "collapseEnd") {
	                        outstreamSelf.isCollapseEnd = true;
	                    }
	                    if (param === "adComplete") {
	                        outstreamSelf.isAdComplete = true;
	                    }
	                    if (param === "expandStart") {//VID-2844 for viewaibiltiy
	                        outstreamSelf.playerManager.dispatchEventToAdunit({"name": "expand"});
	                    }
	                    if (param === "collapseEnd") {//VID-2844 for viewaibiltiy
	                        outstreamSelf.playerManager.dispatchEventToAdunit({"name": "collapse"});
	                    }
	                } else {
	                    outstreamSelf.options.cbNotification('VAST', param, outstreamSelf.options.targetId);
	                }
	            }
	        },
	        "eventCB_internal": function (ASTadId, eventName, options_, errObj) {
	            debug("invoke eventCB to " + ASTadId + " with '" + eventName + "' event");
	            try {
	                if (options_ && typeof options_.eventCB === "function") {
	                    options_.eventCB(ASTadId, eventName, options_);
	                }
	                if (eventName === outstreamSelf.cbType.error) {
	                    if (errObj && errObj.code === 1) {
	                        outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.timeout, false);
	                    }
	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.error, true);
	                }
	            } catch (ex) {
	                debug(ex);
	            }
	        },
	        "reportFinalSize": function () {
	            var finalSize = outstreamSelf.playerManager.getFinalSize();
	            outstreamSelf.sizeObj = {
	                originalSize: {width: outstreamSelf.originalSize.width, height: outstreamSelf.originalSize.height},
	                finalSize: {width: finalSize.width, height: finalSize.height}
	            };

	            debug("options delivered from impbus : autoInitialSize=" + outstreamSelf.options.autoInitialSize + ", playerAspectRatio=" + outstreamSelf.options.playerAspectRatio + ", playerHeight(deprecated)=" + outstreamSelf.options.playerHeight);
	            debug("size delivered from impbus (width,height) : " + outstreamSelf.sizeObj.originalSize.width + "," + outstreamSelf.sizeObj.originalSize.height);
	            debug("size finalized by player (width,height) : " + outstreamSelf.sizeObj.finalSize.width + "," + outstreamSelf.sizeObj.finalSize.height);

	            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.size, false, outstreamSelf.sizeObj);
	        }
	    };
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.debug(message, "Outstream_Media");
	};

	/**
	 * Media : control video with playerManager
	 * @param outstreamSelf
	 * @returns {{isPlayingVideo: "isPlayingVideo", sendPlaySignalToVideoPlayerExplicit: "sendPlaySignalToVideoPlayerExplicit", sendPlaySignalToVideoPlayer: "sendPlaySignalToVideoPlayer", sendPauseSignalToVideoPlayerExplicit: "sendPauseSignalToVideoPlayerExplicit", sendPauseSignalToVideoPlayer: "sendPauseSignalToVideoPlayer"}}
	 */
	module.exports = function (outstreamSelf) {
	    return {
	        "isPlayingVideo": function () {
	            /**
	             * getting status of video
	             * @returns {boolean} return true if video is playing
	             */
	            if (outstreamSelf.playerManager) {
	                var result = outstreamSelf.playerManager.isPlayingVideo;
	                return result;
	            } else {
	                return false;
	            }

	        },
	        "sendPlaySignalToVideoPlayerExplicit": function () {
	            /**
	             * interfaces to video player
	             */
	            if (outstreamSelf.options.initialPlayback !== "auto" && !outstreamSelf.playerManager.isDoneInitialPlay) {
	                return;
	            }
	            if (!outstreamSelf.isPlayingVideo()) {
	                if (typeof outstreamSelf.playerManager.play === "function") {
	                    outstreamSelf.playerManager.explicitPlay();
	                    debug("sendPlaySignalToVideoPlayerExplicit");
	                }
	            }
	        },
	        "sendPlaySignalToVideoPlayer": function () {
	            /**
	             * interfaces to video player
	             */
	            if (outstreamSelf.options.initialPlayback !== "auto" && !outstreamSelf.playerManager.isDoneInitialPlay) {
	                return;
	            }
	            if (!outstreamSelf.isPlayingVideo()) {
	                if (typeof outstreamSelf.playerManager.play === "function" && !outstreamSelf.playerManager.explicitPaused) {
	                    outstreamSelf.playerManager.play();
	                    debug("sendPlaySignalToVideoPlayer");
	                }
	            }
	        },
	        "sendPauseSignalToVideoPlayerExplicit" : function () {
	            /**
	             * sendPauseSignalToVideoPlayer
	             */
	            if (outstreamSelf.isPlayingVideo()) {
	                if (typeof outstreamSelf.playerManager.explicitPause === "function") {
	                    outstreamSelf.playerManager.explicitPause();
	                }
	                debug("sendPauseSignalToVideoPlayerExplicit");
	            }
	        },
	        "sendPauseSignalToVideoPlayer" : function () {
	            if (outstreamSelf.isPlayingVideo()) {
	                if (typeof outstreamSelf.playerManager.pause === "function") {
	                    outstreamSelf.playerManager.pause();
	                }
	                debug("sendPauseSignalToVideoPlayer");
	            }
	        },
	    };
	};





/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var prefixOfLog = "Outstream_Events";
	var APN_Logger = __webpack_require__(2);
	var debug = function (message) {
	    APN_Logger.verbose(message, prefixOfLog);
	};
	var error = function (message) {
	    APN_Logger.error(message, prefixOfLog);
	};
	var info = function (message) {
	    APN_Logger.info(message, prefixOfLog);
	};

	var Utils = __webpack_require__(47);

	/**
	 * Events : event handling and adUnit behavior
	 * @param outstreamSelf
	 * @returns {{listenerBlur: "listenerBlur", listenerFocus: "listenerFocus", expandArea: "expandArea", detectAndPlay: "detectAndPlay", isElementVisible: "isElementVisible"}}
	 */
	module.exports = function (outstreamSelf) {
	    return {
	        "listenerBlur": function () {
	            if (outstreamSelf.playerManager.toggleWindowFocus === false) {//ks : if window already lost a focus this logic don't need to execute again for VID-2556
	                return;
	            }
	            if (!Utils.isFullScreen(outstreamSelf.playerManager) && outstreamSelf.playerManager.isPlayingVideo) {
	                var isVisible = outstreamSelf.isElementVisible(outstreamSelf.targetElement);//fix VIDLA-443
	                if (isVisible === true) {
	                    outstreamSelf.sendPauseSignalToVideoPlayer();
	                }
	                outstreamSelf.playerManager.toggleWindowFocus = false;//set toggle flag for VID-2556
	                info("pause a video by leaving a focus from the window");
	            }

	        },
	        "listenerFocus": function () {
	            if (outstreamSelf.playerManager.toggleWindowFocus === true) {//ks : if window already has focus don't need to do again for VID-2556
	                return;
	            }
	            var customVisibleThreshold = 1;//check whole element for detecting outstream is in video
	            var customHeight = (outstreamSelf.options.sideStream && outstreamSelf.options.sideStream.height && outstreamSelf.haveVideoThresholdForSideStream) ? outstreamSelf.options.sideStream.height : outstreamSelf.options.height;//if side stream is activated use the height of sideStream
	            var isVisibleAndFocus = outstreamSelf.isElementVisible(outstreamSelf.targetElement, customVisibleThreshold, customHeight);
	            if (outstreamSelf.playerManager) {
	                outstreamSelf.playerManager.isViewable = isVisibleAndFocus;
	            }
	            if (outstreamSelf.isExpanded && isVisibleAndFocus) {
	                outstreamSelf.sendPlaySignalToVideoPlayer();
	                outstreamSelf.playerManager.toggleWindowFocus = true;//set toggle flag for VID-2556
	            }
	            info("resume a video by having a focus on the window");
	        },
	        "setIsExpanded": function (val) {
	            //this is silly
	            outstreamSelf.isExpanded = val;
	            outstreamSelf.playerManager.isExpanded = val;
	        },
	        "expandArea": function () {
	            info("expand outstream area");

	            //for fix VID-1028 playbuzz unfriendly iframe issue with iOS
	            //main reason is an early invokation of Outstream.init cause unexpected 0 value as targetELement.offsetWidth when unfriendly iframe on playBuzz like 3rd party pages - www.playbuzz.com/mtveditorial10/taylor-swift-or-taylor-momsen-who-sang-these-lyrics?feed=true&src=http://www.playbuzz.com/mtveditorial10/taylor-swift-or-taylor-momsen-who-sang-these-lyrics&comments=undefined&divId=div0&articleCanonicalUrl=http%3A%2F%2Fwww.mtv.com%2Fnews%2F2876759%2Ftaylor-swift-momsen-pretty-reckless-lyrics-quiz%2F&width=640&height=auto&recommend=false&game=mtveditorial10/taylor-swift-or-taylor-momsen-who-sang-these-lyrics&useShares=false&useComments=false&gameInfo=false&embedBy=85b7478f-3761-4e11-be16-d1d587ba4c73&social=true&socialReferrer=false&pbads_debug=1&pbads_preview=test.outstream&pageLoadTrackerId=69787948938852610&shouldTrackLoading=true&parentHost=www.mtv.com&parentUrl=http%3A%2F%2Fwww.mtv.com%2Fnews%2F2876759%2Ftaylor-swift-momsen-pretty-reckless-lyrics-quiz%2F%3Fpbads_debug%3D1%26pbads_preview%3Dtest.outstream%26ast_debug%3Dtrue&referral=
	            if (Utils.isMobile() && outstreamSelf.playerManager.isIosInlineRequired() && !outstreamSelf.isWindowTopAccessible) {//this will be performed with only iOS and unfriendly iframe case
	                Utils.fireCustomEvent(outstreamSelf.options.targetElement, "IOS_INLINE_REFERESH");//this event will re-get offsetWidth of targetElement and resize video
	            }

	            //An event to handle css transition should be defined before starting the transition to make sure it's reliable
	            //invoke expandEnd when expand completed
	            outstreamSelf.targetElement.addEventListener("transitionend", function (e) {
	                if (!outstreamSelf.isExpandTransitionCompleted) {
	                    outstreamSelf.isExpandTransitionCompleted = true;
	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.expandEnd);
	                    if (outstreamSelf.options.initialPlayback !== "auto") {
	                        outstreamSelf.playerManager.delayEventHandler.suppress(false);
	                    }
	                }
	                /*jshint -W059 */
	                //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                e.target.removeEventListener(e.type, arguments.callee);//remove event handling, this will cause just one time event capturing
	                /*jshint -W059 */

	                outstreamSelf.reportFinalSize();
	            });

	            if (Utils.isChrome() && outstreamSelf.isFlash) {
	                //avoid situation to show ugly animation when it's blocked by Chrome
	                outstreamSelf.targetElement.style.position = "relative";
	                outstreamSelf.targetElement.addEventListener("transitionend", function (e) {
	                    if (outstreamSelf.options.initialPlayback !== "auto") {
	                        outstreamSelf.playerManager.delayEventHandler.suppress(false);
	                    }
	                    outstreamSelf.targetElement.style.left = "-0.1px";
	                    /*jshint -W059 */
	                    //arguments.callee is restricted when it's used over strict mode. but we don't use strict mode for now and this variable is required to do one time event handling
	                    e.target.removeEventListener(e.type, arguments.callee);
	                    /*jshint -W059 */
	                    setTimeout(function () {
	                        outstreamSelf.targetElement.style.left = "0px";
	                        outstreamSelf.isExpandedWhenFlash = true;
	                    }, 1);

	                });
	            }

	            //notify expandStart
	            outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.expandStart);

	            //css transition start
	            outstreamSelf.targetElement.style.height = outstreamSelf.options.height + "px";


	            //protection logic if it's in iOS and if transiotnEnd is not reliable
	            var gapOfRecheckTransition = 500;
	            setTimeout(function () {
	                if (!outstreamSelf.isExpandTransitionCompleted && outstreamSelf.targetElement.style.height === outstreamSelf.options.height + "px") {
	                    outstreamSelf.cbNotification(outstreamSelf.cbNotificationType.expandEnd);
	                    outstreamSelf.reportFinalSize();
	                    outstreamSelf.isExpandTransitionCompleted = true;
	                    if (outstreamSelf.options.initialPlayback !== "auto") {
	                        outstreamSelf.playerManager.delayEventHandler.suppress(false);
	                    }
	                }
	            }, outstreamSelf.animationSpeed * 1000 + gapOfRecheckTransition);


	            //if succeeded?
	            outstreamSelf.setIsExpanded(true);


	            if (outstreamSelf.options.vpaid) {
	                outstreamSelf.playerManager.dispatchEventToAdunit({"name": "creative-view"});
	            }


	        },
	        "detectAndPlay": function () {

	            if (outstreamSelf.videoIsreadyToPlay !== true || outstreamSelf.isAreadyTerminated) {//this videoIsreadyToPlay will set after got cbWhenReady from playerManager
	                return;//for VID-2106
	            }

	            if (Object.keys && Object.keys(outstreamSelf.playerManager).length === 0) {
	                // if playerManager is an emoty object, we are not ready to expand or load yet
	                return;
	            }

	            if (!outstreamSelf.isDoneLoadVideo) {
	                try {

	                    var willGoWithIosInline = Utils.isIos() && outstreamSelf.options.enableInlineVideoForIos === true;
	                    if (willGoWithIosInline === false) {//ios inline has their own video.load part
	                        outstreamSelf.playerManager.load();
	                    }

	                    outstreamSelf.isDoneLoadVideo = true;
	                } catch (ex) {
	                    error(ex);
	                }
	            }

	            //if video area is not expended, start to expend and play video
	            var elementIsVisible = outstreamSelf.isElementVisible(outstreamSelf.targetElement);
	            if (outstreamSelf.playerManager) {
	                outstreamSelf.playerManager.isViewable = elementIsVisible;
	            }

	            if (outstreamSelf.isExpanded === false && outstreamSelf.videoIsreadyToPlay && elementIsVisible && outstreamSelf.isOkToPlayFromPublisher) {

	                if (outstreamSelf.options.initialPlayback === "auto") {
	                    outstreamSelf.playerManager.isPlayingVideo = false;      // force to set playing flag to false, make sure the video will play (one time deal)
	                }

	                //expanda area
	                outstreamSelf.expandArea();

	                outstreamSelf.eventCB(outstreamSelf.ASTadId, outstreamSelf.cbType.impression, outstreamSelf.options);
	                //tigger loaded and impression at the same time
	                //this might change in the future, but for now let's leave it
	                outstreamSelf.eventCB(outstreamSelf.ASTadId, outstreamSelf.cbType.loaded, outstreamSelf.options);
	                outstreamSelf.setIsExpanded(true);
	                outstreamSelf.playerManager.pausedByViewability = true;

	                info("ready to start to play a video by videopausedByViewability true");

	                return;
	            }


	            //behaviors if video area is already expended
	            if (outstreamSelf.isExpanded) {
	                //for script
	                elementIsVisible = outstreamSelf.isElementVisible(outstreamSelf.targetElement);

	                //activate sideStream if it should
	                if (outstreamSelf.playerManager.isFullscreen === false && elementIsVisible === false && outstreamSelf.playerManager.isCompleted === false && outstreamSelf.doneInitialPlayback && outstreamSelf.options.sideStream.enabled === true && outstreamSelf.sideStream && outstreamSelf.haveVideoThresholdForSideStream === false && outstreamSelf.sideStream.checkPageOverlay() === true && outstreamSelf.options.impressionSent) {//for VID-1805, side stream activation needs to do checkPageOverlay()

	                    if (outstreamSelf.playerManager.isFullscreenToggled === true && Utils.isMobile() === false) {
	                        return;//for VID-2558 VID-2554 Desktop Safari, Firefox response lately from fullscreen change event so additional flag isFullscreenToggled will cover the situation. and it is set by playerManager
	                    }

	                    if (Utils.isIos() && outstreamSelf.options.enableInlineVideoForIos === false) {
	                        //not activate sideStream if enableInlineVideoForIos is false in iOS
	                    } else {
	                        if (Utils.isChrome() && outstreamSelf.isFlash) {//flash has a delay logic to set style.left and it can intefere with sideStream feature, so should wait until isExpandedWhenFlash is true at the case
	                            if (outstreamSelf.isExpandedWhenFlash) {
	                                outstreamSelf.sideStream.moveAdUnit();
	                                outstreamSelf.haveVideoThresholdForSideStream = true;

	                            }
	                        } else {
	                            outstreamSelf.sideStream.moveAdUnit();
	                            outstreamSelf.haveVideoThresholdForSideStream = true;
	                        }
	                        return;//don't need to pause/mute if sideStream is activated
	                    }
	                }

	                if (outstreamSelf.haveVideoThresholdForSideStream === true && outstreamSelf.sideStream.checkPageOverlay() === true) {//to avoid to go pause/mute if sidestream is alreay enabled.
	                    outstreamSelf.playerManager.isViewable = true;//for VID-1926 SideStream should be considered as always visible because it has fixed css attribute;
	                    return;
	                }

	                //a logic for mute by scroll
	                //this is for VID-1081, VID-1013
	                if (outstreamSelf.playerManager.isFullscreen && outstreamSelf.playerManager.isMuted && outstreamSelf.playerManager.hasBeenUnmuted) {
	                    outstreamSelf.playerManager.unmute();
	                    outstreamSelf.isMutedByViewability = false;
	                    outstreamSelf.playerManager.mutedByViewability = false;
	                } else if (outstreamSelf.options.nonViewableBehavior === "mute" && (outstreamSelf.playerManager && outstreamSelf.playerManager.isFullscreen === false) && !outstreamSelf.playerManager.isPaused) {
	                    if (elementIsVisible && outstreamSelf.isMutedByViewability === true) {
	                        outstreamSelf.playerManager.unmute();
	                        outstreamSelf.isMutedByViewability = false;
	                        outstreamSelf.playerManager.mutedByViewability = false;

	                        if (outstreamSelf.options.initialPlayback === "auto") {
	                            outstreamSelf.playerManager.delayEventHandler.suppress(false);
	                        }

	                    } else if (elementIsVisible === false && outstreamSelf.isMutedByViewability === false && outstreamSelf.playerManager.isMuted === false) {
	                        outstreamSelf.playerManager.mute();
	                        outstreamSelf.isMutedByViewability = true;
	                        outstreamSelf.playerManager.mutedByViewability = true;
	                    }

	                    if (outstreamSelf.doneInitialPlayback) {
	                        elementIsVisible = true;
	                    }
	                }

	                if (outstreamSelf.playerManager) {
	                    outstreamSelf.playerManager.isViewable = elementIsVisible;
	                }

	                //a logic for pause by scroll
	                if (elementIsVisible) {
	                    if (outstreamSelf.playerManager.pausedByViewability) {
	                        if (outstreamSelf.options.initialPlayback === "auto") {
	                            outstreamSelf.playerManager.delayEventHandler.suppress(false);
	                        }
	                        outstreamSelf.sendPlaySignalToVideoPlayerExplicit();
	                        outstreamSelf.playerManager.pausedByViewability = false;
	                        debug("set pausedByViewability false");
	                        outstreamSelf.doneInitialPlayback = true;
	                        if (Utils.isAndroid()) {
	                            outstreamSelf.rWindowForPublisher.removeEventListener("touchmove", outstreamSelf.detectAndPlay);
	                            outstreamSelf.intervalIdForDetectAndPlay = setInterval(outstreamSelf.detectAndPlay, outstreamSelf.options.intervals.playAndPause);//if it's in cross domain iframe environment, AST renderer will dispatch an event of top frame by parentIframeGeometryUpdate method
	                        }

	                    } else if (outstreamSelf.firstAdAttempted && outstreamSelf.videoIsreadyToPlay && !outstreamSelf.playerManager.isDoneInitialPlay) {
	                        outstreamSelf.sendPlaySignalToVideoPlayerExplicit();
	                    }
	                } else {
	                    if (!Utils.isFullScreen(outstreamSelf.playerManager)) {
	                        if (outstreamSelf.playerManager.isDoneInitialPlay && outstreamSelf.playerManager.pausedByViewability === false && !outstreamSelf.playerManager.explicitPaused) {//VID-1795
	                            outstreamSelf.sendPauseSignalToVideoPlayerExplicit();
	                            debug("set pausedByViewability true");
	                            outstreamSelf.playerManager.pausedByViewability = true;
	                        }
	                    }
	                }

	            }


	        },
	        "isElementVisible": function (element, customVisibleThreshold, customHeight) {

	            // var elementToCheckTopMost = null;
	            // var rateOfBeaconsForTopMostCheck = null;
	            // if (outstreamSelf.options.topMostViewableCheck.enabled === true) {
	            //     if (element && element.children && element.children.length > 0 && element.children[0]) {
	            //         elementToCheckTopMost = element.children[0];//outstream will use iframe instead of target div because of more accutrate calculation - target div can have 0.x value due to a mechanism of browsers
	            //     } else {
	            //         elementToCheckTopMost = element;
	            //     }
	            //     rateOfBeaconsForTopMostCheck = outstreamSelf.options.topMostViewableCheck.rateOfBeacons;
	            // }
	            // var param = {
	            //     element: element,
	            //     rWindowForPublisher: outstreamSelf.rWindowForPublisher,
	            //     isExpanded: outstreamSelf.isExpanded,
	            //     isWindowTopAccessible: outstreamSelf.isWindowTopAccessible,
	            //     iframeWindowHeight: outstreamSelf.currentEventFromCrossDomainWindow.windowHeight,
	            //     iframeOffsetTop: outstreamSelf.currentEventFromCrossDomainWindow.offsetTop,
	            //     customVisibleThreshold: customVisibleThreshold,
	            //     customHeight: customHeight,
	            //     elementToCheckTopMost: elementToCheckTopMost,
	            //     rateOfBeaconsForTopMostCheck: rateOfBeaconsForTopMostCheck,
	            //     videoHeight: outstreamSelf.options.height,
	            //     playVideoVisibleThreshold: outstreamSelf.options.playVideoVisibleThreshold,
	            //     checkVerticalOnly: outstreamSelf.options.topMostViewableCheck.checkVerticalOnly,
	            //     parentIframeIsModal: outstreamSelf.parentIframeIsModal
	            // };
	            // return outstreamSelf.viewableDetector.isElementVisible(param);


	            //refactor to reduce garbage collection on Chrome
	            if (outstreamSelf.options.topMostViewableCheck.enabled === true) {
	                if (element && element.children && element.children.length > 0 && element.children[0]) {
	                    outstreamSelf.elementToCheckTopMost = element.children[0];//outstream will use iframe instead of target div because of more accutrate calculation - target div can have 0.x value due to a mechanism of browsers
	                } else {
	                    outstreamSelf.elementToCheckTopMost = element;
	                }
	                outstreamSelf.rateOfBeaconsForTopMostCheck = outstreamSelf.options.topMostViewableCheck.rateOfBeacons;
	            }

	            return outstreamSelf.viewableDetector(
	                element,
	                outstreamSelf.rWindowForPublisher,
	                outstreamSelf.isExpanded,
	                outstreamSelf.isWindowTopAccessible,
	                outstreamSelf.currentEventFromCrossDomainWindow.windowHeight,
	                outstreamSelf.currentEventFromCrossDomainWindow.offsetTop,
	                customVisibleThreshold,
	                customHeight,
	                outstreamSelf.elementToCheckTopMost,
	                outstreamSelf.rateOfBeaconsForTopMostCheck,
	                outstreamSelf.options.height,
	                outstreamSelf.options.playVideoVisibleThreshold,
	                outstreamSelf.options.topMostViewableCheck.checkVerticalOnly,
	                outstreamSelf.parentIframeIsModal
	            );

	        }
	    };
	};





/***/ }
/******/ ]);